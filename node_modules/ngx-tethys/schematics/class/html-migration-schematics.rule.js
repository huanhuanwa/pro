"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HtmlMigrationSchematicsRule = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const path = tslib_1.__importStar(require("path"));
const cyia_code_util_1 = require("cyia-code-util");
function HtmlMigrationSchematicsRule(migrationList) {
    return (tree, context) => {
        const updateFileService = utils_1.createUpdateFileService(tree);
        const angularConfig = utils_1.getAngularJson(tree);
        const tsConfigList = utils_1.getWorkspaceAllTsconfig(angularConfig);
        const transformedList = [];
        const htmlPathList = [];
        for (const tsConfig of tsConfigList) {
            const readResult = typescript_1.default.readConfigFile(tsConfig, e => {
                return tree.read(path.resolve('/', e)).toString();
            });
            if (readResult.error) {
                throw new Error(`read ${tsConfig} fail`);
            }
            const config = readResult.config;
            const basePath = path.dirname(path.join('/', tsConfig));
            const parseContent = typescript_1.default.parseJsonConfigFileContent(config, utils_1.creatTreeTsParseConfigHost(tree), basePath, {});
            const program = typescript_1.default.createProgram({
                host: utils_1.createTreeCompilerHost(parseContent.options, tree),
                rootNames: parseContent.fileNames,
                options: parseContent.options
            });
            program
                .getSourceFiles()
                .filter(sf => !sf.fileName.includes('node_modules'))
                .filter(item => !transformedList.includes(item.fileName))
                .forEach(sf => {
                const instance = cyia_code_util_1.createCssSelectorForTs(sf);
                const templateUrlNodeList = instance.queryAll('CallExpression[expression=Component] PropertyAssignment[name=templateUrl]');
                templateUrlNodeList
                    .sort((a, b) => b.pos - a.pos)
                    .forEach(item => {
                    const htmlPath = path.join(path.dirname(sf.fileName), item.initializer.text);
                    if (htmlPathList.includes(htmlPath)) {
                        return;
                    }
                    htmlPathList.push(htmlPath);
                    migrationList.forEach(Item => {
                        new Item(htmlPath, 0, cyia_code_util_1.createCssSelectorForHtml(tree.read(htmlPath).toString()), updateFileService).run();
                    });
                });
                const templateNodeList = instance.queryAll('CallExpression[expression=Component] PropertyAssignment[name=template]');
                templateNodeList
                    .sort((a, b) => b.pos - a.pos)
                    .forEach(item => {
                    if (htmlPathList.includes(sf.fileName)) {
                        return;
                    }
                    let str = item.initializer.getText();
                    str = str.substr(1, str.length - 2);
                    migrationList.forEach(Item => {
                        new Item(sf.fileName, item.initializer.getStart() + 1, cyia_code_util_1.createCssSelectorForHtml(str), updateFileService).run();
                    });
                });
                htmlPathList.push(sf.fileName);
                transformedList.push(sf.fileName);
            });
        }
        return tree;
    };
}
exports.HtmlMigrationSchematicsRule = HtmlMigrationSchematicsRule;
