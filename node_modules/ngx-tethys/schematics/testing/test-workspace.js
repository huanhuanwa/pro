"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTestWorkspaceFactory = exports.TestWorkspaceFactory = void 0;
const tslib_1 = require("tslib");
const schematics_1 = require("@angular-devkit/schematics");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
class TestWorkspaceFactory {
    constructor(runner) {
        this.runner = runner;
        this.hostTree = new schematics_1.HostTree();
    }
    create(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.tree = yield this.runner
                .runExternalSchematicAsync('@schematics/angular', 'workspace', Object.assign({ name: 'test-workspace', version: '9.0.0', newProjectRoot: 'projects' }, options), this.hostTree)
                .toPromise();
            return this.tree;
        });
    }
    addApplication(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.tree = yield this.runner.runExternalSchematicAsync('@schematics/angular', 'application', options, this.tree).toPromise();
            return this.tree;
        });
    }
    addLibrary(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.tree = yield this.runner.runExternalSchematicAsync('@schematics/angular', 'library', options, this.tree).toPromise();
            return this.tree;
        });
    }
    addNewFile(templatePath, content) {
        this.hostTree.create(templatePath, content);
        return this.tree;
    }
    /**
     * @description 复制硬盘中的资源到虚拟的tree中,目前并没用用到,因为换了一种方案,但是好不容易写的就不删了
     * @param from 真实路径
     * @param to 虚拟路径
     */
    copyFolder(from, to, overwrite = false) {
        if (!fs.existsSync(from)) {
            throw new Error(`${from} folder not found`);
        }
        const list = fs.readdirSync(from);
        const toAddList = [{ parentFromPath: from, parentToPath: to, children: list }];
        while (toAddList.length) {
            const item = toAddList.pop();
            for (let i = 0; i < item.children.length; i++) {
                const element = item.children[i];
                const absolutePath = path.resolve(item.parentFromPath, element);
                const stat = fs.statSync(absolutePath);
                if (stat.isDirectory()) {
                    toAddList.push({
                        parentFromPath: absolutePath,
                        parentToPath: path.join(item.parentToPath, element),
                        children: fs.readdirSync(absolutePath)
                    });
                }
                else {
                    if (this.hostTree.exists(path.join(item.parentToPath, element))) {
                        if (overwrite) {
                            this.hostTree.overwrite(path.join(item.parentToPath, element), fs.readFileSync(absolutePath));
                        }
                        continue;
                    }
                    this.hostTree.create(path.join(item.parentToPath, element), fs.readFileSync(absolutePath));
                }
            }
        }
        return this.tree;
    }
    getTree() {
        return this.tree;
    }
}
exports.TestWorkspaceFactory = TestWorkspaceFactory;
function createTestWorkspaceFactory(runner) {
    return new TestWorkspaceFactory(runner);
}
exports.createTestWorkspaceFactory = createTestWorkspaceFactory;
