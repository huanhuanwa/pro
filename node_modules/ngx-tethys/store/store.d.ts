import { Observable, Observer, BehaviorSubject, Subscription } from 'rxjs';
import { OnDestroy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export declare class Store<T = unknown> implements Observer<T>, OnDestroy {
    initialStateCache: any;
    state$: BehaviorSubject<T>;
    reduxToolEnabled: boolean;
    private _defaultStoreInstanceId;
    constructor(initialState: any);
    get snapshot(): T;
    dispatch(type: string, payload?: any): Observable<any>;
    private _dispatch;
    select<TResult>(selector: (state: T) => TResult): Observable<TResult> | Observable<TResult>;
    next(state: T): void;
    error(error: any): void;
    complete(): void;
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
    /**
     * set store new state
     *
     * @example
     * this.setState(newState);
     * this.setState({ users: produce(this.snapshot.users).add(user) });
     * this.setState((state) => {
     *    return {
     *        users: produce(state.users).add(user)
     *    }
     * });
     * @param fn
     */
    setState(fn: Partial<T> | ((newState: T) => Partial<T>)): void;
    getState(): T;
    clearState(): void;
    ngOnDestroy(): void;
    /**
     * You can override this method if you want to give your container instance a custom id.
     * The returned id must be unique in the application.
     */
    getStoreInstanceId(): string;
    private _getClassName;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Store<any>, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Store<any>>;
}

//# sourceMappingURL=store.d.ts.map