import { __decorate, __metadata } from "tslib";
import { InputBoolean } from 'ngx-tethys/core';
import { Component, HostBinding, ViewEncapsulation, Optional, Input } from '@angular/core';
import { ThyFormDirective } from '../form.directive';
export class ThyFormGroupErrorComponent {
    constructor(thyParentForm) {
        this.thyParentForm = thyParentForm;
        this.thyShowFirst = true;
        this.isHorizontal = true;
    }
    set thyErrors(errors) {
        this.errors = errors;
    }
    get thyErrors() {
        const errors = this.errors || this.thyParentForm.validator.errors;
        return errors && errors.length > 0 && this.thyShowFirst ? [errors[0]] : errors;
    }
    get _isFormGroup() {
        return this.thyErrors && this.thyErrors.length > 0;
    }
    ngOnInit() {
        if (this.thyParentForm) {
            this.isHorizontal = this.thyParentForm.isHorizontal;
        }
    }
}
ThyFormGroupErrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-form-group-error',
                template: "<div [ngClass]=\"{ 'col-sm-10 offset-sm-2 col-form-control': isHorizontal }\">\n  <thy-alert *ngFor=\"let error of thyErrors\" thyType=\"danger\" [thyMessage]=\"error\"></thy-alert>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
ThyFormGroupErrorComponent.ctorParameters = () => [
    { type: ThyFormDirective, decorators: [{ type: Optional }] }
];
ThyFormGroupErrorComponent.propDecorators = {
    thyShowFirst: [{ type: Input }],
    thyErrors: [{ type: Input }],
    _isFormGroup: [{ type: HostBinding, args: ['class.form-group',] }],
    isHorizontal: [{ type: HostBinding, args: ['class.row',] }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], ThyFormGroupErrorComponent.prototype, "thyShowFirst", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1ncm91cC1lcnJvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZm9ybS9mb3JtLWdyb3VwLWVycm9yL2Zvcm0tZ3JvdXAtZXJyb3IuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsaUJBQWlCLEVBQVUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQU9yRCxNQUFNLE9BQU8sMEJBQTBCO0lBc0JuQyxZQUFnQyxhQUErQjtRQUEvQixrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7UUFuQnRDLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBaUJuQixpQkFBWSxHQUFHLElBQUksQ0FBQztJQUVvQixDQUFDO0lBakJuRSxJQUNJLFNBQVMsQ0FBQyxNQUFnQjtRQUMxQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBSSxTQUFTO1FBQ1QsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDbEUsT0FBTyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ25GLENBQUM7SUFFRCxJQUNJLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFNRCxRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUM7U0FDdkQ7SUFDTCxDQUFDOzs7WUFqQ0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxzQkFBc0I7Z0JBQ2hDLDJNQUFnRDtnQkFDaEQsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7YUFDeEM7OztZQU5RLGdCQUFnQix1QkE2QlIsUUFBUTs7OzJCQW5CcEIsS0FBSzt3QkFFTCxLQUFLOzJCQVVMLFdBQVcsU0FBQyxrQkFBa0I7MkJBSzlCLFdBQVcsU0FBQyxXQUFXOztBQWpCQztJQUFmLFlBQVksRUFBRTs7Z0VBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXRCb29sZWFuIH0gZnJvbSAnbmd4LXRldGh5cy9jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIFZpZXdFbmNhcHN1bGF0aW9uLCBPbkluaXQsIE9wdGlvbmFsLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGh5Rm9ybURpcmVjdGl2ZSB9IGZyb20gJy4uL2Zvcm0uZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0aHktZm9ybS1ncm91cC1lcnJvcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2Zvcm0tZ3JvdXAtZXJyb3IuY29tcG9uZW50Lmh0bWwnLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgVGh5Rm9ybUdyb3VwRXJyb3JDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIHB1YmxpYyBlcnJvcnM6IHN0cmluZ1tdO1xuXG4gICAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIHRoeVNob3dGaXJzdCA9IHRydWU7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB0aHlFcnJvcnMoZXJyb3JzOiBzdHJpbmdbXSkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG5cbiAgICBnZXQgdGh5RXJyb3JzKCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmVycm9ycyB8fCB0aGlzLnRoeVBhcmVudEZvcm0udmFsaWRhdG9yLmVycm9ycztcbiAgICAgICAgcmV0dXJuIGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoID4gMCAmJiB0aGlzLnRoeVNob3dGaXJzdCA/IFtlcnJvcnNbMF1dIDogZXJyb3JzO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZm9ybS1ncm91cCcpXG4gICAgZ2V0IF9pc0Zvcm1Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGh5RXJyb3JzICYmIHRoaXMudGh5RXJyb3JzLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5yb3cnKSBpc0hvcml6b250YWwgPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSB0aHlQYXJlbnRGb3JtOiBUaHlGb3JtRGlyZWN0aXZlKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRoeVBhcmVudEZvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gdGhpcy50aHlQYXJlbnRGb3JtLmlzSG9yaXpvbnRhbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==