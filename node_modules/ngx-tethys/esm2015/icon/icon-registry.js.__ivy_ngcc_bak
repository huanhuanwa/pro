import { Injectable, SecurityContext, Inject } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { of, forkJoin, throwError } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { finalize, share, map, tap, catchError } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/platform-browser";
import * as i2 from "@angular/common/http";
import * as i3 from "@angular/common";
class SvgIconConfig {
    constructor(data) {
        // Note that we can't use `instanceof SVGElement` here,
        // because it'll break during server-side rendering.
        if (!!data.nodeName) {
            this.svgElement = data;
        }
        else {
            this.url = data;
        }
    }
}
export class ThyIconRegistry {
    constructor(sanitizer, httpClient, document) {
        this.sanitizer = sanitizer;
        this.httpClient = httpClient;
        this.document = document;
        this.defaultFontSetClass = 'wt-icon';
        this.internalIconMode = 'svg';
        this.svgIconConfigs = new Map();
        this.svgIconSetConfigs = new Map();
        this.inProgressUrlFetches = new Map();
    }
    get iconMode() {
        return this.internalIconMode;
    }
    getIconNameNotFoundError(iconName) {
        return Error(`Unable to find icon with the name "${iconName}"`);
    }
    getIconFailedToSanitizeLiteralError(literal) {
        return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by ` +
            `Angular's DomSanitizer. Attempted literal was "${literal}".`);
    }
    internalAddSvgIconSet(namespace, config) {
        const configNamespace = this.svgIconSetConfigs.get(namespace);
        if (configNamespace) {
            configNamespace.push(config);
        }
        else {
            this.svgIconSetConfigs.set(namespace, [config]);
        }
        return this;
    }
    cloneSvg(svg) {
        return svg.cloneNode(true);
    }
    fetchUrl(safeUrl) {
        if (safeUrl == null) {
            throw Error(`Cannot fetch icon from URL "${safeUrl}".`);
        }
        const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
        if (!url) {
            throw new Error(`The URL provided to ThyIconRegistry was not trusted as a resource URL ` +
                `via Angular's DomSanitizer. Attempted URL was "${url}".`);
        }
        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
        // already a request in progress for that URL. It's necessary to call share() on the
        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
        const inProgressFetch = this.inProgressUrlFetches.get(url);
        if (inProgressFetch) {
            return inProgressFetch;
        }
        else {
            // TODO(jelbourn): for some reason, the `finalize` operator "loses" the generic type on the
            // Observable. Figure out why and fix it.
            const req = this.httpClient.get(url, { responseType: 'text' }).pipe(finalize(() => this.inProgressUrlFetches.delete(url)), share());
            this.inProgressUrlFetches.set(url, req);
            return req;
        }
    }
    toSvgElement(element) {
        const svg = this.svgElementFromString('<svg></svg>');
        for (let i = 0; i < element.childNodes.length; i++) {
            if (element.childNodes[i].nodeType === this.document.ELEMENT_NODE) {
                svg.appendChild(element.childNodes[i].cloneNode(true));
            }
        }
        return svg;
    }
    extractSvgIconFromIconSet(iconSet, iconName) {
        // Use the `id="iconName"` syntax in order to escape special
        // characters in the ID (versus using the #iconName syntax).
        const iconSource = iconSet.querySelector(`[id="${iconName}"]`);
        if (!iconSource) {
            return null;
        }
        // Clone the element and remove the ID to prevent multiple elements from being added
        // to the page with the same ID.
        const iconElement = iconSource.cloneNode(true);
        iconElement.removeAttribute('id');
        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
        // the content of a new <svg> node.
        if (iconElement.nodeName.toLowerCase() === 'svg') {
            return this.setSvgAttributes(iconElement);
        }
        // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note
        // that the same could be achieved by referring to it via <use href="#id">, however the <use>
        // tag is problematic on Firefox, because it needs to include the current page path.
        if (iconElement.nodeName.toLowerCase() === 'symbol') {
            return this.setSvgAttributes(this.toSvgElement(iconElement));
        }
        // createElement('SVG') doesn't work as expected; the DOM ends up with
        // the correct nodes, but the SVG content doesn't render. Instead we
        // have to create an empty SVG node using innerHTML and append its content.
        // Elements created using DOMParser.parseFromString have the same problem.
        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
        const svg = this.svgElementFromString('<svg></svg>');
        // Clone the node so we don't remove it from the parent icon set element.
        svg.appendChild(iconElement);
        return this.setSvgAttributes(svg);
    }
    extractIconWithNameFromIconSetConfigs(iconName, iconSetConfigs) {
        // Iterate backwards, so icon sets added later have precedence.
        for (let i = iconSetConfigs.length - 1; i >= 0; i--) {
            const config = iconSetConfigs[i];
            if (config.svgElement) {
                const foundIcon = this.extractSvgIconFromIconSet(config.svgElement, iconName);
                if (foundIcon) {
                    return foundIcon;
                }
            }
        }
        return null;
    }
    svgElementFromString(str) {
        const div = this.document.createElement('DIV');
        div.innerHTML = str;
        const svg = div.querySelector('svg');
        if (!svg) {
            throw Error('<svg> tag not found');
        }
        return svg;
    }
    setSvgAttributes(svg) {
        svg.setAttribute('fit', '');
        svg.setAttribute('height', '1em');
        svg.setAttribute('width', '1em');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
        return svg;
    }
    createSvgElementForSingleIcon(responseText) {
        const svg = this.svgElementFromString(responseText);
        this.setSvgAttributes(svg);
        return svg;
    }
    loadSvgIconFromConfig(config) {
        return this.fetchUrl(config.url).pipe(map(svgText => this.createSvgElementForSingleIcon(svgText)));
    }
    loadSvgIconSetFromConfig(config) {
        // If the SVG for this icon set has already been parsed, do nothing.
        if (config.svgElement) {
            return of(config.svgElement);
        }
        return this.fetchUrl(config.url).pipe(map(svgText => {
            // It is possible that the icon set was parsed and cached by an earlier request, so parsing
            // only needs to occur if the cache is yet unset.
            if (!config.svgElement) {
                config.svgElement = this.svgElementFromString(svgText);
            }
            return config.svgElement;
        }));
    }
    getSvgFromConfig(config) {
        if (config.svgElement) {
            // We already have the SVG element for this icon, return a copy.
            return of(this.cloneSvg(config.svgElement));
        }
        else {
            // Fetch the icon from the config's URL, cache it, and return a copy.
            return this.loadSvgIconFromConfig(config).pipe(tap(svg => (config.svgElement = svg)), map(svg => this.cloneSvg(svg)));
        }
    }
    getSvgFromIconSetConfigs(name, iconSetConfigs) {
        // For all the icon set SVG elements we've fetched, see if any contain an icon with the
        // requested name.
        const namedIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
        if (namedIcon) {
            // We could cache namedIcon in svgIconConfigs, but since we have to make a copy every
            // time anyway, there's probably not much advantage compared to just always extracting
            // it from the icon set.
            return of(namedIcon);
        }
        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
        // fetched, fetch them now and look for iconName in the results.
        const iconSetFetchRequests = iconSetConfigs
            .filter(iconSetConfig => !iconSetConfig.svgElement)
            .map(iconSetConfig => {
            return this.loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError((err) => {
                const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);
                // Swallow errors fetching individual URLs so the
                // combined Observable won't necessarily fail.
                console.error(`Loading icon set URL: ${url} failed: ${err.message}`);
                return of(null);
            }));
        });
        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
        // cached SVG element (unless the request failed), and we can check again for the icon.
        return forkJoin(iconSetFetchRequests).pipe(map(() => {
            const foundIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
            if (!foundIcon) {
                throw this.getIconNameNotFoundError(name);
            }
            return foundIcon;
        }));
    }
    internalAddSvgIconConfig(namespace, iconName, config) {
        this.svgIconConfigs.set(this.buildIconKey(namespace, iconName), config);
        return this;
    }
    buildIconKey(namespace, name) {
        return namespace + ':' + name;
    }
    splitIconName(iconName) {
        if (!iconName) {
            return ['', ''];
        }
        const parts = iconName.split(':');
        switch (parts.length) {
            case 1:
                return ['', parts[0]]; // Use default namespace.
            case 2:
                return parts;
            default:
                throw Error(`Invalid icon name: "${iconName}"`);
        }
    }
    addSvgIconSetInNamespace(namespace, url) {
        return this.internalAddSvgIconSet(namespace, new SvgIconConfig(url));
    }
    addSvgIconSet(url) {
        return this.addSvgIconSetInNamespace('', url);
    }
    addSvgIconSetLiteralInNamespace(namespace, literal) {
        const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);
        if (!sanitizedLiteral) {
            throw this.getIconFailedToSanitizeLiteralError(literal);
        }
        const svgElement = this.svgElementFromString(sanitizedLiteral);
        return this.internalAddSvgIconSet(namespace, new SvgIconConfig(svgElement));
    }
    addSvgIconSetLiteral(literal) {
        return this.addSvgIconSetLiteralInNamespace('', literal);
    }
    /**
     * Registers an icon by URL in the specified namespace.
     * @param namespace Namespace in which the icon should be registered.
     * @param iconName Name under which the icon should be registered.
     * @param url
     */
    addSvgIconInNamespace(namespace, iconName, url) {
        return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
    }
    /**
     * Registers an icon by URL in the default namespace.
     * @param iconName Name under which the icon should be registered.
     * @param url
     */
    addSvgIcon(iconName, url) {
        return this.addSvgIconInNamespace('', iconName, url);
    }
    /**
     * Registers an icon using an HTML string in the default namespace.
     * @param iconName Name under which the icon should be registered.
     * @param literal SVG source of the icon.
     */
    addSvgIconLiteral(iconName, literal) {
        return this.addSvgIconLiteralInNamespace('', iconName, literal);
    }
    /**
     * Registers an icon using an HTML string in the specified namespace.
     * @param namespace Namespace in which the icon should be registered.
     * @param iconName Name under which the icon should be registered.
     * @param literal SVG source of the icon.
     */
    addSvgIconLiteralInNamespace(namespace, iconName, literal) {
        const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);
        if (!sanitizedLiteral) {
            throw this.getIconFailedToSanitizeLiteralError(literal);
        }
        const svgElement = this.createSvgElementForSingleIcon(sanitizedLiteral);
        return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
    }
    getDefaultFontSetClass() {
        return this.defaultFontSetClass;
    }
    getFontSetClassByAlias(fontSet) {
        return fontSet;
    }
    getSvgIcon(name, namespace = '') {
        // Return (copy of) cached icon if possible.
        const key = this.buildIconKey(namespace, name);
        const config = this.svgIconConfigs.get(key);
        if (config) {
            return this.getSvgFromConfig(config);
        }
        // See if we have any icon sets registered for the namespace.
        const iconSetConfigs = this.svgIconSetConfigs.get(namespace);
        if (iconSetConfigs) {
            return this.getSvgFromIconSetConfigs(name, iconSetConfigs);
        }
        return throwError(this.getIconNameNotFoundError(key));
    }
    setIconMode(mode) {
        this.internalIconMode = mode;
    }
}
ThyIconRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyIconRegistry_Factory() { return new ThyIconRegistry(i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(i3.DOCUMENT)); }, token: ThyIconRegistry, providedIn: "root" });
ThyIconRegistry.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ThyIconRegistry.ctorParameters = () => [
    { type: DomSanitizer },
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi1yZWdpc3RyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9pY29uL2ljb24tcmVnaXN0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQVUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVFLE9BQU8sRUFBNkIsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDcEYsT0FBTyxFQUFjLEVBQUUsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBRSxVQUFVLEVBQXFCLE1BQU0sc0JBQXNCLENBQUM7QUFDckUsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7O0FBRTNDLE1BQU0sYUFBYTtJQUlmLFlBQVksSUFBa0M7UUFDMUMsdURBQXVEO1FBQ3ZELG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsQ0FBRSxJQUFZLENBQUMsUUFBUSxFQUFFO1lBQzFCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBa0IsQ0FBQztTQUN4QzthQUFNO1lBQ0gsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUF1QixDQUFDO1NBQ3RDO0lBQ0wsQ0FBQztDQUNKO0FBT0QsTUFBTSxPQUFPLGVBQWU7SUFXeEIsWUFBb0IsU0FBdUIsRUFBVSxVQUFzQixFQUE0QixRQUFhO1FBQWhHLGNBQVMsR0FBVCxTQUFTLENBQWM7UUFBVSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQTRCLGFBQVEsR0FBUixRQUFRLENBQUs7UUFWNUcsd0JBQW1CLEdBQUcsU0FBUyxDQUFDO1FBQ2hDLHFCQUFnQixHQUFhLEtBQUssQ0FBQztRQUNuQyxtQkFBYyxHQUFHLElBQUksR0FBRyxFQUF5QixDQUFD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LEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMvQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUU1QyxJQUFJLE1BQU0sRUFBRTtZQUNSLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsNkRBQTZEO1FBQzdELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFN0QsSUFBSSxjQUFjLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQzlEO1FBRUQsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVELFdBQVcsQ0FBQyxJQUFjO1FBQ3RCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7SUFDakMsQ0FBQzs7OztZQXBYSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQXpCbUMsWUFBWTtZQUV2QyxVQUFVOzRDQW1DK0QsTUFBTSxTQUFDLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBTZWN1cml0eUNvbnRleHQsIGluamVjdCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTYWZlUmVzb3VyY2VVcmwsIFNhZmVIdG1sLCBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBmb3JrSm9pbiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSHR0cENsaWVudCwgSHR0cEVycm9yUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBmaW5hbGl6ZSwgc2hhcmUsIG1hcCwgdGFwLCBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5jbGFzcyBTdmdJY29uQ29uZmlnIHtcbiAgICB1cmw6IFNhZmVSZXNvdXJjZVVybCB8IG51bGw7XG4gICAgc3ZnRWxlbWVudDogU1ZHRWxlbWVudCB8IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihkYXRhOiBTYWZlUmVzb3VyY2VVcmwgfCBTVkdFbGVtZW50KSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCB1c2UgYGluc3RhbmNlb2YgU1ZHRWxlbWVudGAgaGVyZSxcbiAgICAgICAgLy8gYmVjYXVzZSBpdCdsbCBicmVhayBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgICAgICBpZiAoISEoZGF0YSBhcyBhbnkpLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnQgPSBkYXRhIGFzIFNWR0VsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IGRhdGEgYXMgU2FmZVJlc291cmNlVXJsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBJY29uTW9kZSA9ICdmb250JyB8ICdzdmcnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRoeUljb25SZWdpc3RyeSB7XG4gICAgcHJpdmF0ZSBkZWZhdWx0Rm9udFNldENsYXNzID0gJ3d0LWljb24nO1xuICAgIHByaXZhdGUgaW50ZXJuYWxJY29uTW9kZTogSWNvbk1vZGUgPSAnc3ZnJztcbiAgICBwcml2YXRlIHN2Z0ljb25Db25maWdzID0gbmV3IE1hcDxzdHJpbmcsIFN2Z0ljb25Db25maWc+KCk7XG4gICAgcHJpdmF0ZSBzdmdJY29uU2V0Q29uZmlncyA9IG5ldyBNYXA8c3RyaW5nLCBTdmdJY29uQ29uZmlnW10+KCk7XG4gICAgcHJpdmF0ZSBpblByb2dyZXNzVXJsRmV0Y2hlcyA9IG5ldyBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPHN0cmluZz4+KCk7XG5cbiAgICBwdWJsaWMgZ2V0IGljb25Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEljb25Nb2RlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc2FuaXRpemVyOiBEb21TYW5pdGl6ZXIsIHByaXZhdGUgaHR0cENsaWVudDogSHR0cENsaWVudCwgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBkb2N1bWVudDogYW55KSB7fVxuXG4gICAgcHJpdmF0ZSBnZXRJY29uTmFtZU5vdEZvdW5kRXJyb3IoaWNvbk5hbWU6IHN0cmluZyk6IEVycm9yIHtcbiAgICAgICAgcmV0dXJuIEVycm9yKGBVbmFibGUgdG8gZmluZCBpY29uIHdpdGggdGhlIG5hbWUgXCIke2ljb25OYW1lfVwiYCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRJY29uRmFpbGVkVG9TYW5pdGl6ZUxpdGVyYWxFcnJvcihsaXRlcmFsOiBTYWZlSHRtbCk6IEVycm9yIHtcbiAgICAgICAgcmV0dXJuIEVycm9yKFxuICAgICAgICAgICAgYFRoZSBsaXRlcmFsIHByb3ZpZGVkIHRvIE1hdEljb25SZWdpc3RyeSB3YXMgbm90IHRydXN0ZWQgYXMgc2FmZSBIVE1MIGJ5IGAgK1xuICAgICAgICAgICAgICAgIGBBbmd1bGFyJ3MgRG9tU2FuaXRpemVyLiBBdHRlbXB0ZWQgbGl0ZXJhbCB3YXMgXCIke2xpdGVyYWx9XCIuYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW50ZXJuYWxBZGRTdmdJY29uU2V0KG5hbWVzcGFjZTogc3RyaW5nLCBjb25maWc6IFN2Z0ljb25Db25maWcpOiB0aGlzIHtcbiAgICAgICAgY29uc3QgY29uZmlnTmFtZXNwYWNlID0gdGhpcy5zdmdJY29uU2V0Q29uZmlncy5nZXQobmFtZXNwYWNlKTtcblxuICAgICAgICBpZiAoY29uZmlnTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBjb25maWdOYW1lc3BhY2UucHVzaChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdmdJY29uU2V0Q29uZmlncy5zZXQobmFtZXNwYWNlLCBbY29uZmlnXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb25lU3ZnKHN2ZzogU1ZHRWxlbWVudCk6IFNWR0VsZW1lbnQge1xuICAgICAgICByZXR1cm4gc3ZnLmNsb25lTm9kZSh0cnVlKSBhcyBTVkdFbGVtZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZmV0Y2hVcmwoc2FmZVVybDogU2FmZVJlc291cmNlVXJsIHwgbnVsbCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgICAgIGlmIChzYWZlVXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDYW5ub3QgZmV0Y2ggaWNvbiBmcm9tIFVSTCBcIiR7c2FmZVVybH1cIi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuc2FuaXRpemVyLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIHNhZmVVcmwpO1xuXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFRoZSBVUkwgcHJvdmlkZWQgdG8gVGh5SWNvblJlZ2lzdHJ5IHdhcyBub3QgdHJ1c3RlZCBhcyBhIHJlc291cmNlIFVSTCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHZpYSBBbmd1bGFyJ3MgRG9tU2FuaXRpemVyLiBBdHRlbXB0ZWQgVVJMIHdhcyBcIiR7dXJsfVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBpbi1wcm9ncmVzcyBmZXRjaGVzIHRvIGF2b2lkIHNlbmRpbmcgYSBkdXBsaWNhdGUgcmVxdWVzdCBmb3IgYSBVUkwgd2hlbiB0aGVyZSBpc1xuICAgICAgICAvLyBhbHJlYWR5IGEgcmVxdWVzdCBpbiBwcm9ncmVzcyBmb3IgdGhhdCBVUkwuIEl0J3MgbmVjZXNzYXJ5IHRvIGNhbGwgc2hhcmUoKSBvbiB0aGVcbiAgICAgICAgLy8gT2JzZXJ2YWJsZSByZXR1cm5lZCBieSBodHRwLmdldCgpIHNvIHRoYXQgbXVsdGlwbGUgc3Vic2NyaWJlcnMgZG9uJ3QgY2F1c2UgbXVsdGlwbGUgWEhScy5cbiAgICAgICAgY29uc3QgaW5Qcm9ncmVzc0ZldGNoID0gdGhpcy5pblByb2dyZXNzVXJsRmV0Y2hlcy5nZXQodXJsKTtcblxuICAgICAgICBpZiAoaW5Qcm9ncmVzc0ZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5Qcm9ncmVzc0ZldGNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IGZvciBzb21lIHJlYXNvbiwgdGhlIGBmaW5hbGl6ZWAgb3BlcmF0b3IgXCJsb3Nlc1wiIHRoZSBnZW5lcmljIHR5cGUgb24gdGhlXG4gICAgICAgICAgICAvLyBPYnNlcnZhYmxlLiBGaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LlxuICAgICAgICAgICAgY29uc3QgcmVxID0gdGhpcy5odHRwQ2xpZW50LmdldCh1cmwsIHsgcmVzcG9uc2VUeXBlOiAndGV4dCcgfSkucGlwZShcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLmluUHJvZ3Jlc3NVcmxGZXRjaGVzLmRlbGV0ZSh1cmwpKSxcbiAgICAgICAgICAgICAgICBzaGFyZSgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmluUHJvZ3Jlc3NVcmxGZXRjaGVzLnNldCh1cmwsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b1N2Z0VsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IFNWR0VsZW1lbnQge1xuICAgICAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0VsZW1lbnRGcm9tU3RyaW5nKCc8c3ZnPjwvc3ZnPicpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSB0aGlzLmRvY3VtZW50LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmRDaGlsZChlbGVtZW50LmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0U3ZnSWNvbkZyb21JY29uU2V0KGljb25TZXQ6IFNWR0VsZW1lbnQsIGljb25OYW1lOiBzdHJpbmcpOiBTVkdFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIC8vIFVzZSB0aGUgYGlkPVwiaWNvbk5hbWVcImAgc3ludGF4IGluIG9yZGVyIHRvIGVzY2FwZSBzcGVjaWFsXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgaW4gdGhlIElEICh2ZXJzdXMgdXNpbmcgdGhlICNpY29uTmFtZSBzeW50YXgpLlxuICAgICAgICBjb25zdCBpY29uU291cmNlID0gaWNvblNldC5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke2ljb25OYW1lfVwiXWApO1xuXG4gICAgICAgIGlmICghaWNvblNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9uZSB0aGUgZWxlbWVudCBhbmQgcmVtb3ZlIHRoZSBJRCB0byBwcmV2ZW50IG11bHRpcGxlIGVsZW1lbnRzIGZyb20gYmVpbmcgYWRkZWRcbiAgICAgICAgLy8gdG8gdGhlIHBhZ2Ugd2l0aCB0aGUgc2FtZSBJRC5cbiAgICAgICAgY29uc3QgaWNvbkVsZW1lbnQgPSBpY29uU291cmNlLmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50O1xuICAgICAgICBpY29uRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGljb24gbm9kZSBpcyBpdHNlbGYgYW4gPHN2Zz4gbm9kZSwgY2xvbmUgYW5kIHJldHVybiBpdCBkaXJlY3RseS4gSWYgbm90LCBzZXQgaXQgYXNcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgb2YgYSBuZXcgPHN2Zz4gbm9kZS5cbiAgICAgICAgaWYgKGljb25FbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdmdBdHRyaWJ1dGVzKGljb25FbGVtZW50IGFzIFNWR0VsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgYSA8c3ltYm9sPiwgaXQgd29uJ3QgYmUgcmVuZGVyZWQgc28gd2UgaGF2ZSB0byBjb252ZXJ0IGl0IGludG8gPHN2Zz4uIE5vdGVcbiAgICAgICAgLy8gdGhhdCB0aGUgc2FtZSBjb3VsZCBiZSBhY2hpZXZlZCBieSByZWZlcnJpbmcgdG8gaXQgdmlhIDx1c2UgaHJlZj1cIiNpZFwiPiwgaG93ZXZlciB0aGUgPHVzZT5cbiAgICAgICAgLy8gdGFnIGlzIHByb2JsZW1hdGljIG9uIEZpcmVmb3gsIGJlY2F1c2UgaXQgbmVlZHMgdG8gaW5jbHVkZSB0aGUgY3VycmVudCBwYWdlIHBhdGguXG4gICAgICAgIGlmIChpY29uRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3ZnQXR0cmlidXRlcyh0aGlzLnRvU3ZnRWxlbWVudChpY29uRWxlbWVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlRWxlbWVudCgnU1ZHJykgZG9lc24ndCB3b3JrIGFzIGV4cGVjdGVkOyB0aGUgRE9NIGVuZHMgdXAgd2l0aFxuICAgICAgICAvLyB0aGUgY29ycmVjdCBub2RlcywgYnV0IHRoZSBTVkcgY29udGVudCBkb2Vzbid0IHJlbmRlci4gSW5zdGVhZCB3ZVxuICAgICAgICAvLyBoYXZlIHRvIGNyZWF0ZSBhbiBlbXB0eSBTVkcgbm9kZSB1c2luZyBpbm5lckhUTUwgYW5kIGFwcGVuZCBpdHMgY29udGVudC5cbiAgICAgICAgLy8gRWxlbWVudHMgY3JlYXRlZCB1c2luZyBET01QYXJzZXIucGFyc2VGcm9tU3RyaW5nIGhhdmUgdGhlIHNhbWUgcHJvYmxlbS5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMzAwMzI3OC9zdmctaW5uZXJodG1sLWluLWZpcmVmb3gtY2FuLW5vdC1kaXNwbGF5XG4gICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRWxlbWVudEZyb21TdHJpbmcoJzxzdmc+PC9zdmc+Jyk7XG4gICAgICAgIC8vIENsb25lIHRoZSBub2RlIHNvIHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQgaWNvbiBzZXQgZWxlbWVudC5cbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdmdBdHRyaWJ1dGVzKHN2Zyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0SWNvbldpdGhOYW1lRnJvbUljb25TZXRDb25maWdzKGljb25OYW1lOiBzdHJpbmcsIGljb25TZXRDb25maWdzOiBTdmdJY29uQ29uZmlnW10pOiBTVkdFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIC8vIEl0ZXJhdGUgYmFja3dhcmRzLCBzbyBpY29uIHNldHMgYWRkZWQgbGF0ZXIgaGF2ZSBwcmVjZWRlbmNlLlxuICAgICAgICBmb3IgKGxldCBpID0gaWNvblNldENvbmZpZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGljb25TZXRDb25maWdzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRJY29uID0gdGhpcy5leHRyYWN0U3ZnSWNvbkZyb21JY29uU2V0KGNvbmZpZy5zdmdFbGVtZW50LCBpY29uTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kSWNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJY29uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN2Z0VsZW1lbnRGcm9tU3RyaW5nKHN0cjogc3RyaW5nKTogU1ZHRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBzdHI7XG4gICAgICAgIGNvbnN0IHN2ZyA9IGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKSBhcyBTVkdFbGVtZW50O1xuXG4gICAgICAgIGlmICghc3ZnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignPHN2Zz4gdGFnIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFN2Z0F0dHJpYnV0ZXMoc3ZnOiBTVkdFbGVtZW50KTogU1ZHRWxlbWVudCB7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZpdCcsICcnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzFlbScpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxZW0nKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsICdmYWxzZScpOyAvLyBEaXNhYmxlIElFMTEgZGVmYXVsdCBiZWhhdmlvciB0byBtYWtlIFNWR3MgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU3ZnRWxlbWVudEZvclNpbmdsZUljb24ocmVzcG9uc2VUZXh0OiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICAgICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdFbGVtZW50RnJvbVN0cmluZyhyZXNwb25zZVRleHQpO1xuICAgICAgICB0aGlzLnNldFN2Z0F0dHJpYnV0ZXMoc3ZnKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9XG5cbiAgICBwcml2YXRlIGxvYWRTdmdJY29uRnJvbUNvbmZpZyhjb25maWc6IFN2Z0ljb25Db25maWcpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hVcmwoY29uZmlnLnVybCkucGlwZShtYXAoc3ZnVGV4dCA9PiB0aGlzLmNyZWF0ZVN2Z0VsZW1lbnRGb3JTaW5nbGVJY29uKHN2Z1RleHQpKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkU3ZnSWNvblNldEZyb21Db25maWcoY29uZmlnOiBTdmdJY29uQ29uZmlnKTogT2JzZXJ2YWJsZTxTVkdFbGVtZW50PiB7XG4gICAgICAgIC8vIElmIHRoZSBTVkcgZm9yIHRoaXMgaWNvbiBzZXQgaGFzIGFscmVhZHkgYmVlbiBwYXJzZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmIChjb25maWcuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG9mKGNvbmZpZy5zdmdFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoVXJsKGNvbmZpZy51cmwpLnBpcGUoXG4gICAgICAgICAgICBtYXAoc3ZnVGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUgaWNvbiBzZXQgd2FzIHBhcnNlZCBhbmQgY2FjaGVkIGJ5IGFuIGVhcmxpZXIgcmVxdWVzdCwgc28gcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgbmVlZHMgdG8gb2NjdXIgaWYgdGhlIGNhY2hlIGlzIHlldCB1bnNldC5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdmdFbGVtZW50ID0gdGhpcy5zdmdFbGVtZW50RnJvbVN0cmluZyhzdmdUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLnN2Z0VsZW1lbnQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U3ZnRnJvbUNvbmZpZyhjb25maWc6IFN2Z0ljb25Db25maWcpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQ+IHtcbiAgICAgICAgaWYgKGNvbmZpZy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIFNWRyBlbGVtZW50IGZvciB0aGlzIGljb24sIHJldHVybiBhIGNvcHkuXG4gICAgICAgICAgICByZXR1cm4gb2YodGhpcy5jbG9uZVN2Zyhjb25maWcuc3ZnRWxlbWVudCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGljb24gZnJvbSB0aGUgY29uZmlnJ3MgVVJMLCBjYWNoZSBpdCwgYW5kIHJldHVybiBhIGNvcHkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkU3ZnSWNvbkZyb21Db25maWcoY29uZmlnKS5waXBlKFxuICAgICAgICAgICAgICAgIHRhcChzdmcgPT4gKGNvbmZpZy5zdmdFbGVtZW50ID0gc3ZnKSksXG4gICAgICAgICAgICAgICAgbWFwKHN2ZyA9PiB0aGlzLmNsb25lU3ZnKHN2ZykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTdmdGcm9tSWNvblNldENvbmZpZ3MobmFtZTogc3RyaW5nLCBpY29uU2V0Q29uZmlnczogU3ZnSWNvbkNvbmZpZ1tdKTogT2JzZXJ2YWJsZTxTVkdFbGVtZW50PiB7XG4gICAgICAgIC8vIEZvciBhbGwgdGhlIGljb24gc2V0IFNWRyBlbGVtZW50cyB3ZSd2ZSBmZXRjaGVkLCBzZWUgaWYgYW55IGNvbnRhaW4gYW4gaWNvbiB3aXRoIHRoZVxuICAgICAgICAvLyByZXF1ZXN0ZWQgbmFtZS5cbiAgICAgICAgY29uc3QgbmFtZWRJY29uID0gdGhpcy5leHRyYWN0SWNvbldpdGhOYW1lRnJvbUljb25TZXRDb25maWdzKG5hbWUsIGljb25TZXRDb25maWdzKTtcblxuICAgICAgICBpZiAobmFtZWRJY29uKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCBjYWNoZSBuYW1lZEljb24gaW4gc3ZnSWNvbkNvbmZpZ3MsIGJ1dCBzaW5jZSB3ZSBoYXZlIHRvIG1ha2UgYSBjb3B5IGV2ZXJ5XG4gICAgICAgICAgICAvLyB0aW1lIGFueXdheSwgdGhlcmUncyBwcm9iYWJseSBub3QgbXVjaCBhZHZhbnRhZ2UgY29tcGFyZWQgdG8ganVzdCBhbHdheXMgZXh0cmFjdGluZ1xuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgaWNvbiBzZXQuXG4gICAgICAgICAgICByZXR1cm4gb2YobmFtZWRJY29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdCBmb3VuZCBpbiBhbnkgY2FjaGVkIGljb24gc2V0cy4gSWYgdGhlcmUgYXJlIGljb24gc2V0cyB3aXRoIFVSTHMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgIC8vIGZldGNoZWQsIGZldGNoIHRoZW0gbm93IGFuZCBsb29rIGZvciBpY29uTmFtZSBpbiB0aGUgcmVzdWx0cy5cbiAgICAgICAgY29uc3QgaWNvblNldEZldGNoUmVxdWVzdHM6IE9ic2VydmFibGU8U1ZHRWxlbWVudCB8IG51bGw+W10gPSBpY29uU2V0Q29uZmlnc1xuICAgICAgICAgICAgLmZpbHRlcihpY29uU2V0Q29uZmlnID0+ICFpY29uU2V0Q29uZmlnLnN2Z0VsZW1lbnQpXG4gICAgICAgICAgICAubWFwKGljb25TZXRDb25maWcgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRTdmdJY29uU2V0RnJvbUNvbmZpZyhpY29uU2V0Q29uZmlnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICBjYXRjaEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVycjogSHR0cEVycm9yUmVzcG9uc2UpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQgfCBudWxsPiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgaWNvblNldENvbmZpZy51cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dhbGxvdyBlcnJvcnMgZmV0Y2hpbmcgaW5kaXZpZHVhbCBVUkxzIHNvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmVkIE9ic2VydmFibGUgd29uJ3QgbmVjZXNzYXJpbHkgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBMb2FkaW5nIGljb24gc2V0IFVSTDogJHt1cmx9IGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmV0Y2ggYWxsIHRoZSBpY29uIHNldCBVUkxzLiBXaGVuIHRoZSByZXF1ZXN0cyBjb21wbGV0ZSwgZXZlcnkgSWNvblNldCBzaG91bGQgaGF2ZSBhXG4gICAgICAgIC8vIGNhY2hlZCBTVkcgZWxlbWVudCAodW5sZXNzIHRoZSByZXF1ZXN0IGZhaWxlZCksIGFuZCB3ZSBjYW4gY2hlY2sgYWdhaW4gZm9yIHRoZSBpY29uLlxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oaWNvblNldEZldGNoUmVxdWVzdHMpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kSWNvbiA9IHRoaXMuZXh0cmFjdEljb25XaXRoTmFtZUZyb21JY29uU2V0Q29uZmlncyhuYW1lLCBpY29uU2V0Q29uZmlncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kSWNvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldEljb25OYW1lTm90Rm91bmRFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJY29uO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGludGVybmFsQWRkU3ZnSWNvbkNvbmZpZyhuYW1lc3BhY2U6IHN0cmluZywgaWNvbk5hbWU6IHN0cmluZywgY29uZmlnOiBTdmdJY29uQ29uZmlnKTogdGhpcyB7XG4gICAgICAgIHRoaXMuc3ZnSWNvbkNvbmZpZ3Muc2V0KHRoaXMuYnVpbGRJY29uS2V5KG5hbWVzcGFjZSwgaWNvbk5hbWUpLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBidWlsZEljb25LZXkobmFtZXNwYWNlOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlICsgJzonICsgbmFtZTtcbiAgICB9XG5cbiAgICBzcGxpdEljb25OYW1lKGljb25OYW1lOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmddIHtcbiAgICAgICAgaWYgKCFpY29uTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gaWNvbk5hbWUuc3BsaXQoJzonKTtcbiAgICAgICAgc3dpdGNoIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCBwYXJ0c1swXV07IC8vIFVzZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gPFtzdHJpbmcsIHN0cmluZ10+cGFydHM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGljb24gbmFtZTogXCIke2ljb25OYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UobmFtZXNwYWNlOiBzdHJpbmcsIHVybDogU2FmZVJlc291cmNlVXJsKTogdGhpcyB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQWRkU3ZnSWNvblNldChuYW1lc3BhY2UsIG5ldyBTdmdJY29uQ29uZmlnKHVybCkpO1xuICAgIH1cblxuICAgIGFkZFN2Z0ljb25TZXQodXJsOiBTYWZlUmVzb3VyY2VVcmwpOiB0aGlzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3ZnSWNvblNldEluTmFtZXNwYWNlKCcnLCB1cmwpO1xuICAgIH1cblxuICAgIGFkZFN2Z0ljb25TZXRMaXRlcmFsSW5OYW1lc3BhY2UobmFtZXNwYWNlOiBzdHJpbmcsIGxpdGVyYWw6IFNhZmVIdG1sKTogdGhpcyB7XG4gICAgICAgIGNvbnN0IHNhbml0aXplZExpdGVyYWwgPSB0aGlzLnNhbml0aXplci5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuSFRNTCwgbGl0ZXJhbCk7XG5cbiAgICAgICAgaWYgKCFzYW5pdGl6ZWRMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldEljb25GYWlsZWRUb1Nhbml0aXplTGl0ZXJhbEVycm9yKGxpdGVyYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuc3ZnRWxlbWVudEZyb21TdHJpbmcoc2FuaXRpemVkTGl0ZXJhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQWRkU3ZnSWNvblNldChuYW1lc3BhY2UsIG5ldyBTdmdJY29uQ29uZmlnKHN2Z0VsZW1lbnQpKTtcbiAgICB9XG5cbiAgICBhZGRTdmdJY29uU2V0TGl0ZXJhbChsaXRlcmFsOiBTYWZlSHRtbCk6IHRoaXMge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uU2V0TGl0ZXJhbEluTmFtZXNwYWNlKCcnLCBsaXRlcmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiBieSBVUkwgaW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSBOYW1lc3BhY2UgaW4gd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIGljb25OYW1lIE5hbWUgdW5kZXIgd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIGFkZFN2Z0ljb25Jbk5hbWVzcGFjZShuYW1lc3BhY2U6IHN0cmluZywgaWNvbk5hbWU6IHN0cmluZywgdXJsOiBTYWZlUmVzb3VyY2VVcmwpOiB0aGlzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBZGRTdmdJY29uQ29uZmlnKG5hbWVzcGFjZSwgaWNvbk5hbWUsIG5ldyBTdmdJY29uQ29uZmlnKHVybCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIGljb25OYW1lIE5hbWUgdW5kZXIgd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIGFkZFN2Z0ljb24oaWNvbk5hbWU6IHN0cmluZywgdXJsOiBTYWZlUmVzb3VyY2VVcmwpOiB0aGlzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3ZnSWNvbkluTmFtZXNwYWNlKCcnLCBpY29uTmFtZSwgdXJsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiB1c2luZyBhbiBIVE1MIHN0cmluZyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIGljb25OYW1lIE5hbWUgdW5kZXIgd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIGxpdGVyYWwgU1ZHIHNvdXJjZSBvZiB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBhZGRTdmdJY29uTGl0ZXJhbChpY29uTmFtZTogc3RyaW5nLCBsaXRlcmFsOiBTYWZlSHRtbCk6IHRoaXMge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uTGl0ZXJhbEluTmFtZXNwYWNlKCcnLCBpY29uTmFtZSwgbGl0ZXJhbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gdXNpbmcgYW4gSFRNTCBzdHJpbmcgaW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSBOYW1lc3BhY2UgaW4gd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIGljb25OYW1lIE5hbWUgdW5kZXIgd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIGxpdGVyYWwgU1ZHIHNvdXJjZSBvZiB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBhZGRTdmdJY29uTGl0ZXJhbEluTmFtZXNwYWNlKG5hbWVzcGFjZTogc3RyaW5nLCBpY29uTmFtZTogc3RyaW5nLCBsaXRlcmFsOiBTYWZlSHRtbCk6IHRoaXMge1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWRMaXRlcmFsID0gdGhpcy5zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LkhUTUwsIGxpdGVyYWwpO1xuXG4gICAgICAgIGlmICghc2FuaXRpemVkTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRJY29uRmFpbGVkVG9TYW5pdGl6ZUxpdGVyYWxFcnJvcihsaXRlcmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSB0aGlzLmNyZWF0ZVN2Z0VsZW1lbnRGb3JTaW5nbGVJY29uKHNhbml0aXplZExpdGVyYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFkZFN2Z0ljb25Db25maWcobmFtZXNwYWNlLCBpY29uTmFtZSwgbmV3IFN2Z0ljb25Db25maWcoc3ZnRWxlbWVudCkpO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRGb250U2V0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRGb250U2V0Q2xhc3M7XG4gICAgfVxuXG4gICAgZ2V0Rm9udFNldENsYXNzQnlBbGlhcyhmb250U2V0OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZvbnRTZXQ7XG4gICAgfVxuXG4gICAgZ2V0U3ZnSWNvbihuYW1lOiBzdHJpbmcsIG5hbWVzcGFjZTogc3RyaW5nID0gJycpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQ+IHtcbiAgICAgICAgLy8gUmV0dXJuIChjb3B5IG9mKSBjYWNoZWQgaWNvbiBpZiBwb3NzaWJsZS5cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5idWlsZEljb25LZXkobmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5zdmdJY29uQ29uZmlncy5nZXQoa2V5KTtcblxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdmdGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWUgaWYgd2UgaGF2ZSBhbnkgaWNvbiBzZXRzIHJlZ2lzdGVyZWQgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgICAgIGNvbnN0IGljb25TZXRDb25maWdzID0gdGhpcy5zdmdJY29uU2V0Q29uZmlncy5nZXQobmFtZXNwYWNlKTtcblxuICAgICAgICBpZiAoaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN2Z0Zyb21JY29uU2V0Q29uZmlncyhuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih0aGlzLmdldEljb25OYW1lTm90Rm91bmRFcnJvcihrZXkpKTtcbiAgICB9XG5cbiAgICBzZXRJY29uTW9kZShtb2RlOiBJY29uTW9kZSkge1xuICAgICAgICB0aGlzLmludGVybmFsSWNvbk1vZGUgPSBtb2RlO1xuICAgIH1cbn1cbiJdfQ==