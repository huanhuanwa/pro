import { Directive, ElementRef, NgZone, Input, ViewContainerRef, HostBinding, Optional, Inject, ChangeDetectorRef } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { ThyAutocompleteService } from './overlay/autocomplete.service';
import { ThyAutocompleteComponent } from './autocomplete.component';
import { ThyOptionSelectionChangeEvent } from 'ngx-tethys/shared';
import { DOCUMENT } from '@angular/common';
import { Subject, merge, fromEvent, of } from 'rxjs';
import { ESCAPE, UP_ARROW, ENTER, DOWN_ARROW, TAB } from 'ngx-tethys/util';
import { filter, map, take, delay, switchMap } from 'rxjs/operators';
import { ScrollToService } from 'ngx-tethys/core';
import { warnDeprecation } from 'ngx-tethys/util';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/overlay';
import * as ɵngcc2 from './overlay/autocomplete.service';
export class ThyAutocompleteTriggerDirective {
    constructor(elementRef, ngZone, overlay, autocompleteService, viewContainerRef, document, cdr) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.overlay = overlay;
        this.autocompleteService = autocompleteService;
        this.viewContainerRef = viewContainerRef;
        this.document = document;
        this.cdr = cdr;
        this.closeKeyEventStream = new Subject();
        this.panelOpened = false;
        this.thyOffset = 4;
        this.thyPlacement = 'bottomLeft';
    }
    set autocompleteComponent(data) {
        this._autocompleteComponent = data;
    }
    set autocomplete(data) {
        warnDeprecation(`The property thyAutocomplete will be deprecated, please use thyAutocompleteComponent instead.`);
        this._autocompleteComponent = data;
    }
    get autocompleteComponent() {
        return this._autocompleteComponent;
    }
    get activeOption() {
        if (this.autocompleteComponent && this.autocompleteComponent.keyManager) {
            return this.autocompleteComponent.keyManager.activeItem;
        }
        return null;
    }
    get panelClosingActions() {
        return merge(this.autocompleteComponent.thyOptionSelected, this.autocompleteComponent.keyManager.tabOut.pipe(filter(() => this.panelOpened)), this.closeKeyEventStream, this.getOutsideClickStream(), this.overlayRef ? this.overlayRef.detachments().pipe(filter(() => this.panelOpened)) : of()).pipe(
        // Normalize the output so we return a consistent type.
        map(event => (event instanceof ThyOptionSelectionChangeEvent ? event : null)));
    }
    ngOnInit() { }
    onFocus() {
        if (this.canOpen()) {
            this.openPanel();
        }
    }
    onKeydown(event) {
        const keyCode = event.keyCode;
        // Prevent the default action on all escape key presses. This is here primarily to bring IE
        // in line with other browsers. By default, pressing escape on IE will cause it to revert
        // the input value to the one that it had on focus, however it won't dispatch any events
        // which means that the model value will be out of sync with the view.
        if (keyCode === ESCAPE) {
            event.preventDefault();
        }
        if (this.activeOption && keyCode === ENTER && this.panelOpened) {
            this.activeOption.selectViaInteraction();
            this.resetActiveItem();
            event.preventDefault();
        }
        else if (this.autocompleteComponent) {
            const prevActiveItem = this.autocompleteComponent.keyManager.activeItem;
            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
            if (this.panelOpened || keyCode === TAB) {
                this.autocompleteComponent.keyManager.onKeydown(event);
            }
            else if (isArrowKey && this.canOpen()) {
                this.openPanel();
            }
            if ((isArrowKey || this.autocompleteComponent.keyManager.activeItem !== prevActiveItem) &&
                this.autocompleteComponent.keyManager.activeItem) {
                ScrollToService.scrollToElement(this.autocompleteComponent.keyManager.activeItem.element.nativeElement, this.autocompleteComponent.optionsContainer.nativeElement);
            }
        }
    }
    handleInput(event) {
        if (this.canOpen() && document.activeElement === event.target) {
            this.openPanel();
        }
    }
    openPanel() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            return;
        }
        const overlayRef = this.createOverlay();
        this.overlayRef = overlayRef;
        overlayRef.keydownEvents().subscribe(event => {
            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
            if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {
                this.resetActiveItem();
                this.closeKeyEventStream.next();
                // We need to stop propagation, otherwise the event will eventually
                // reach the input itself and cause the overlay to be reopened.
                event.stopPropagation();
                event.preventDefault();
            }
        });
        this.panelOpened = true;
        this.autocompleteComponent.open();
    }
    closePanel() {
        if (this.autocompleteRef) {
            this.autocompleteRef.close();
            this.cdr.detectChanges();
            this.closingActionsSubscription.unsubscribe();
        }
    }
    createOverlay() {
        const config = Object.assign({
            origin: this.elementRef.nativeElement,
            viewContainerRef: this.viewContainerRef,
            placement: this.thyPlacement,
            offset: this.thyOffset,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
            width: this.thyAutocompleteWidth || this.elementRef.nativeElement.clientWidth
        });
        this.autocompleteRef = this.autocompleteService.open(this.autocompleteComponent.contentTemplateRef, config);
        this.autocompleteRef.afterClosed().subscribe(() => {
            this.panelOpened = false;
            this.autocompleteComponent.close();
        });
        // delay 200ms to prevent emit document click rightnow
        this.autocompleteRef
            .afterOpened()
            .pipe(delay(200))
            .subscribe(() => {
            this.closingActionsSubscription = this.subscribeToClosingActions();
        });
        return this.autocompleteRef.getOverlayRef();
    }
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     */
    subscribeToClosingActions() {
        const firstStable = this.ngZone.onStable.asObservable().pipe(take(1));
        const optionChanges = this.autocompleteComponent.options.changes.pipe(
        // Defer emitting to the stream until the next tick, because changing
        // bindings in here will cause "changed after checked" errors.
        delay(0));
        // When the zone is stable initially, and when the option list changes...
        return (merge(firstStable, optionChanges)
            .pipe(
        // create a new stream of panelClosingActions, replacing any previous streams
        // that were created, and flatten it so our stream only emits closing events...
        switchMap(() => {
            this.resetActiveItem();
            if (this.panelOpened) {
                this.overlayRef.updatePosition();
            }
            return this.panelClosingActions;
        }), 
        // when the first closing event occurs...
        take(1))
            // set the value, close the panel, and complete.
            .subscribe(event => this.setValueAndClose(event)));
    }
    setValueAndClose(event) {
        if (event && event.option) {
            this.setValue(event.option.thyLabelText);
        }
        this.closePanel();
    }
    /** Stream of clicks outside of the autocomplete panel. */
    getOutsideClickStream() {
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter(event => {
            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
            // fall back to check the first element in the path of the click event.
            const clickTarget = event.target;
            const formField = null;
            return (this.panelOpened &&
                clickTarget !== this.elementRef.nativeElement &&
                (!formField || !formField.contains(clickTarget)) &&
                !!this.overlayRef &&
                !this.overlayRef.overlayElement.contains(clickTarget));
        }));
    }
    setValue(value) {
        this.elementRef.nativeElement.value = value;
        this.elementRef.nativeElement.focus();
    }
    canOpen() {
        const element = this.elementRef.nativeElement;
        return !element.readOnly && !element.disabled;
    }
    resetActiveItem() {
        this.autocompleteComponent.keyManager.setActiveItem(this.autocompleteComponent.thyAutoActiveFirstOption ? 0 : -1);
    }
    destroyPanel() {
        if (this.overlayRef) {
            this.closePanel();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
    }
    ngOnDestroy() {
        this.closeKeyEventStream.complete();
        this.destroyPanel();
    }
}
ThyAutocompleteTriggerDirective.ɵfac = function ThyAutocompleteTriggerDirective_Factory(t) { return new (t || ThyAutocompleteTriggerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ThyAutocompleteService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ThyAutocompleteTriggerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyAutocompleteTriggerDirective, selectors: [["input", "thyAutocompleteTrigger", ""], ["textarea", "thyAutocompleteTrigger", ""]], hostVars: 2, hostBindings: function ThyAutocompleteTriggerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function ThyAutocompleteTriggerDirective_input_HostBindingHandler($event) { return ctx.handleInput($event); })("focusin", function ThyAutocompleteTriggerDirective_focusin_HostBindingHandler() { return ctx.onFocus(); })("keydown", function ThyAutocompleteTriggerDirective_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-autocomplete-opened", ctx.panelOpened);
    } }, inputs: { thyOffset: "thyOffset", thyPlacement: "thyPlacement", autocompleteComponent: ["thyAutocompleteComponent", "autocompleteComponent"], autocomplete: ["thyAutocomplete", "autocomplete"], thyAutocompleteWidth: "thyAutocompleteWidth" }, exportAs: ["thyAutocompleteTrigger"] });
ThyAutocompleteTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Overlay },
    { type: ThyAutocompleteService },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef }
];
ThyAutocompleteTriggerDirective.propDecorators = {
    panelOpened: [{ type: HostBinding, args: [`class.thy-autocomplete-opened`,] }],
    autocompleteComponent: [{ type: Input, args: ['thyAutocompleteComponent',] }],
    autocomplete: [{ type: Input, args: ['thyAutocomplete',] }],
    thyOffset: [{ type: Input }],
    thyAutocompleteWidth: [{ type: Input }],
    thyPlacement: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteTriggerDirective, [{
        type: Directive,
        args: [{
                selector: 'input[thyAutocompleteTrigger], textarea[thyAutocompleteTrigger]',
                exportAs: 'thyAutocompleteTrigger',
                host: {
                    '(input)': 'handleInput($event)',
                    '(focusin)': 'onFocus()',
                    '(keydown)': 'onKeydown($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.Overlay }, { type: ɵngcc2.ThyAutocompleteService }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { panelOpened: [{
            type: HostBinding,
            args: [`class.thy-autocomplete-opened`]
        }], thyOffset: [{
            type: Input
        }], thyPlacement: [{
            type: Input
        }], autocompleteComponent: [{
            type: Input,
            args: ['thyAutocompleteComponent']
        }], autocomplete: [{
            type: Input,
            args: ['thyAutocomplete']
        }], thyAutocompleteWidth: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLnRyaWdnZXIuZGlyZWN0aXZlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS50cmlnZ2VyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFFVixNQUFNLEVBRU4sS0FBSyxFQUVMLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsUUFBUSxFQUNSLE1BQU0sRUFDTixpQkFBaUIsRUFDcEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRzNELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXhFLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3BFLE9BQU8sRUFBc0IsNkJBQTZCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUN0RixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBYyxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDL0UsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQU8sS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7QUFXbEQsTUFBTSxPQUFPLCtCQUErQjtBQUFHLElBdUQzQyxZQUNZLFVBQXNCLEVBQ3RCLE1BQWMsRUFDZCxPQUFnQixFQUNo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LElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ25DLFNBQVM7QUFDVCxJQUFJLENBQUM7QUFDTCxJQUNJLFdBQVc7QUFDZixRQUFRLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUM1QyxRQUFRLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUM1QixJQUFJLENBQUM7QUFDTDsyREF6UUMsU0FBUyxTQUFDLGtCQUNQLFFBQVEsRUFBRSxpRUFBaUUsa0JBQzNFLFFBQVEsRUFBRSx3QkFBd0Isa0JBQ2xDLElBQUksRUFBRSxzQkFDRixTQUFTLEVBQUUscUJBQXFCLHNCQUNoQyxXQUFXLEVBQUUsV0FBVyxzQkFDeEIsV0FBVyxFQUFFLG1CQUFtQixrQkFDbkMsY0FDSjs7Ozs7a1NBQ0k7QUFBQztBQUF5RCxZQXBDM0QsVUFBVTtBQUNaLFlBQ0UsTUFBTTtBQUNSLFlBVW1CLE9BQU87QUFBSSxZQUd2QixzQkFBc0I7QUFBSSxZQVYvQixnQkFBZ0I7QUFDbEIsNENBMEZPLFFBQVEsWUFBSSxNQUFNLFNBQUMsUUFBUTtBQUFTLFlBdkZ6QyxpQkFBaUI7QUFDbkI7QUFBRztBQUMyQiwwQkFtQzNCLFdBQVcsU0FBQywrQkFBK0I7QUFBTyxvQ0FFbEQsS0FBSyxTQUFDLDBCQUEwQjtBQUNoQywyQkFJQSxLQUFLLFNBQUMsaUJBQWlCO0FBQ3ZCLHdCQVNBLEtBQUs7QUFBSyxtQ0FFVixLQUFLO0FBQUssMkJBRVYsS0FBSztBQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbmplY3RhYmxlLFxuICAgIE5nWm9uZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgSW5wdXQsXG4gICAgT25Jbml0LFxuICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgT3B0aW9uYWwsXG4gICAgSW5qZWN0LFxuICAgIENoYW5nZURldGVjdG9yUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgT3ZlcmxheVJlZiwgT3ZlcmxheSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IEZvY3VzTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IFRoeU92ZXJsYXlEaXJlY3RpdmVCYXNlLCBUaHlQbGFjZW1lbnQgfSBmcm9tICduZ3gtdGV0aHlzL2NvcmUnO1xuaW1wb3J0IHsgVGh5QXV0b2NvbXBsZXRlU2VydmljZSB9IGZyb20gJy4vb3ZlcmxheS9hdXRvY29tcGxldGUuc2VydmljZSc7XG5pbXBvcnQgeyBUaHlBdXRvY29tcGxldGVSZWYgfSBmcm9tICcuL292ZXJsYXkvYXV0b2NvbXBsZXRlLXJlZic7XG5pbXBvcnQgeyBUaHlBdXRvY29tcGxldGVDb21wb25lbnQgfSBmcm9tICcuL2F1dG9jb21wbGV0ZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGh5T3B0aW9uQ29tcG9uZW50LCBUaHlPcHRpb25TZWxlY3Rpb25DaGFuZ2VFdmVudCB9IGZyb20gJ25neC10ZXRoeXMvc2hhcmVkJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUsIG1lcmdlLCBmcm9tRXZlbnQsIG9mLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEVTQ0FQRSwgVVBfQVJST1csIEVOVEVSLCBET1dOX0FSUk9XLCBUQUIgfSBmcm9tICduZ3gtdGV0aHlzL3V0aWwnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2UsIHRhcCwgZGVsYXksIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFNjcm9sbFRvU2VydmljZSB9IGZyb20gJ25neC10ZXRoeXMvY29yZSc7XG5pbXBvcnQgeyB3YXJuRGVwcmVjYXRpb24gfSBmcm9tICduZ3gtdGV0aHlzL3V0aWwnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2lucHV0W3RoeUF1dG9jb21wbGV0ZVRyaWdnZXJdLCB0ZXh0YXJlYVt0aHlBdXRvY29tcGxldGVUcmlnZ2VyXScsXG4gICAgZXhwb3J0QXM6ICd0aHlBdXRvY29tcGxldGVUcmlnZ2VyJyxcbiAgICBob3N0OiB7XG4gICAgICAgICcoaW5wdXQpJzogJ2hhbmRsZUlucHV0KCRldmVudCknLFxuICAgICAgICAnKGZvY3VzaW4pJzogJ29uRm9jdXMoKScsXG4gICAgICAgICcoa2V5ZG93biknOiAnb25LZXlkb3duKCRldmVudCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUaHlBdXRvY29tcGxldGVUcmlnZ2VyRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHByb3RlY3RlZCBvdmVybGF5UmVmOiBPdmVybGF5UmVmO1xuXG4gICAgcHJpdmF0ZSBhdXRvY29tcGxldGVSZWY6IFRoeUF1dG9jb21wbGV0ZVJlZjxUaHlBdXRvY29tcGxldGVDb21wb25lbnQ+O1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBjbG9zZUtleUV2ZW50U3RyZWFtID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIHByaXZhdGUgY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIHByaXZhdGUgX2F1dG9jb21wbGV0ZUNvbXBvbmVudDogVGh5QXV0b2NvbXBsZXRlQ29tcG9uZW50O1xuXG4gICAgQEhvc3RCaW5kaW5nKGBjbGFzcy50aHktYXV0b2NvbXBsZXRlLW9wZW5lZGApIHBhbmVsT3BlbmVkID0gZmFsc2U7XG5cbiAgICBASW5wdXQoJ3RoeUF1dG9jb21wbGV0ZUNvbXBvbmVudCcpXG4gICAgc2V0IGF1dG9jb21wbGV0ZUNvbXBvbmVudChkYXRhOiBUaHlBdXRvY29tcGxldGVDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlQ29tcG9uZW50ID0gZGF0YTtcbiAgICB9XG5cbiAgICBASW5wdXQoJ3RoeUF1dG9jb21wbGV0ZScpXG4gICAgc2V0IGF1dG9jb21wbGV0ZShkYXRhOiBUaHlBdXRvY29tcGxldGVDb21wb25lbnQpIHtcbiAgICAgICAgd2FybkRlcHJlY2F0aW9uKGBUaGUgcHJvcGVydHkgdGh5QXV0b2NvbXBsZXRlIHdpbGwgYmUgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aHlBdXRvY29tcGxldGVDb21wb25lbnQgaW5zdGVhZC5gKTtcbiAgICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlQ29tcG9uZW50ID0gZGF0YTtcbiAgICB9XG5cbiAgICBnZXQgYXV0b2NvbXBsZXRlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b2NvbXBsZXRlQ29tcG9uZW50O1xuICAgIH1cblxuICAgIEBJbnB1dCgpIHRoeU9mZnNldCA9IDQ7XG5cbiAgICBASW5wdXQoKSB0aHlBdXRvY29tcGxldGVXaWR0aDogbnVtYmVyO1xuXG4gICAgQElucHV0KCkgdGh5UGxhY2VtZW50OiBUaHlQbGFjZW1lbnQgPSAnYm90dG9tTGVmdCc7XG5cbiAgICBnZXQgYWN0aXZlT3B0aW9uKCk6IFRoeU9wdGlvbkNvbXBvbmVudCB8IG51bGwge1xuICAgICAgICBpZiAodGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQgJiYgdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LmtleU1hbmFnZXIuYWN0aXZlSXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGdldCBwYW5lbENsb3NpbmdBY3Rpb25zKCk6IE9ic2VydmFibGU8VGh5T3B0aW9uU2VsZWN0aW9uQ2hhbmdlRXZlbnQgfCBudWxsPiB7XG4gICAgICAgIHJldHVybiBtZXJnZShcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LnRoeU9wdGlvblNlbGVjdGVkLFxuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlci50YWJPdXQucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5wYW5lbE9wZW5lZCkpLFxuICAgICAgICAgICAgdGhpcy5jbG9zZUtleUV2ZW50U3RyZWFtLFxuICAgICAgICAgICAgdGhpcy5nZXRPdXRzaWRlQ2xpY2tTdHJlYW0oKSxcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZiA/IHRoaXMub3ZlcmxheVJlZi5kZXRhY2htZW50cygpLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMucGFuZWxPcGVuZWQpKSA6IG9mKClcbiAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBvdXRwdXQgc28gd2UgcmV0dXJuIGEgY29uc2lzdGVudCB0eXBlLlxuICAgICAgICAgICAgbWFwKGV2ZW50ID0+IChldmVudCBpbnN0YW5jZW9mIFRoeU9wdGlvblNlbGVjdGlvbkNoYW5nZUV2ZW50ID8gZXZlbnQgOiBudWxsKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgICAgICBwcml2YXRlIG92ZXJsYXk6IE92ZXJsYXksXG4gICAgICAgIHByaXZhdGUgYXV0b2NvbXBsZXRlU2VydmljZTogVGh5QXV0b2NvbXBsZXRlU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnksXG4gICAgICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICAgICkge31cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge31cblxuICAgIG9uRm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbk9wZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiBvbiBhbGwgZXNjYXBlIGtleSBwcmVzc2VzLiBUaGlzIGlzIGhlcmUgcHJpbWFyaWx5IHRvIGJyaW5nIElFXG4gICAgICAgIC8vIGluIGxpbmUgd2l0aCBvdGhlciBicm93c2Vycy4gQnkgZGVmYXVsdCwgcHJlc3NpbmcgZXNjYXBlIG9uIElFIHdpbGwgY2F1c2UgaXQgdG8gcmV2ZXJ0XG4gICAgICAgIC8vIHRoZSBpbnB1dCB2YWx1ZSB0byB0aGUgb25lIHRoYXQgaXQgaGFkIG9uIGZvY3VzLCBob3dldmVyIGl0IHdvbid0IGRpc3BhdGNoIGFueSBldmVudHNcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgbW9kZWwgdmFsdWUgd2lsbCBiZSBvdXQgb2Ygc3luYyB3aXRoIHRoZSB2aWV3LlxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gRVNDQVBFKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU9wdGlvbiAmJiBrZXlDb2RlID09PSBFTlRFUiAmJiB0aGlzLnBhbmVsT3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbi5zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZBY3RpdmVJdGVtID0gdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlci5hY3RpdmVJdGVtO1xuICAgICAgICAgICAgY29uc3QgaXNBcnJvd0tleSA9IGtleUNvZGUgPT09IFVQX0FSUk9XIHx8IGtleUNvZGUgPT09IERPV05fQVJST1c7XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5lbE9wZW5lZCB8fCBrZXlDb2RlID09PSBUQUIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyb3dLZXkgJiYgdGhpcy5jYW5PcGVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChpc0Fycm93S2V5IHx8IHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LmtleU1hbmFnZXIuYWN0aXZlSXRlbSAhPT0gcHJldkFjdGl2ZUl0ZW0pICYmXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlci5hY3RpdmVJdGVtXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBTY3JvbGxUb1NlcnZpY2Uuc2Nyb2xsVG9FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0uZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5vcHRpb25zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuT3BlbigpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5QYW5lbCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVJlZiAmJiB0aGlzLm92ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmID0gb3ZlcmxheVJlZjtcbiAgICAgICAgb3ZlcmxheVJlZi5rZXlkb3duRXZlbnRzKCkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIC8vIENsb3NlIHdoZW4gcHJlc3NpbmcgRVNDQVBFIG9yIEFMVCArIFVQX0FSUk9XLCBiYXNlZCBvbiB0aGUgYTExeSBndWlkZWxpbmVzLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLTEuMS8jdGV4dGJveC1rZXlib2FyZC1pbnRlcmFjdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSB8fCAoZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cgJiYgZXZlbnQuYWx0S2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUtleUV2ZW50U3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHN0b3AgcHJvcGFnYXRpb24sIG90aGVyd2lzZSB0aGUgZXZlbnQgd2lsbCBldmVudHVhbGx5XG4gICAgICAgICAgICAgICAgLy8gcmVhY2ggdGhlIGlucHV0IGl0c2VsZiBhbmQgY2F1c2UgdGhlIG92ZXJsYXkgdG8gYmUgcmVvcGVuZWQuXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFuZWxPcGVuZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5vcGVuKCk7XG4gICAgfVxuXG4gICAgY2xvc2VQYW5lbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b2NvbXBsZXRlUmVmKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZVJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgdmlld0NvbnRhaW5lclJlZjogdGhpcy52aWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgcGxhY2VtZW50OiB0aGlzLnRoeVBsYWNlbWVudCxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy50aHlPZmZzZXQsXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMudGh5QXV0b2NvbXBsZXRlV2lkdGggfHwgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlUmVmID0gdGhpcy5hdXRvY29tcGxldGVTZXJ2aWNlLm9wZW4odGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQuY29udGVudFRlbXBsYXRlUmVmLCBjb25maWcpO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZVJlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsT3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGVsYXkgMjAwbXMgdG8gcHJldmVudCBlbWl0IGRvY3VtZW50IGNsaWNrIHJpZ2h0bm93XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlUmVmXG4gICAgICAgICAgICAuYWZ0ZXJPcGVuZWQoKVxuICAgICAgICAgICAgLnBpcGUoZGVsYXkoMjAwKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRvY29tcGxldGVSZWYuZ2V0T3ZlcmxheVJlZigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGxpc3RlbnMgdG8gYSBzdHJlYW0gb2YgcGFuZWwgY2xvc2luZyBhY3Rpb25zIGFuZCByZXNldHMgdGhlXG4gICAgICogc3RyZWFtIGV2ZXJ5IHRpbWUgdGhlIG9wdGlvbiBsaXN0IGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUb0Nsb3NpbmdBY3Rpb25zKCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgICAgIGNvbnN0IGZpcnN0U3RhYmxlID0gdGhpcy5uZ1pvbmUub25TdGFibGUuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uQ2hhbmdlcyA9IHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50Lm9wdGlvbnMuY2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgLy8gRGVmZXIgZW1pdHRpbmcgdG8gdGhlIHN0cmVhbSB1bnRpbCB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyBiaW5kaW5ncyBpbiBoZXJlIHdpbGwgY2F1c2UgXCJjaGFuZ2VkIGFmdGVyIGNoZWNrZWRcIiBlcnJvcnMuXG4gICAgICAgICAgICBkZWxheSgwKVxuICAgICAgICApO1xuICAgICAgICAvLyBXaGVuIHRoZSB6b25lIGlzIHN0YWJsZSBpbml0aWFsbHksIGFuZCB3aGVuIHRoZSBvcHRpb24gbGlzdCBjaGFuZ2VzLi4uXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBtZXJnZShmaXJzdFN0YWJsZSwgb3B0aW9uQ2hhbmdlcylcbiAgICAgICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHN0cmVhbSBvZiBwYW5lbENsb3NpbmdBY3Rpb25zLCByZXBsYWNpbmcgYW55IHByZXZpb3VzIHN0cmVhbXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3ZXJlIGNyZWF0ZWQsIGFuZCBmbGF0dGVuIGl0IHNvIG91ciBzdHJlYW0gb25seSBlbWl0cyBjbG9zaW5nIGV2ZW50cy4uLlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2ZUl0ZW0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFuZWxPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsQ2xvc2luZ0FjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCBjbG9zaW5nIGV2ZW50IG9jY3Vycy4uLlxuICAgICAgICAgICAgICAgICAgICB0YWtlKDEpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgdmFsdWUsIGNsb3NlIHRoZSBwYW5lbCwgYW5kIGNvbXBsZXRlLlxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4gdGhpcy5zZXRWYWx1ZUFuZENsb3NlKGV2ZW50KSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlQW5kQ2xvc2UoZXZlbnQ6IFRoeU9wdGlvblNlbGVjdGlvbkNoYW5nZUV2ZW50IHwgbnVsbCk6IHZvaWQge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQub3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKGV2ZW50Lm9wdGlvbi50aHlMYWJlbFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH1cblxuICAgIC8qKiBTdHJlYW0gb2YgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbC4gKi9cbiAgICBwcml2YXRlIGdldE91dHNpZGVDbGlja1N0cmVhbSgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgICAgICByZXR1cm4gbWVyZ2UoXG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5kb2N1bWVudCwgJ2NsaWNrJykgYXMgT2JzZXJ2YWJsZTxNb3VzZUV2ZW50PixcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAndG91Y2hlbmQnKSBhcyBPYnNlcnZhYmxlPFRvdWNoRXZlbnQ+XG4gICAgICAgICkucGlwZShcbiAgICAgICAgICAgIGZpbHRlcihldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIFNoYWRvdyBET00sIHRoZSBldmVudCB0YXJnZXQgd2lsbCBiZSB0aGUgc2hhZG93IHJvb3QsIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gY2hlY2sgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHBhdGggb2YgdGhlIGNsaWNrIGV2ZW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrVGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZDogYW55ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuZWxPcGVuZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tUYXJnZXQgIT09IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICghZm9ybUZpZWxkIHx8ICFmb3JtRmllbGQuY29udGFpbnMoY2xpY2tUYXJnZXQpKSAmJlxuICAgICAgICAgICAgICAgICAgICAhIXRoaXMub3ZlcmxheVJlZiAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LmNvbnRhaW5zKGNsaWNrVGFyZ2V0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FuT3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZWxlbWVudDogSFRNTElucHV0RWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gIWVsZW1lbnQucmVhZE9ubHkgJiYgIWVsZW1lbnQuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldEFjdGl2ZUl0ZW0oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LmtleU1hbmFnZXIuc2V0QWN0aXZlSXRlbSh0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC50aHlBdXRvQWN0aXZlRmlyc3RPcHRpb24gPyAwIDogLTEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVzdHJveVBhbmVsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2xvc2VLZXlFdmVudFN0cmVhbS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQYW5lbCgpO1xuICAgIH1cbn1cbiJdfQ==