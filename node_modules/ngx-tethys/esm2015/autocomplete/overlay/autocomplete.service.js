import { Overlay, ScrollDispatcher, OverlayContainer, FlexibleConnectedPositionStrategy } from '@angular/cdk/overlay';
import { Injectable, Injector, Inject, NgZone } from '@angular/core';
import { coerceElement, coerceArray } from '@angular/cdk/coercion';
import { ComponentPortal } from '@angular/cdk/portal';
import { ThyAutocompleteContainerComponent } from './autocomplete-container.component';
import { ThyAutocompleteConfig, THY_AUTOCOMPLETE_DEFAULT_CONFIG } from './autocomplete.config';
import { ThyAutocompleteRef, ThyInternalAutocompleteRef } from './autocomplete-ref';
import { Directionality } from '@angular/cdk/bidi';
import { of, Subject } from 'rxjs';
import { getFlexiblePositions, ThyAbstractOverlayService } from 'ngx-tethys/core';
import { takeUntil } from 'rxjs/operators';
import { autocompleteUpperOverlayOptions } from './autocomplete.options';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { DOCUMENT } from '@angular/common';
import { Platform } from '@angular/cdk/platform';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "./autocomplete.config";
import * as i3 from "@angular/cdk/scrolling";
import * as i4 from "@angular/common";
import * as i5 from "@angular/cdk/platform";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/overlay';
import * as ɵngcc2 from '@angular/cdk/scrolling';
import * as ɵngcc3 from '@angular/cdk/platform';
import * as ɵngcc4 from './autocomplete.config';
export class ThyAutocompleteService extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig, scrollDispatcher, ngZone, _viewportRuler, _document, _platform, _overlayContainer) {
        super(autocompleteUpperOverlayOptions, overlay, injector, defaultConfig);
        this.scrollDispatcher = scrollDispatcher;
        this.ngZone = ngZone;
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        this.ngUnsubscribe$ = new Subject();
        this.originInstancesMap = new Map();
    }
    buildPositionStrategy(config) {
        const positionStrategy = new FlexibleConnectedPositionStrategy(config.origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        const positions = getFlexiblePositions(config.placement, config.offset, 'thy-autocomplete');
        positionStrategy.withPositions(positions);
        positionStrategy.withGrowAfterOpen(true);
        positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {
            if (change.scrollableViewProperties.isOverlayClipped) {
                // After position changes occur and the overlay is clipped by
                // a parent scrollable then close the tooltip.
                this.ngZone.run(() => this.close());
            }
        });
        return positionStrategy;
    }
    buildOverlayConfig(config) {
        const strategy = this.buildPositionStrategy(config);
        const overlayConfig = this.buildBaseOverlayConfig(config);
        overlayConfig.positionStrategy = strategy;
        overlayConfig.scrollStrategy = config.scrollStrategy || this.overlay.scrollStrategies.block();
        overlayConfig.width = config.width;
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThyAutocompleteConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThyAutocompleteContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalAutocompleteRef(overlayRef, containerInstance, config);
    }
    createInjector(config, autocompleteRef, autocompleteContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            {
                provide: ThyAutocompleteContainerComponent,
                useValue: autocompleteContainer
            },
            {
                provide: ThyAutocompleteRef,
                useValue: autocompleteRef
            }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    originElementAddActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.add(...coerceArray(config.originActiveClass));
        }
    }
    originElementRemoveActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.remove(...coerceArray(config.originActiveClass));
        }
    }
    open(componentOrTemplateRef, config) {
        const originElement = coerceElement(config.origin);
        const autocompleteRef = this.openUpperOverlay(componentOrTemplateRef, config);
        config = autocompleteRef.containerInstance.config;
        autocompleteRef.afterClosed().subscribe(() => {
            this.originElementRemoveActiveClass(config);
            this.originInstancesMap.delete(originElement);
        });
        this.originElementAddActiveClass(config);
        this.originInstancesMap.set(originElement, {
            config,
            autocompleteRef
        });
        return autocompleteRef;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyAutocompleteService.ɵfac = function ThyAutocompleteService_Factory(t) { return new (t || ThyAutocompleteService)(ɵngcc0.ɵɵinject(ɵngcc1.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(THY_AUTOCOMPLETE_DEFAULT_CONFIG), ɵngcc0.ɵɵinject(ɵngcc1.ScrollDispatcher), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc2.ViewportRuler), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc3.Platform), ɵngcc0.ɵɵinject(ɵngcc1.OverlayContainer)); };
ThyAutocompleteService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyAutocompleteService_Factory() { return new ThyAutocompleteService(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i2.THY_AUTOCOMPLETE_DEFAULT_CONFIG), i0.ɵɵinject(i3.ScrollDispatcher), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.ViewportRuler), i0.ɵɵinject(i4.DOCUMENT), i0.ɵɵinject(i5.Platform), i0.ɵɵinject(i1.OverlayContainer)); }, token: ThyAutocompleteService, providedIn: "root" });
ThyAutocompleteService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThyAutocompleteConfig, decorators: [{ type: Inject, args: [THY_AUTOCOMPLETE_DEFAULT_CONFIG,] }] },
    { type: ScrollDispatcher },
    { type: NgZone },
    { type: ViewportRuler },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Platform },
    { type: OverlayContainer }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Overlay }, { type: ɵngcc0.Injector }, { type: ɵngcc4.ThyAutocompleteConfig, decorators: [{
                type: Inject,
                args: [THY_AUTOCOMPLETE_DEFAULT_CONFIG]
            }] }, { type: ɵngcc1.ScrollDispatcher }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.ViewportRuler }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc3.Platform }, { type: ɵngcc1.OverlayContainer }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hdXRvY29tcGxldGUvb3ZlcmxheS9hdXRvY29tcGxldGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsT0FBTyxFQUlQLGdCQUFnQixFQUNoQixnQkFBZ0IsRUFDaEIsaUNBQWlDLEVBQ3BDLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFpQyxVQUFVLEVBQWMsUUFBUSxFQUFhLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0gsT0FBTyxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsZUFBZSxFQUFrQixNQUFNLHFCQUFxQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQy9GLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUseUJBQXlCLEVBQXlCLE1BQU0saUJBQWlCLENBQUM7QUFDekcsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFFBQVEs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QWpCakIsZ0JBQWdCO0FBQ25COzs7Ozs7Ozs7Ozs7Z0dBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50VHlwZSxcbiAgICBPdmVybGF5LFxuICAgIE92ZXJsYXlDb25maWcsXG4gICAgT3ZlcmxheVJlZixcbiAgICBQb3NpdGlvblN0cmF0ZWd5LFxuICAgIFNjcm9sbERpc3BhdGNoZXIsXG4gICAgT3ZlcmxheUNvbnRhaW5lcixcbiAgICBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYsIEluamVjdGFibGUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBPbkRlc3Ryb3ksIEluamVjdCwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjb2VyY2VFbGVtZW50LCBjb2VyY2VBcnJheSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwsIFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBUaHlBdXRvY29tcGxldGVDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL2F1dG9jb21wbGV0ZS1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFRoeUF1dG9jb21wbGV0ZUNvbmZpZywgVEhZX0FVVE9DT01QTEVURV9ERUZBVUxUX0NPTkZJRyB9IGZyb20gJy4vYXV0b2NvbXBsZXRlLmNvbmZpZyc7XG5pbXBvcnQgeyBUaHlBdXRvY29tcGxldGVSZWYsIFRoeUludGVybmFsQXV0b2NvbXBsZXRlUmVmIH0gZnJvbSAnLi9hdXRvY29tcGxldGUtcmVmJztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGdldEZsZXhpYmxlUG9zaXRpb25zLCBUaHlBYnN0cmFjdE92ZXJsYXlTZXJ2aWNlLCBUaHlBYnN0cmFjdE92ZXJsYXlSZWYgfSBmcm9tICduZ3gtdGV0aHlzL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ25neC10ZXRoeXMvdXRpbCc7XG5pbXBvcnQgeyBhdXRvY29tcGxldGVVcHBlck92ZXJsYXlPcHRpb25zIH0gZnJvbSAnLi9hdXRvY29tcGxldGUub3B0aW9ucyc7XG5pbXBvcnQgeyBWaWV3cG9ydFJ1bGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBTdGF0aWNQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRoeUF1dG9jb21wbGV0ZVNlcnZpY2UgZXh0ZW5kcyBUaHlBYnN0cmFjdE92ZXJsYXlTZXJ2aWNlPFRoeUF1dG9jb21wbGV0ZUNvbmZpZywgVGh5QXV0b2NvbXBsZXRlQ29udGFpbmVyQ29tcG9uZW50PlxuICAgIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5nVW5zdWJzY3JpYmUkID0gbmV3IFN1YmplY3QoKTtcblxuICAgIHByaXZhdGUgb3JpZ2luSW5zdGFuY2VzTWFwID0gbmV3IE1hcDxcbiAgICAgICAgRWxlbWVudFJlZiB8IEhUTUxFbGVtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWc6IFRoeUF1dG9jb21wbGV0ZUNvbmZpZztcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZVJlZjogVGh5QXV0b2NvbXBsZXRlUmVmPGFueSwgYW55PjtcbiAgICAgICAgfVxuICAgID4oKTtcblxuICAgIHByaXZhdGUgYnVpbGRQb3NpdGlvblN0cmF0ZWd5PFREYXRhPihjb25maWc6IFRoeUF1dG9jb21wbGV0ZUNvbmZpZzxURGF0YT4pOiBQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IG5ldyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgICAgICBjb25maWcub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRSdWxlcixcbiAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50LFxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm0sXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdldEZsZXhpYmxlUG9zaXRpb25zKGNvbmZpZy5wbGFjZW1lbnQsIGNvbmZpZy5vZmZzZXQsICd0aHktYXV0b2NvbXBsZXRlJyk7XG4gICAgICAgIHBvc2l0aW9uU3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICAgICAgICBwb3NpdGlvblN0cmF0ZWd5LndpdGhHcm93QWZ0ZXJPcGVuKHRydWUpO1xuICAgICAgICBwb3NpdGlvblN0cmF0ZWd5LnBvc2l0aW9uQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnNjcm9sbGFibGVWaWV3UHJvcGVydGllcy5pc092ZXJsYXlDbGlwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgcG9zaXRpb24gY2hhbmdlcyBvY2N1ciBhbmQgdGhlIG92ZXJsYXkgaXMgY2xpcHBlZCBieVxuICAgICAgICAgICAgICAgIC8vIGEgcGFyZW50IHNjcm9sbGFibGUgdGhlbiBjbG9zZSB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvblN0cmF0ZWd5O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBidWlsZE92ZXJsYXlDb25maWc8VERhdGE+KGNvbmZpZzogVGh5QXV0b2NvbXBsZXRlQ29uZmlnPFREYXRhPik6IE92ZXJsYXlDb25maWcge1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuYnVpbGRQb3NpdGlvblN0cmF0ZWd5KGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLmJ1aWxkQmFzZU92ZXJsYXlDb25maWcoY29uZmlnKTtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIG92ZXJsYXlDb25maWcuc2Nyb2xsU3RyYXRlZ3kgPSBjb25maWcuc2Nyb2xsU3RyYXRlZ3kgfHwgdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlDb25maWc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGF0dGFjaFVwcGVyT3ZlcmxheUNvbnRhaW5lcihvdmVybGF5OiBPdmVybGF5UmVmLCBjb25maWc6IFRoeUF1dG9jb21wbGV0ZUNvbmZpZzxhbnk+KTogVGh5QXV0b2NvbXBsZXRlQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3QgdXNlckluamVjdG9yID0gY29uZmlnICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmLmluamVjdG9yO1xuICAgICAgICBjb25zdCBpbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7XG4gICAgICAgICAgICBwYXJlbnQ6IHVzZXJJbmplY3RvciB8fCB0aGlzLmluamVjdG9yLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBUaHlBdXRvY29tcGxldGVDb25maWcsIHVzZVZhbHVlOiBjb25maWcgfV1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoVGh5QXV0b2NvbXBsZXRlQ29udGFpbmVyQ29tcG9uZW50LCBjb25maWcudmlld0NvbnRhaW5lclJlZiwgaW5qZWN0b3IpO1xuICAgICAgICBjb25zdCBjb250YWluZXJSZWYgPSBvdmVybGF5LmF0dGFjaDxUaHlBdXRvY29tcGxldGVDb250YWluZXJDb21wb25lbnQ+KGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVVwcGVyT3ZlcmxheVJlZjxUPihcbiAgICAgICAgb3ZlcmxheVJlZjogT3ZlcmxheVJlZixcbiAgICAgICAgY29udGFpbmVySW5zdGFuY2U6IFRoeUF1dG9jb21wbGV0ZUNvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgY29uZmlnOiBUaHlBdXRvY29tcGxldGVDb25maWc8YW55PlxuICAgICk6IFRoeUludGVybmFsQXV0b2NvbXBsZXRlUmVmPFQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaHlJbnRlcm5hbEF1dG9jb21wbGV0ZVJlZjxUPihvdmVybGF5UmVmLCBjb250YWluZXJJbnN0YW5jZSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5qZWN0b3I8VD4oXG4gICAgICAgIGNvbmZpZzogVGh5QXV0b2NvbXBsZXRlQ29uZmlnLFxuICAgICAgICBhdXRvY29tcGxldGVSZWY6IFRoeUF1dG9jb21wbGV0ZVJlZjxUPixcbiAgICAgICAgYXV0b2NvbXBsZXRlQ29udGFpbmVyOiBUaHlBdXRvY29tcGxldGVDb250YWluZXJDb21wb25lbnRcbiAgICApOiBJbmplY3RvciB7XG4gICAgICAgIGNvbnN0IHVzZXJJbmplY3RvciA9IGNvbmZpZyAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZiAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZi5pbmplY3RvcjtcbiAgICAgICAgY29uc3QgaW5qZWN0aW9uVG9rZW5zOiBTdGF0aWNQcm92aWRlcltdID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRoeUF1dG9jb21wbGV0ZUNvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogYXV0b2NvbXBsZXRlQ29udGFpbmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRoeUF1dG9jb21wbGV0ZVJlZixcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogYXV0b2NvbXBsZXRlUmVmXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGNvbmZpZy5kaXJlY3Rpb24gJiYgKCF1c2VySW5qZWN0b3IgfHwgIXVzZXJJbmplY3Rvci5nZXQ8RGlyZWN0aW9uYWxpdHkgfCBudWxsPihEaXJlY3Rpb25hbGl0eSwgbnVsbCkpKSB7XG4gICAgICAgICAgICBpbmplY3Rpb25Ub2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogRGlyZWN0aW9uYWxpdHksXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbmZpZy5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZTogb2YoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEluamVjdG9yLmNyZWF0ZSh7IHBhcmVudDogdXNlckluamVjdG9yIHx8IHRoaXMuaW5qZWN0b3IsIHByb3ZpZGVyczogaW5qZWN0aW9uVG9rZW5zIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgb3JpZ2luRWxlbWVudEFkZEFjdGl2ZUNsYXNzKGNvbmZpZzogVGh5QXV0b2NvbXBsZXRlQ29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcub3JpZ2luQWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvZXJjZUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KGNvbmZpZy5vcmlnaW4pLmNsYXNzTGlzdC5hZGQoLi4uY29lcmNlQXJyYXkoY29uZmlnLm9yaWdpbkFjdGl2ZUNsYXNzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9yaWdpbkVsZW1lbnRSZW1vdmVBY3RpdmVDbGFzcyhjb25maWc6IFRoeUF1dG9jb21wbGV0ZUNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLm9yaWdpbkFjdGl2ZUNsYXNzKSB7XG4gICAgICAgICAgICBjb2VyY2VFbGVtZW50PEhUTUxFbGVtZW50Pihjb25maWcub3JpZ2luKS5jbGFzc0xpc3QucmVtb3ZlKC4uLmNvZXJjZUFycmF5KGNvbmZpZy5vcmlnaW5BY3RpdmVDbGFzcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG92ZXJsYXk6IE92ZXJsYXksXG4gICAgICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICAgICAgQEluamVjdChUSFlfQVVUT0NPTVBMRVRFX0RFRkFVTFRfQ09ORklHKSBkZWZhdWx0Q29uZmlnOiBUaHlBdXRvY29tcGxldGVDb25maWcsXG4gICAgICAgIHByaXZhdGUgc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJpdmF0ZSBfdmlld3BvcnRSdWxlcjogVmlld3BvcnRSdWxlcixcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgcHJpdmF0ZSBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgICAgICBwcml2YXRlIF9vdmVybGF5Q29udGFpbmVyOiBPdmVybGF5Q29udGFpbmVyXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGF1dG9jb21wbGV0ZVVwcGVyT3ZlcmxheU9wdGlvbnMsIG92ZXJsYXksIGluamVjdG9yLCBkZWZhdWx0Q29uZmlnKTtcbiAgICB9XG5cbiAgICBvcGVuPFQsIFREYXRhID0gYW55LCBUUmVzdWx0ID0gYW55PihcbiAgICAgICAgY29tcG9uZW50T3JUZW1wbGF0ZVJlZjogQ29tcG9uZW50VHlwZTxUPiB8IFRlbXBsYXRlUmVmPFQ+LFxuICAgICAgICBjb25maWc/OiBUaHlBdXRvY29tcGxldGVDb25maWc8VERhdGE+XG4gICAgKTogVGh5QXV0b2NvbXBsZXRlUmVmPFQsIFRSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luRWxlbWVudCA9IGNvZXJjZUVsZW1lbnQoY29uZmlnLm9yaWdpbik7XG4gICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZVJlZiA9IHRoaXMub3BlblVwcGVyT3ZlcmxheShjb21wb25lbnRPclRlbXBsYXRlUmVmLCBjb25maWcpIGFzIFRoeUF1dG9jb21wbGV0ZVJlZjxUPjtcbiAgICAgICAgY29uZmlnID0gYXV0b2NvbXBsZXRlUmVmLmNvbnRhaW5lckluc3RhbmNlLmNvbmZpZztcbiAgICAgICAgYXV0b2NvbXBsZXRlUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luRWxlbWVudFJlbW92ZUFjdGl2ZUNsYXNzKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbkluc3RhbmNlc01hcC5kZWxldGUob3JpZ2luRWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub3JpZ2luRWxlbWVudEFkZEFjdGl2ZUNsYXNzKGNvbmZpZyk7XG4gICAgICAgIHRoaXMub3JpZ2luSW5zdGFuY2VzTWFwLnNldChvcmlnaW5FbGVtZW50LCB7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBhdXRvY29tcGxldGVSZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVJlZjtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfVxufVxuIl19