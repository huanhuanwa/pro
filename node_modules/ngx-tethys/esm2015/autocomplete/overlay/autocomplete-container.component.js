import { Component, ViewChild, Inject, ElementRef, EventEmitter, ChangeDetectorRef, NgZone } from '@angular/core';
import { CdkPortalOutlet } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { ThyAutocompleteConfig } from './autocomplete.config';
import { thyAutocompleteAnimations } from './autocomplete-animations';
import { ThyAbstractOverlayContainer } from 'ngx-tethys/core';
import { autocompleteUpperOverlayOptions } from './autocomplete.options';
import { filter } from 'rxjs/operators';
import { ThyClickDispatcher } from 'ngx-tethys/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './autocomplete.config';
import * as ɵngcc2 from 'ngx-tethys/core';
import * as ɵngcc3 from '@angular/cdk/portal';

function ThyAutocompleteContainerComponent_ng_template_0_Template(rf, ctx) { }
export class ThyAutocompleteContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, thyClickDispatcher, ngZone) {
        super(autocompleteUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.thyClickDispatcher = thyClickDispatcher;
        this.ngZone = ngZone;
        /** State of the autocomplete animation. */
        this.animationState = 'enter';
        /** Emits when an animation state changes. */
        this.animationStateChanged = new EventEmitter();
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'enter';
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
    }
    beforeAttachPortal() { }
    ngAfterViewInit() { }
    /** Callback, invoked whenever an animation on the host completes. */
    onAnimationDone(event) {
        this.animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    startExitAnimation() {
        this.animationState = 'exit';
        this.changeDetectorRef.markForCheck();
    }
}
ThyAutocompleteContainerComponent.ɵfac = function ThyAutocompleteContainerComponent_Factory(t) { return new (t || ThyAutocompleteContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ThyAutocompleteConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ThyClickDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ThyAutocompleteContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyAutocompleteContainerComponent, selectors: [["thy-autocomplete-container"]], viewQuery: function ThyAutocompleteContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(CdkPortalOutlet, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, hostAttrs: ["tabindex", "-1", 1, "thy-autocomplete-container"], hostVars: 2, hostBindings: function ThyAutocompleteContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@autocompleteContainer.start", function ThyAutocompleteContainerComponent_animation_autocompleteContainer_start_HostBindingHandler($event) { return ctx.onAnimationStart($event); })("@autocompleteContainer.done", function ThyAutocompleteContainerComponent_animation_autocompleteContainer_done_HostBindingHandler($event) { return ctx.onAnimationDone($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "autocomplete");
        ɵngcc0.ɵɵsyntheticHostProperty("@autocompleteContainer", ctx.animationState);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function ThyAutocompleteContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ThyAutocompleteContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [ɵngcc3.CdkPortalOutlet], encapsulation: 2, data: { animation: [thyAutocompleteAnimations.autocompleteContainer] } });
ThyAutocompleteContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThyAutocompleteConfig },
    { type: ChangeDetectorRef },
    { type: ThyClickDispatcher },
    { type: NgZone }
];
ThyAutocompleteContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteContainerComponent, [{
        type: Component,
        args: [{
                selector: 'thy-autocomplete-container',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                animations: [thyAutocompleteAnimations.autocompleteContainer],
                host: {
                    class: 'thy-autocomplete-container',
                    tabindex: '-1',
                    '[attr.role]': `'autocomplete'`,
                    '[@autocompleteContainer]': 'animationState',
                    '(@autocompleteContainer.start)': 'onAnimationStart($event)',
                    '(@autocompleteContainer.done)': 'onAnimationDone($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc1.ThyAutocompleteConfig }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.ThyClickDispatcher }, { type: ɵngcc0.NgZone }]; }, { portalOutlet: [{
            type: ViewChild,
            args: [CdkPortalOutlet, { static: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLWNvbnRhaW5lci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hdXRvY29tcGxldGUvb3ZlcmxheS9hdXRvY29tcGxldGUtY29udGFpbmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUVULFNBQVMsRUFFVCxNQUFNLEVBQ04sVUFBVSxFQUNWLFlBQVksRUFFWixpQkFBaUIsRUFHakIsTUFBTSxFQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBbUMsZUFBZSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRzNDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXpFLE9BQU8sRUFBRSxNQUFNLEVBQWEsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7Ozs7OztBQWVyRCxNQUFNLE9BQU8saUNBQWtDLFNBQVEsMkJBQTJCO0FBQUcsSUFlakYsWUFDWSxVQUFzQixFQUNKLFFBQWEsRUFDaEMsTUFBNkIsRUFDcEMsaUJBQW9DLEVBQzVCLGtCQUFzQyxFQUN0QyxNQUFjO0FBQzNCLFFBQ0ssS0FBSyxDQUFDLCtCQUErQixFQUFFLGlCQUFpQixDQUFDLENBQUM7QUFDbEUsUUFSZ0IsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDLFFBQ0wsYUFBUSxHQUFSLFFBQVEsQ0FBSztBQUFDLFFBQ2pDLFdBQU0sR0FBTixNQUFNLENBQXVCO0FBQUMsUUFFN0IsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtBQUFDLFFBQ3ZDLFdBQU0sR0FBTixNQUFNLENBQVE7QUFDOUIsUUFsQkksMkNBQTJDO0FBQy9DLFFBQUksbUJBQWMsR0FBOEIsT0FBTyxDQUFDO0FBQ3hELFFBQ0ksNkNBQTZDO0FBQ2pELFFBQUksMEJBQXFCLEdBQUcsSUFBSSxZQUFZLEVBQWtCLENBQUM7QUFDL0QsUUFnQlEsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQ3ZELE1BQU0sQ0FBQyxDQUFDLEtBQXFCLEVBQUUsRUFBRTtBQUM3QyxZQUFnQixPQUFPLEtBQUssQ0FBQyxTQUFTLEtBQUssTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDO0FBQy9FLFFBQVksQ0FBQyxDQUFDLENBQ0wsQ0FBQztBQUNWLFFBQVEsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQ3ZELE1BQU0sQ0FBQyxDQUFDLEtBQXFCLEVBQUUsRUFBRTtBQUM3QyxZQUFnQixPQUFPLEtBQUssQ0FBQyxTQUFTLEtBQUssTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssTUFBTSxDQUFDO0FBQzlFLFFBQVksQ0FBQyxDQUFDLENBQ0wsQ0FBQztBQUNWLElBQUksQ0FBQztBQUNMLElBdkJJLGtCQUFrQixLQUFVLENBQUM7QUFDakMsSUF1QkksZUFBZSxLQUFJLENBQUM7QUFDeEIsSUFDSSxxRUFBcUU7QUFDekUsSUFBSSxlQUFlLENBQUMsS0FBcUI7QUFDekMsUUFBUSxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9DLElBQUksQ0FBQztBQUNMLElBQ0ksOERBQThEO0FBQ2xFLElBQUksZ0JBQWdCLENBQUMsS0FBcUI7QUFDMUMsUUFBUSxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9DLElBQUksQ0FBQztBQUNMLElBQ0ksa0JBQWtCO0FBQUssUUFDbkIsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUM7QUFDckMsUUFBUSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDOUMsSUFBSSxDQUFDO0FBQ0w7NkRBbEVDLFNBQVMsU0FBQyxrQkFDUCxRQUFRLEVBQUUsNEJBQTRCLGtCQUN0Qyx5REFBc0Qsa0JBQ3RELFVBQVUsRUFBRSxDQUFDLHlCQUF5QixDQUFDLHFCQUFxQixDQUFDLGtCQUM3RCxJQUFJLEVBQUUsc0JBQ0YsS0FBSyxFQUFFLDRCQUE0QixzQkFDbkMsUUFBUSxFQUFFLElBQUksc0JBQ2Q7S0FBYSxFQUFFLGdCQUFnQixzQkFDL0IsMEJBQTBCLEVBQUUsZ0JBQWdCLHNCQUM1QyxnQ0FBZ0MsRUFBRSwwQkFBMEIsc0JBQzVELCtCQUErQixFQUFFO1lBQXlCLGtCQUM3RCxjQUNKOzs7Ozs7Ozs7OzsySUFDSTtBQUFDO0FBQTJELFlBbEM3RCxVQUFVO0FBQ1osNENBa0RPLE1BQU0sU0FBQyxRQUFRO0FBQVMsWUF0Q3hCLHFCQUFxQjtBQUFJLFlBVjlCLGlCQUFpQjtBQUNuQixZQWVPLGtCQUFrQjtBQUFJLFlBYjNCLE1BQU07QUFDVDtBQUFHO0FBRWEsMkJBMEJaLFNBQVMsU0FBQyxlQUFlLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBJbmplY3QsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIE9uSW5pdCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIE5nWm9uZSxcbiAgICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCwgVGVtcGxhdGVQb3J0YWwsIENka1BvcnRhbE91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuaW1wb3J0IHsgVGh5QXV0b2NvbXBsZXRlQ29uZmlnIH0gZnJvbSAnLi9hdXRvY29tcGxldGUuY29uZmlnJztcbmltcG9ydCB7IHRoeUF1dG9jb21wbGV0ZUFuaW1hdGlvbnMgfSBmcm9tICcuL2F1dG9jb21wbGV0ZS1hbmltYXRpb25zJztcbmltcG9ydCB7IFRoeUFic3RyYWN0T3ZlcmxheUNvbnRhaW5lciB9IGZyb20gJ25neC10ZXRoeXMvY29yZSc7XG5pbXBvcnQgeyBhdXRvY29tcGxldGVVcHBlck92ZXJsYXlPcHRpb25zIH0gZnJvbSAnLi9hdXRvY29tcGxldGUub3B0aW9ucyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tRXZlbnQsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRoeUNsaWNrRGlzcGF0Y2hlciB9IGZyb20gJ25neC10ZXRoeXMvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndGh5LWF1dG9jb21wbGV0ZS1jb250YWluZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hdXRvY29tcGxldGUtY29udGFpbmVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBhbmltYXRpb25zOiBbdGh5QXV0b2NvbXBsZXRlQW5pbWF0aW9ucy5hdXRvY29tcGxldGVDb250YWluZXJdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgY2xhc3M6ICd0aHktYXV0b2NvbXBsZXRlLWNvbnRhaW5lcicsXG4gICAgICAgIHRhYmluZGV4OiAnLTEnLFxuICAgICAgICAnW2F0dHIucm9sZV0nOiBgJ2F1dG9jb21wbGV0ZSdgLFxuICAgICAgICAnW0BhdXRvY29tcGxldGVDb250YWluZXJdJzogJ2FuaW1hdGlvblN0YXRlJyxcbiAgICAgICAgJyhAYXV0b2NvbXBsZXRlQ29udGFpbmVyLnN0YXJ0KSc6ICdvbkFuaW1hdGlvblN0YXJ0KCRldmVudCknLFxuICAgICAgICAnKEBhdXRvY29tcGxldGVDb250YWluZXIuZG9uZSknOiAnb25BbmltYXRpb25Eb25lKCRldmVudCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUaHlBdXRvY29tcGxldGVDb250YWluZXJDb21wb25lbnQgZXh0ZW5kcyBUaHlBYnN0cmFjdE92ZXJsYXlDb250YWluZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgICBAVmlld0NoaWxkKENka1BvcnRhbE91dGxldCwgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwb3J0YWxPdXRsZXQ6IENka1BvcnRhbE91dGxldDtcblxuICAgIC8qKiBTdGF0ZSBvZiB0aGUgYXV0b2NvbXBsZXRlIGFuaW1hdGlvbi4gKi9cbiAgICBhbmltYXRpb25TdGF0ZTogJ3ZvaWQnIHwgJ2VudGVyJyB8ICdleGl0JyA9ICdlbnRlcic7XG5cbiAgICAvKiogRW1pdHMgd2hlbiBhbiBhbmltYXRpb24gc3RhdGUgY2hhbmdlcy4gKi9cbiAgICBhbmltYXRpb25TdGF0ZUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPEFuaW1hdGlvbkV2ZW50PigpO1xuXG4gICAgYW5pbWF0aW9uT3BlbmluZ0RvbmU6IE9ic2VydmFibGU8QW5pbWF0aW9uRXZlbnQ+O1xuICAgIGFuaW1hdGlvbkNsb3NpbmdEb25lOiBPYnNlcnZhYmxlPEFuaW1hdGlvbkV2ZW50PjtcblxuICAgIGJlZm9yZUF0dGFjaFBvcnRhbCgpOiB2b2lkIHt9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnksXG4gICAgICAgIHB1YmxpYyBjb25maWc6IFRoeUF1dG9jb21wbGV0ZUNvbmZpZyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIHRoeUNsaWNrRGlzcGF0Y2hlcjogVGh5Q2xpY2tEaXNwYXRjaGVyLFxuICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGF1dG9jb21wbGV0ZVVwcGVyT3ZlcmxheU9wdGlvbnMsIGNoYW5nZURldGVjdG9yUmVmKTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbk9wZW5pbmdEb25lID0gdGhpcy5hbmltYXRpb25TdGF0ZUNoYW5nZWQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnBoYXNlTmFtZSA9PT0gJ2RvbmUnICYmIGV2ZW50LnRvU3RhdGUgPT09ICdlbnRlcic7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNsb3NpbmdEb25lID0gdGhpcy5hbmltYXRpb25TdGF0ZUNoYW5nZWQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnBoYXNlTmFtZSA9PT0gJ2RvbmUnICYmIGV2ZW50LnRvU3RhdGUgPT09ICdleGl0JztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCkge31cblxuICAgIC8qKiBDYWxsYmFjaywgaW52b2tlZCB3aGVuZXZlciBhbiBhbmltYXRpb24gb24gdGhlIGhvc3QgY29tcGxldGVzLiAqL1xuICAgIG9uQW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZUNoYW5nZWQuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIENhbGxiYWNrLCBpbnZva2VkIHdoZW4gYW4gYW5pbWF0aW9uIG9uIHRoZSBob3N0IHN0YXJ0cy4gKi9cbiAgICBvbkFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlQ2hhbmdlZC5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBzdGFydEV4aXRBbmltYXRpb24oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnZXhpdCc7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuIl19