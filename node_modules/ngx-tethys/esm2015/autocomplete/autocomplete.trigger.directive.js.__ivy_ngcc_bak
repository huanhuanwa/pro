import { Directive, ElementRef, NgZone, Input, ViewContainerRef, HostBinding, Optional, Inject, ChangeDetectorRef } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { ThyAutocompleteService } from './overlay/autocomplete.service';
import { ThyAutocompleteComponent } from './autocomplete.component';
import { ThyOptionSelectionChangeEvent } from 'ngx-tethys/shared';
import { DOCUMENT } from '@angular/common';
import { Subject, merge, fromEvent, of } from 'rxjs';
import { ESCAPE, UP_ARROW, ENTER, DOWN_ARROW, TAB } from 'ngx-tethys/util';
import { filter, map, take, delay, switchMap } from 'rxjs/operators';
import { ScrollToService } from 'ngx-tethys/core';
import { warnDeprecation } from 'ngx-tethys/util';
export class ThyAutocompleteTriggerDirective {
    constructor(elementRef, ngZone, overlay, autocompleteService, viewContainerRef, document, cdr) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.overlay = overlay;
        this.autocompleteService = autocompleteService;
        this.viewContainerRef = viewContainerRef;
        this.document = document;
        this.cdr = cdr;
        this.closeKeyEventStream = new Subject();
        this.panelOpened = false;
        this.thyOffset = 4;
        this.thyPlacement = 'bottomLeft';
    }
    set autocompleteComponent(data) {
        this._autocompleteComponent = data;
    }
    set autocomplete(data) {
        warnDeprecation(`The property thyAutocomplete will be deprecated, please use thyAutocompleteComponent instead.`);
        this._autocompleteComponent = data;
    }
    get autocompleteComponent() {
        return this._autocompleteComponent;
    }
    get activeOption() {
        if (this.autocompleteComponent && this.autocompleteComponent.keyManager) {
            return this.autocompleteComponent.keyManager.activeItem;
        }
        return null;
    }
    get panelClosingActions() {
        return merge(this.autocompleteComponent.thyOptionSelected, this.autocompleteComponent.keyManager.tabOut.pipe(filter(() => this.panelOpened)), this.closeKeyEventStream, this.getOutsideClickStream(), this.overlayRef ? this.overlayRef.detachments().pipe(filter(() => this.panelOpened)) : of()).pipe(
        // Normalize the output so we return a consistent type.
        map(event => (event instanceof ThyOptionSelectionChangeEvent ? event : null)));
    }
    ngOnInit() { }
    onFocus() {
        if (this.canOpen()) {
            this.openPanel();
        }
    }
    onKeydown(event) {
        const keyCode = event.keyCode;
        // Prevent the default action on all escape key presses. This is here primarily to bring IE
        // in line with other browsers. By default, pressing escape on IE will cause it to revert
        // the input value to the one that it had on focus, however it won't dispatch any events
        // which means that the model value will be out of sync with the view.
        if (keyCode === ESCAPE) {
            event.preventDefault();
        }
        if (this.activeOption && keyCode === ENTER && this.panelOpened) {
            this.activeOption.selectViaInteraction();
            this.resetActiveItem();
            event.preventDefault();
        }
        else if (this.autocompleteComponent) {
            const prevActiveItem = this.autocompleteComponent.keyManager.activeItem;
            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
            if (this.panelOpened || keyCode === TAB) {
                this.autocompleteComponent.keyManager.onKeydown(event);
            }
            else if (isArrowKey && this.canOpen()) {
                this.openPanel();
            }
            if ((isArrowKey || this.autocompleteComponent.keyManager.activeItem !== prevActiveItem) &&
                this.autocompleteComponent.keyManager.activeItem) {
                ScrollToService.scrollToElement(this.autocompleteComponent.keyManager.activeItem.element.nativeElement, this.autocompleteComponent.optionsContainer.nativeElement);
            }
        }
    }
    handleInput(event) {
        if (this.canOpen() && document.activeElement === event.target) {
            this.openPanel();
        }
    }
    openPanel() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            return;
        }
        const overlayRef = this.createOverlay();
        this.overlayRef = overlayRef;
        overlayRef.keydownEvents().subscribe(event => {
            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
            if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {
                this.resetActiveItem();
                this.closeKeyEventStream.next();
                // We need to stop propagation, otherwise the event will eventually
                // reach the input itself and cause the overlay to be reopened.
                event.stopPropagation();
                event.preventDefault();
            }
        });
        this.panelOpened = true;
        this.autocompleteComponent.open();
    }
    closePanel() {
        if (this.autocompleteRef) {
            this.autocompleteRef.close();
            this.cdr.detectChanges();
            this.closingActionsSubscription.unsubscribe();
        }
    }
    createOverlay() {
        const config = Object.assign({
            origin: this.elementRef.nativeElement,
            viewContainerRef: this.viewContainerRef,
            placement: this.thyPlacement,
            offset: this.thyOffset,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
            width: this.thyAutocompleteWidth || this.elementRef.nativeElement.clientWidth
        });
        this.autocompleteRef = this.autocompleteService.open(this.autocompleteComponent.contentTemplateRef, config);
        this.autocompleteRef.afterClosed().subscribe(() => {
            this.panelOpened = false;
            this.autocompleteComponent.close();
        });
        // delay 200ms to prevent emit document click rightnow
        this.autocompleteRef
            .afterOpened()
            .pipe(delay(200))
            .subscribe(() => {
            this.closingActionsSubscription = this.subscribeToClosingActions();
        });
        return this.autocompleteRef.getOverlayRef();
    }
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     */
    subscribeToClosingActions() {
        const firstStable = this.ngZone.onStable.asObservable().pipe(take(1));
        const optionChanges = this.autocompleteComponent.options.changes.pipe(
        // Defer emitting to the stream until the next tick, because changing
        // bindings in here will cause "changed after checked" errors.
        delay(0));
        // When the zone is stable initially, and when the option list changes...
        return (merge(firstStable, optionChanges)
            .pipe(
        // create a new stream of panelClosingActions, replacing any previous streams
        // that were created, and flatten it so our stream only emits closing events...
        switchMap(() => {
            this.resetActiveItem();
            if (this.panelOpened) {
                this.overlayRef.updatePosition();
            }
            return this.panelClosingActions;
        }), 
        // when the first closing event occurs...
        take(1))
            // set the value, close the panel, and complete.
            .subscribe(event => this.setValueAndClose(event)));
    }
    setValueAndClose(event) {
        if (event && event.option) {
            this.setValue(event.option.thyLabelText);
        }
        this.closePanel();
    }
    /** Stream of clicks outside of the autocomplete panel. */
    getOutsideClickStream() {
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter(event => {
            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
            // fall back to check the first element in the path of the click event.
            const clickTarget = event.target;
            const formField = null;
            return (this.panelOpened &&
                clickTarget !== this.elementRef.nativeElement &&
                (!formField || !formField.contains(clickTarget)) &&
                !!this.overlayRef &&
                !this.overlayRef.overlayElement.contains(clickTarget));
        }));
    }
    setValue(value) {
        this.elementRef.nativeElement.value = value;
        this.elementRef.nativeElement.focus();
    }
    canOpen() {
        const element = this.elementRef.nativeElement;
        return !element.readOnly && !element.disabled;
    }
    resetActiveItem() {
        this.autocompleteComponent.keyManager.setActiveItem(this.autocompleteComponent.thyAutoActiveFirstOption ? 0 : -1);
    }
    destroyPanel() {
        if (this.overlayRef) {
            this.closePanel();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
    }
    ngOnDestroy() {
        this.closeKeyEventStream.complete();
        this.destroyPanel();
    }
}
ThyAutocompleteTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[thyAutocompleteTrigger], textarea[thyAutocompleteTrigger]',
                exportAs: 'thyAutocompleteTrigger',
                host: {
                    '(input)': 'handleInput($event)',
                    '(focusin)': 'onFocus()',
                    '(keydown)': 'onKeydown($event)'
                }
            },] }
];
ThyAutocompleteTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Overlay },
    { type: ThyAutocompleteService },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef }
];
ThyAutocompleteTriggerDirective.propDecorators = {
    panelOpened: [{ type: HostBinding, args: [`class.thy-autocomplete-opened`,] }],
    autocompleteComponent: [{ type: Input, args: ['thyAutocompleteComponent',] }],
    autocomplete: [{ type: Input, args: ['thyAutocomplete',] }],
    thyOffset: [{ type: Input }],
    thyAutocompleteWidth: [{ type: Input }],
    thyPlacement: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLnRyaWdnZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2F1dG9jb21wbGV0ZS9hdXRvY29tcGxldGUudHJpZ2dlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBRVYsTUFBTSxFQUVOLEtBQUssRUFFTCxnQkFBZ0IsRUFDaEIsV0FBVyxFQUNYLFFBQVEsRUFDUixNQUFNLEVBQ04saUJBQWlCLEVBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBYyxPQUFPLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUczRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUV4RSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNwRSxPQUFPLEVBQXNCLDZCQUE2QixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxPQUFPLEVBQWMsS0FBSyxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQy9FLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0UsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFPLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBV2xELE1BQU0sT0FBTywrQkFBK0I7SUF1RHhDLFlBQ1ksVUFBc0IsRUFDdEIsTUFBYyxFQUNkLE9B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QixDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QixDQUFDOzs7WUF4UUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxpRUFBaUU7Z0JBQzNFLFFBQVEsRUFBRSx3QkFBd0I7Z0JBQ2xDLElBQUksRUFBRTtvQkFDRixTQUFTLEVBQUUscUJBQXFCO29CQUNoQyxXQUFXLEVBQUUsV0FBVztvQkFDeEIsV0FBVyxFQUFFLG1CQUFtQjtpQkFDbkM7YUFDSjs7O1lBbkNHLFVBQVU7WUFFVixNQUFNO1lBV1csT0FBTztZQUduQixzQkFBc0I7WUFWM0IsZ0JBQWdCOzRDQTJGWCxRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7WUF2RmhDLGlCQUFpQjs7OzBCQXFDaEIsV0FBVyxTQUFDLCtCQUErQjtvQ0FFM0MsS0FBSyxTQUFDLDBCQUEwQjsyQkFLaEMsS0FBSyxTQUFDLGlCQUFpQjt3QkFVdkIsS0FBSzttQ0FFTCxLQUFLOzJCQUVMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEluamVjdGFibGUsXG4gICAgTmdab25lLFxuICAgIE9uRGVzdHJveSxcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgVmlld0NvbnRhaW5lclJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBPcHRpb25hbCxcbiAgICBJbmplY3QsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBPdmVybGF5UmVmLCBPdmVybGF5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgVGh5T3ZlcmxheURpcmVjdGl2ZUJhc2UsIFRoeVBsYWNlbWVudCB9IGZyb20gJ25neC10ZXRoeXMvY29yZSc7XG5pbXBvcnQgeyBUaHlBdXRvY29tcGxldGVTZXJ2aWNlIH0gZnJvbSAnLi9vdmVybGF5L2F1dG9jb21wbGV0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IFRoeUF1dG9jb21wbGV0ZVJlZiB9IGZyb20gJy4vb3ZlcmxheS9hdXRvY29tcGxldGUtcmVmJztcbmltcG9ydCB7IFRoeUF1dG9jb21wbGV0ZUNvbXBvbmVudCB9IGZyb20gJy4vYXV0b2NvbXBsZXRlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaHlPcHRpb25Db21wb25lbnQsIFRoeU9wdGlvblNlbGVjdGlvbkNoYW5nZUV2ZW50IH0gZnJvbSAnbmd4LXRldGh5cy9zaGFyZWQnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgU3ViamVjdCwgT2JzZXJ2YWJsZSwgbWVyZ2UsIGZyb21FdmVudCwgb2YsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRVNDQVBFLCBVUF9BUlJPVywgRU5URVIsIERPV05fQVJST1csIFRBQiB9IGZyb20gJ25neC10ZXRoeXMvdXRpbCc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFrZSwgdGFwLCBkZWxheSwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU2Nyb2xsVG9TZXJ2aWNlIH0gZnJvbSAnbmd4LXRldGh5cy9jb3JlJztcbmltcG9ydCB7IHdhcm5EZXByZWNhdGlvbiB9IGZyb20gJ25neC10ZXRoeXMvdXRpbCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnaW5wdXRbdGh5QXV0b2NvbXBsZXRlVHJpZ2dlcl0sIHRleHRhcmVhW3RoeUF1dG9jb21wbGV0ZVRyaWdnZXJdJyxcbiAgICBleHBvcnRBczogJ3RoeUF1dG9jb21wbGV0ZVRyaWdnZXInLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyhpbnB1dCknOiAnaGFuZGxlSW5wdXQoJGV2ZW50KScsXG4gICAgICAgICcoZm9jdXNpbiknOiAnb25Gb2N1cygpJyxcbiAgICAgICAgJyhrZXlkb3duKSc6ICdvbktleWRvd24oJGV2ZW50KSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFRoeUF1dG9jb21wbGV0ZVRyaWdnZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJvdGVjdGVkIG92ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgICBwcml2YXRlIGF1dG9jb21wbGV0ZVJlZjogVGh5QXV0b2NvbXBsZXRlUmVmPFRoeUF1dG9jb21wbGV0ZUNvbXBvbmVudD47XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGNsb3NlS2V5RXZlbnRTdHJlYW0gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgcHJpdmF0ZSBjbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgcHJpdmF0ZSBfYXV0b2NvbXBsZXRlQ29tcG9uZW50OiBUaHlBdXRvY29tcGxldGVDb21wb25lbnQ7XG5cbiAgICBASG9zdEJpbmRpbmcoYGNsYXNzLnRoeS1hdXRvY29tcGxldGUtb3BlbmVkYCkgcGFuZWxPcGVuZWQgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgndGh5QXV0b2NvbXBsZXRlQ29tcG9uZW50JylcbiAgICBzZXQgYXV0b2NvbXBsZXRlQ29tcG9uZW50KGRhdGE6IFRoeUF1dG9jb21wbGV0ZUNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLl9hdXRvY29tcGxldGVDb21wb25lbnQgPSBkYXRhO1xuICAgIH1cblxuICAgIEBJbnB1dCgndGh5QXV0b2NvbXBsZXRlJylcbiAgICBzZXQgYXV0b2NvbXBsZXRlKGRhdGE6IFRoeUF1dG9jb21wbGV0ZUNvbXBvbmVudCkge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb24oYFRoZSBwcm9wZXJ0eSB0aHlBdXRvY29tcGxldGUgd2lsbCBiZSBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoeUF1dG9jb21wbGV0ZUNvbXBvbmVudCBpbnN0ZWFkLmApO1xuICAgICAgICB0aGlzLl9hdXRvY29tcGxldGVDb21wb25lbnQgPSBkYXRhO1xuICAgIH1cblxuICAgIGdldCBhdXRvY29tcGxldGVDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvY29tcGxldGVDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgQElucHV0KCkgdGh5T2Zmc2V0ID0gNDtcblxuICAgIEBJbnB1dCgpIHRoeUF1dG9jb21wbGV0ZVdpZHRoOiBudW1iZXI7XG5cbiAgICBASW5wdXQoKSB0aHlQbGFjZW1lbnQ6IFRoeVBsYWNlbWVudCA9ICdib3R0b21MZWZ0JztcblxuICAgIGdldCBhY3RpdmVPcHRpb24oKTogVGh5T3B0aW9uQ29tcG9uZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudCAmJiB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5rZXlNYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlci5hY3RpdmVJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHBhbmVsQ2xvc2luZ0FjdGlvbnMoKTogT2JzZXJ2YWJsZTxUaHlPcHRpb25TZWxlY3Rpb25DaGFuZ2VFdmVudCB8IG51bGw+IHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKFxuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQudGh5T3B0aW9uU2VsZWN0ZWQsXG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5rZXlNYW5hZ2VyLnRhYk91dC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLnBhbmVsT3BlbmVkKSksXG4gICAgICAgICAgICB0aGlzLmNsb3NlS2V5RXZlbnRTdHJlYW0sXG4gICAgICAgICAgICB0aGlzLmdldE91dHNpZGVDbGlja1N0cmVhbSgpLFxuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmID8gdGhpcy5vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5wYW5lbE9wZW5lZCkpIDogb2YoKVxuICAgICAgICApLnBpcGUoXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIG91dHB1dCBzbyB3ZSByZXR1cm4gYSBjb25zaXN0ZW50IHR5cGUuXG4gICAgICAgICAgICBtYXAoZXZlbnQgPT4gKGV2ZW50IGluc3RhbmNlb2YgVGh5T3B0aW9uU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPyBldmVudCA6IG51bGwpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgICAgIHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJpdmF0ZSBhdXRvY29tcGxldGVTZXJ2aWNlOiBUaHlBdXRvY29tcGxldGVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICAgKSB7fVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxuXG4gICAgb25Gb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuT3BlbigpKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuXG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIG9uIGFsbCBlc2NhcGUga2V5IHByZXNzZXMuIFRoaXMgaXMgaGVyZSBwcmltYXJpbHkgdG8gYnJpbmcgSUVcbiAgICAgICAgLy8gaW4gbGluZSB3aXRoIG90aGVyIGJyb3dzZXJzLiBCeSBkZWZhdWx0LCBwcmVzc2luZyBlc2NhcGUgb24gSUUgd2lsbCBjYXVzZSBpdCB0byByZXZlcnRcbiAgICAgICAgLy8gdGhlIGlucHV0IHZhbHVlIHRvIHRoZSBvbmUgdGhhdCBpdCBoYWQgb24gZm9jdXMsIGhvd2V2ZXIgaXQgd29uJ3QgZGlzcGF0Y2ggYW55IGV2ZW50c1xuICAgICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHRoZSBtb2RlbCB2YWx1ZSB3aWxsIGJlIG91dCBvZiBzeW5jIHdpdGggdGhlIHZpZXcuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBFU0NBUEUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlT3B0aW9uICYmIGtleUNvZGUgPT09IEVOVEVSICYmIHRoaXMucGFuZWxPcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlT3B0aW9uLnNlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0QWN0aXZlSXRlbSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uc3QgcHJldkFjdGl2ZUl0ZW0gPSB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW07XG4gICAgICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0ga2V5Q29kZSA9PT0gVVBfQVJST1cgfHwga2V5Q29kZSA9PT0gRE9XTl9BUlJPVztcbiAgICAgICAgICAgIGlmICh0aGlzLnBhbmVsT3BlbmVkIHx8IGtleUNvZGUgPT09IFRBQikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LmtleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJvd0tleSAmJiB0aGlzLmNhbk9wZW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlblBhbmVsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGlzQXJyb3dLZXkgfHwgdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlci5hY3RpdmVJdGVtICE9PSBwcmV2QWN0aXZlSXRlbSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIFNjcm9sbFRvU2VydmljZS5zY3JvbGxUb0VsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LmtleU1hbmFnZXIuYWN0aXZlSXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50Lm9wdGlvbnNDb250YWluZXIubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVJbnB1dChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5jYW5PcGVuKCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlblBhbmVsKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5UmVmICYmIHRoaXMub3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3ZlcmxheVJlZiA9IHRoaXMuY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSBvdmVybGF5UmVmO1xuICAgICAgICBvdmVybGF5UmVmLmtleWRvd25FdmVudHMoKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAgICAgLy8gQ2xvc2Ugd2hlbiBwcmVzc2luZyBFU0NBUEUgb3IgQUxUICsgVVBfQVJST1csIGJhc2VkIG9uIHRoZSBhMTF5IGd1aWRlbGluZXMuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMtMS4xLyN0ZXh0Ym94LWtleWJvYXJkLWludGVyYWN0aW9uXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFIHx8IChldmVudC5rZXlDb2RlID09PSBVUF9BUlJPVyAmJiBldmVudC5hbHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlS2V5RXZlbnRTdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiwgb3RoZXJ3aXNlIHRoZSBldmVudCB3aWxsIGV2ZW50dWFsbHlcbiAgICAgICAgICAgICAgICAvLyByZWFjaCB0aGUgaW5wdXQgaXRzZWxmIGFuZCBjYXVzZSB0aGUgb3ZlcmxheSB0byBiZSByZW9wZW5lZC5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYW5lbE9wZW5lZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50Lm9wZW4oKTtcbiAgICB9XG5cbiAgICBjbG9zZVBhbmVsKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvY29tcGxldGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICB2aWV3Q29udGFpbmVyUmVmOiB0aGlzLnZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMudGh5UGxhY2VtZW50LFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLnRoeU9mZnNldCxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy50aHlBdXRvY29tcGxldGVXaWR0aCB8fCB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVSZWYgPSB0aGlzLmF1dG9jb21wbGV0ZVNlcnZpY2Uub3Blbih0aGlzLmF1dG9jb21wbGV0ZUNvbXBvbmVudC5jb250ZW50VGVtcGxhdGVSZWYsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFuZWxPcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkZWxheSAyMDBtcyB0byBwcmV2ZW50IGVtaXQgZG9jdW1lbnQgY2xpY2sgcmlnaHRub3dcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVSZWZcbiAgICAgICAgICAgIC5hZnRlck9wZW5lZCgpXG4gICAgICAgICAgICAucGlwZShkZWxheSgyMDApKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaWJlVG9DbG9zaW5nQWN0aW9ucygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9jb21wbGV0ZVJlZi5nZXRPdmVybGF5UmVmKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBhIHN0cmVhbSBvZiBwYW5lbCBjbG9zaW5nIGFjdGlvbnMgYW5kIHJlc2V0cyB0aGVcbiAgICAgKiBzdHJlYW0gZXZlcnkgdGltZSB0aGUgb3B0aW9uIGxpc3QgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMoKTogU3Vic2NyaXB0aW9uIHtcbiAgICAgICAgY29uc3QgZmlyc3RTdGFibGUgPSB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpO1xuICAgICAgICBjb25zdCBvcHRpb25DaGFuZ2VzID0gdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQub3B0aW9ucy5jaGFuZ2VzLnBpcGUoXG4gICAgICAgICAgICAvLyBEZWZlciBlbWl0dGluZyB0byB0aGUgc3RyZWFtIHVudGlsIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIGJpbmRpbmdzIGluIGhlcmUgd2lsbCBjYXVzZSBcImNoYW5nZWQgYWZ0ZXIgY2hlY2tlZFwiIGVycm9ycy5cbiAgICAgICAgICAgIGRlbGF5KDApXG4gICAgICAgICk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHpvbmUgaXMgc3RhYmxlIGluaXRpYWxseSwgYW5kIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGNoYW5nZXMuLi5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG1lcmdlKGZpcnN0U3RhYmxlLCBvcHRpb25DaGFuZ2VzKVxuICAgICAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgc3RyZWFtIG9mIHBhbmVsQ2xvc2luZ0FjdGlvbnMsIHJlcGxhY2luZyBhbnkgcHJldmlvdXMgc3RyZWFtc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdlcmUgY3JlYXRlZCwgYW5kIGZsYXR0ZW4gaXQgc28gb3VyIHN0cmVhbSBvbmx5IGVtaXRzIGNsb3NpbmcgZXZlbnRzLi4uXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWN0aXZlSXRlbSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYW5lbE9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWxDbG9zaW5nQWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IGNsb3NpbmcgZXZlbnQgb2NjdXJzLi4uXG4gICAgICAgICAgICAgICAgICAgIHRha2UoMSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSwgY2xvc2UgdGhlIHBhbmVsLCBhbmQgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiB0aGlzLnNldFZhbHVlQW5kQ2xvc2UoZXZlbnQpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VmFsdWVBbmRDbG9zZShldmVudDogVGh5T3B0aW9uU2VsZWN0aW9uQ2hhbmdlRXZlbnQgfCBudWxsKTogdm9pZCB7XG4gICAgICAgIGlmIChldmVudCAmJiBldmVudC5vcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoZXZlbnQub3B0aW9uLnRoeUxhYmVsVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfVxuXG4gICAgLyoqIFN0cmVhbSBvZiBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLiAqL1xuICAgIHByaXZhdGUgZ2V0T3V0c2lkZUNsaWNrU3RyZWFtKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIHJldHVybiBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnY2xpY2snKSBhcyBPYnNlcnZhYmxlPE1vdXNlRXZlbnQ+LFxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICd0b3VjaGVuZCcpIGFzIE9ic2VydmFibGU8VG91Y2hFdmVudD5cbiAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgU2hhZG93IERPTSwgdGhlIGV2ZW50IHRhcmdldCB3aWxsIGJlIHRoZSBzaGFkb3cgcm9vdCwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBjaGVjayB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcGF0aCBvZiB0aGUgY2xpY2sgZXZlbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpY2tUYXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkOiBhbnkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW5lbE9wZW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBjbGlja1RhcmdldCAhPT0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmb3JtRmllbGQgfHwgIWZvcm1GaWVsZC5jb250YWlucyhjbGlja1RhcmdldCkpICYmXG4gICAgICAgICAgICAgICAgICAgICEhdGhpcy5vdmVybGF5UmVmICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQuY29udGFpbnMoY2xpY2tUYXJnZXQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYW5PcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHJldHVybiAhZWxlbWVudC5yZWFkT25seSAmJiAhZWxlbWVudC5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2V0QWN0aXZlSXRlbSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVDb21wb25lbnQua2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKHRoaXMuYXV0b2NvbXBsZXRlQ29tcG9uZW50LnRoeUF1dG9BY3RpdmVGaXJzdE9wdGlvbiA/IDAgOiAtMSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZXN0cm95UGFuZWwoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUtleUV2ZW50U3RyZWFtLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBhbmVsKCk7XG4gICAgfVxufVxuIl19