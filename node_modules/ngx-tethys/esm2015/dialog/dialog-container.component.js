import { Component, ChangeDetectionStrategy, ViewChild, ElementRef, Inject, EventEmitter, ChangeDetectorRef, HostBinding } from '@angular/core';
import { CdkPortalOutlet } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { ThyDialogConfig } from './dialog.config';
import { thyDialogAnimations } from './dialog-animations';
import { ThyClickPositioner } from 'ngx-tethys/core';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { ThyAbstractOverlayContainer } from 'ngx-tethys/core';
import { dialogUpperOverlayOptions } from './dialog.options';
import { filter } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './dialog.config';
import * as ɵngcc2 from 'ngx-tethys/core';
import * as ɵngcc3 from '@angular/cdk/a11y';
import * as ɵngcc4 from '@angular/cdk/portal';

function ThyDialogContainerComponent_ng_template_0_Template(rf, ctx) { }
export class ThyDialogContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, clickPositioner, focusTrapFactory) {
        super(dialogUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.clickPositioner = clickPositioner;
        this.focusTrapFactory = focusTrapFactory;
        /** State of the dialog animation. */
        this.animationState = 'void';
        /** Emits when an animation state changes. */
        this.animationStateChanged = new EventEmitter();
        /** ID of the element that should be considered as the dialog's label. */
        this.ariaLabelledBy = null;
        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
        this.elementFocusedBeforeDialogWasOpened = null;
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'void';
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
    }
    savePreviouslyFocusedElement() {
        if (this.document) {
            this.elementFocusedBeforeDialogWasOpened = this.document.activeElement;
            // Note that there is no focus method when rendering on the server.
            if (this.elementRef.nativeElement.focus) {
                // Move focus onto the dialog immediately in order to prevent the user from accidentally
                // opening multiple dialogs at the same time. Needs to be async, because the element
                // may not be focusable immediately.
                Promise.resolve().then(() => this.elementRef.nativeElement.focus());
            }
        }
    }
    /** Moves the focus inside the focus trap. */
    trapFocus() {
        const element = this.elementRef.nativeElement;
        if (!this.focusTrap) {
            this.focusTrap = this.focusTrapFactory.create(element);
        }
        // If we were to attempt to focus immediately, then the content of the dialog would not yet be
        // ready in instances where change detection has to run first. To deal with this, we simply
        // wait for the microtask queue to be empty.
        if (this.config.autoFocus) {
            this.focusTrap.focusInitialElementWhenReady();
        }
        else {
            const activeElement = this.document.activeElement;
            // Otherwise ensure that focus is on the dialog container. It's possible that a different
            // component tried to move focus while the open animation was running. See:
            // https://github.com/angular/components/issues/16215. Note that we only want to do this
            // if the focus isn't inside the dialog already, because it's possible that the consumer
            // turned off `autoFocus` in order to move focus themselves.
            if (activeElement !== element && !element.contains(activeElement)) {
                element.focus();
            }
        }
    }
    restoreFocus() {
        const toFocus = this.elementFocusedBeforeDialogWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (this.config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
        if (this.focusTrap) {
            this.focusTrap.destroy();
        }
    }
    setTransformOrigin() {
        this.clickPositioner.runTaskUseLastPosition(lastPosition => {
            if (lastPosition) {
                const containerElement = this.elementRef.nativeElement;
                const transformOrigin = `${lastPosition.x - containerElement.offsetLeft}px ${lastPosition.y -
                    containerElement.offsetTop}px 0px`;
                containerElement.style['transform-origin'] = transformOrigin;
                // 手动修改动画状态为从 void 到 enter, 开启动画
            }
            this.animationState = 'enter';
        });
    }
    beforeAttachPortal() {
        this.setTransformOrigin();
        this.savePreviouslyFocusedElement();
    }
    /** Callback, invoked whenever an animation on the host completes. */
    onAnimationDone(event) {
        if (event.toState === 'void') {
            this.trapFocus();
        }
        else if (event.toState === 'exit') {
            this.restoreFocus();
        }
        this.animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    ngOnDestroy() {
        super.destroy();
    }
}
ThyDialogContainerComponent.ɵfac = function ThyDialogContainerComponent_Factory(t) { return new (t || ThyDialogContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ThyDialogConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ThyClickPositioner), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.FocusTrapFactory)); };
ThyDialogContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyDialogContainerComponent, selectors: [["thy-dialog-container"]], viewQuery: function ThyDialogContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(CdkPortalOutlet, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "thy-dialog-container"], hostVars: 6, hostBindings: function ThyDialogContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@dialogContainer.start", function ThyDialogContainerComponent_animation_dialogContainer_start_HostBindingHandler($event) { return ctx.onAnimationStart($event); })("@dialogContainer.done", function ThyDialogContainerComponent_animation_dialogContainer_done_HostBindingHandler($event) { return ctx.onAnimationDone($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.config.role)("aria-labelledby", ctx.config.ariaLabel ? null : ctx.ariaLabelledBy)("aria-label", ctx.config.ariaLabel)("aria-describedby", ctx.config.ariaDescribedBy || null);
        ɵngcc0.ɵɵsyntheticHostProperty("@dialogContainer", ctx.animationState);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function ThyDialogContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ThyDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [ɵngcc4.CdkPortalOutlet], encapsulation: 2, data: { animation: [thyDialogAnimations.dialogContainer] } });
ThyDialogContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThyDialogConfig },
    { type: ChangeDetectorRef },
    { type: ThyClickPositioner },
    { type: FocusTrapFactory }
];
ThyDialogContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }],
    id: [{ type: HostBinding, args: [`attr.id`,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDialogContainerComponent, [{
        type: Component,
        args: [{
                selector: 'thy-dialog-container',
                template: `
        <ng-template cdkPortalOutlet></ng-template>
    `,
                // Using OnPush for dialogs caused some sync issues, e.g. custom ngModel can't to detect changes
                // Disabled until we can track them down.
                changeDetection: ChangeDetectionStrategy.Default,
                animations: [thyDialogAnimations.dialogContainer],
                host: {
                    class: 'thy-dialog-container',
                    tabindex: '-1',
                    'aria-modal': 'true',
                    '[attr.id]': 'id',
                    '[attr.role]': 'config.role',
                    '[attr.aria-labelledby]': 'config.ariaLabel ? null : ariaLabelledBy',
                    '[attr.aria-label]': 'config.ariaLabel',
                    '[attr.aria-describedby]': 'config.ariaDescribedBy || null',
                    '[@dialogContainer]': 'animationState',
                    '(@dialogContainer.start)': 'onAnimationStart($event)',
                    '(@dialogContainer.done)': 'onAnimationDone($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc1.ThyDialogConfig }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.ThyClickPositioner }, { type: ɵngcc3.FocusTrapFactory }]; }, { portalOutlet: [{
            type: ViewChild,
            args: [CdkPortalOutlet, { static: true }]
        }], id: [{
            type: HostBinding,
            args: [`attr.id`]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLWNvbnRhaW5lci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsb2cvZGlhbG9nLWNvbnRhaW5lci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCx1QkFBdUIsRUFFdkIsU0FBUyxFQUVULFVBQVUsRUFDVixNQUFNLEVBQ04sWUFBWSxFQUNaLGlCQUFpQixFQUNqQixXQUFXLEVBRWQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFtQixlQUFlLEVBQWtCLE1BQU0scUJBQXFCLENBQUM7QUFDdkYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQWEsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUU3RCxPQUFPLEVBQU8sTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7O0FBeUI3QyxNQUFNLE9BQU8sMkJBQTRCLFNBQVEsMkJBQTJCO0FBQUcsSUE0RjNFLFlBQ1ksVUFBc0IsRUFDSixRQUFhLEVBQ2hDLE1BQXVCLEVBQzlCLGlCQUFvQyxFQUM1QixlQUFtQyxFQUNuQyxnQkFBa0M7QUFDL0MsUUFDSyxLQUFLLENBQUMseUJBQXlCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztBQUM1RCxRQVJnQixlQUFVLEdBQVYsVUFBVSxDQUFZO0FBQUMsUUFDTCxhQUFRLEdBQVIsUUFBUSxDQUFLO0FBQUMsUUFD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QUFFLGdCQUFnQixzQkFDdEMsMEJBQTBCLEVBQUUsMEJBQTBCLHNCQUN0RCx5QkFBeUIsRUFBRSx5QkFBeUIsa0JBQ3ZELGNBQ0o7Ozs7OzsrSEFDSTtBQUFDO0FBQXFELFlBMUN2RCxVQUFVO0FBQ1osNENBdUlPLE1BQU0sU0FBQyxRQUFRO0FBQVMsWUE5SHhCLGVBQWU7QUFBSSxZQVB4QixpQkFBaUI7QUFDbkIsWUFRTyxrQkFBa0I7QUFBSSxZQUN0QixnQkFBZ0I7QUFBRztBQUFHO0FBQ2xCLDJCQWdDUixTQUFTLFNBQUMsZUFBZSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtBQUMzQyxpQkFFQSxXQUFXLFNBQUMsU0FBUztBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENvbXBvbmVudFJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5qZWN0LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwsIENka1BvcnRhbE91dGxldCwgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFuaW1hdGlvbkV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBUaHlEaWFsb2dDb25maWcgfSBmcm9tICcuL2RpYWxvZy5jb25maWcnO1xuaW1wb3J0IHsgdGh5RGlhbG9nQW5pbWF0aW9ucyB9IGZyb20gJy4vZGlhbG9nLWFuaW1hdGlvbnMnO1xuaW1wb3J0IHsgVGh5Q2xpY2tQb3NpdGlvbmVyIH0gZnJvbSAnbmd4LXRldGh5cy9jb3JlJztcbmltcG9ydCB7IEZvY3VzVHJhcEZhY3RvcnksIEZvY3VzVHJhcCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IFRoeUFic3RyYWN0T3ZlcmxheUNvbnRhaW5lciB9IGZyb20gJ25neC10ZXRoeXMvY29yZSc7XG5pbXBvcnQgeyBkaWFsb2dVcHBlck92ZXJsYXlPcHRpb25zIH0gZnJvbSAnLi9kaWFsb2cub3B0aW9ucyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0aHktZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlIGNka1BvcnRhbE91dGxldD48L25nLXRlbXBsYXRlPlxuICAgIGAsXG4gICAgLy8gVXNpbmcgT25QdXNoIGZvciBkaWFsb2dzIGNhdXNlZCBzb21lIHN5bmMgaXNzdWVzLCBlLmcuIGN1c3RvbSBuZ01vZGVsIGNhbid0IHRvIGRldGVjdCBjaGFuZ2VzXG4gICAgLy8gRGlzYWJsZWQgdW50aWwgd2UgY2FuIHRyYWNrIHRoZW0gZG93bi5cbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgYW5pbWF0aW9uczogW3RoeURpYWxvZ0FuaW1hdGlvbnMuZGlhbG9nQ29udGFpbmVyXSxcbiAgICBob3N0OiB7XG4gICAgICAgIGNsYXNzOiAndGh5LWRpYWxvZy1jb250YWluZXInLFxuICAgICAgICB0YWJpbmRleDogJy0xJyxcbiAgICAgICAgJ2FyaWEtbW9kYWwnOiAndHJ1ZScsXG4gICAgICAgICdbYXR0ci5pZF0nOiAnaWQnLFxuICAgICAgICAnW2F0dHIucm9sZV0nOiAnY29uZmlnLnJvbGUnLFxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdjb25maWcuYXJpYUxhYmVsID8gbnVsbCA6IGFyaWFMYWJlbGxlZEJ5JyxcbiAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ2NvbmZpZy5hcmlhTGFiZWwnLFxuICAgICAgICAnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnY29uZmlnLmFyaWFEZXNjcmliZWRCeSB8fCBudWxsJyxcbiAgICAgICAgJ1tAZGlhbG9nQ29udGFpbmVyXSc6ICdhbmltYXRpb25TdGF0ZScsXG4gICAgICAgICcoQGRpYWxvZ0NvbnRhaW5lci5zdGFydCknOiAnb25BbmltYXRpb25TdGFydCgkZXZlbnQpJyxcbiAgICAgICAgJyhAZGlhbG9nQ29udGFpbmVyLmRvbmUpJzogJ29uQW5pbWF0aW9uRG9uZSgkZXZlbnQpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVGh5RGlhbG9nQ29udGFpbmVyQ29tcG9uZW50IGV4dGVuZHMgVGh5QWJzdHJhY3RPdmVybGF5Q29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBhbmltYXRpb25PcGVuaW5nRG9uZTogT2JzZXJ2YWJsZTxBbmltYXRpb25FdmVudD47XG4gICAgYW5pbWF0aW9uQ2xvc2luZ0RvbmU6IE9ic2VydmFibGU8QW5pbWF0aW9uRXZlbnQ+O1xuXG4gICAgQFZpZXdDaGlsZChDZGtQb3J0YWxPdXRsZXQsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcG9ydGFsT3V0bGV0OiBDZGtQb3J0YWxPdXRsZXQ7XG5cbiAgICBASG9zdEJpbmRpbmcoYGF0dHIuaWRgKVxuICAgIGlkOiBzdHJpbmc7XG5cbiAgICAvKiogU3RhdGUgb2YgdGhlIGRpYWxvZyBhbmltYXRpb24uICovXG4gICAgYW5pbWF0aW9uU3RhdGU6ICd2b2lkJyB8ICdlbnRlcicgfCAnZXhpdCcgPSAndm9pZCc7XG5cbiAgICAvKiogRW1pdHMgd2hlbiBhbiBhbmltYXRpb24gc3RhdGUgY2hhbmdlcy4gKi9cbiAgICBhbmltYXRpb25TdGF0ZUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPEFuaW1hdGlvbkV2ZW50PigpO1xuXG4gICAgLyoqIElEIG9mIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGRpYWxvZydzIGxhYmVsLiAqL1xuICAgIGFyaWFMYWJlbGxlZEJ5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgIC8qKiBFbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkaWFsb2cgd2FzIG9wZW5lZC4gU2F2ZSB0aGlzIHRvIHJlc3RvcmUgdXBvbiBjbG9zZS4gKi9cbiAgICBwcml2YXRlIGVsZW1lbnRGb2N1c2VkQmVmb3JlRGlhbG9nV2FzT3BlbmVkOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gICAgLyoqIFRoZSBjbGFzcyB0aGF0IHRyYXBzIGFuZCBtYW5hZ2VzIGZvY3VzIHdpdGhpbiB0aGUgZGlhbG9nLiAqL1xuICAgIHByaXZhdGUgZm9jdXNUcmFwOiBGb2N1c1RyYXA7XG5cbiAgICBwcml2YXRlIHNhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRGb2N1c2VkQmVmb3JlRGlhbG9nV2FzT3BlbmVkID0gdGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gZm9jdXMgbWV0aG9kIHdoZW4gcmVuZGVyaW5nIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGZvY3VzIG9udG8gdGhlIGRpYWxvZyBpbW1lZGlhdGVseSBpbiBvcmRlciB0byBwcmV2ZW50IHRoZSB1c2VyIGZyb20gYWNjaWRlbnRhbGx5XG4gICAgICAgICAgICAgICAgLy8gb3BlbmluZyBtdWx0aXBsZSBkaWFsb2dzIGF0IHRoZSBzYW1lIHRpbWUuIE5lZWRzIHRvIGJlIGFzeW5jLCBiZWNhdXNlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gbWF5IG5vdCBiZSBmb2N1c2FibGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBNb3ZlcyB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwLiAqL1xuICAgIHByaXZhdGUgdHJhcEZvY3VzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAgPSB0aGlzLmZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2Ugd2VyZSB0byBhdHRlbXB0IHRvIGZvY3VzIGltbWVkaWF0ZWx5LCB0aGVuIHRoZSBjb250ZW50IG9mIHRoZSBkaWFsb2cgd291bGQgbm90IHlldCBiZVxuICAgICAgICAvLyByZWFkeSBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgdG8gcnVuIGZpcnN0LiBUbyBkZWFsIHdpdGggdGhpcywgd2Ugc2ltcGx5XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZW1wdHkuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBlbnN1cmUgdGhhdCBmb2N1cyBpcyBvbiB0aGUgZGlhbG9nIGNvbnRhaW5lci4gSXQncyBwb3NzaWJsZSB0aGF0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBjb21wb25lbnQgdHJpZWQgdG8gbW92ZSBmb2N1cyB3aGlsZSB0aGUgb3BlbiBhbmltYXRpb24gd2FzIHJ1bm5pbmcuIFNlZTpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvaXNzdWVzLzE2MjE1LiBOb3RlIHRoYXQgd2Ugb25seSB3YW50IHRvIGRvIHRoaXNcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmb2N1cyBpc24ndCBpbnNpZGUgdGhlIGRpYWxvZyBhbHJlYWR5LCBiZWNhdXNlIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgY29uc3VtZXJcbiAgICAgICAgICAgIC8vIHR1cm5lZCBvZmYgYGF1dG9Gb2N1c2AgaW4gb3JkZXIgdG8gbW92ZSBmb2N1cyB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgIT09IGVsZW1lbnQgJiYgIWVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc3RvcmVGb2N1cygpIHtcbiAgICAgICAgY29uc3QgdG9Gb2N1cyA9IHRoaXMuZWxlbWVudEZvY3VzZWRCZWZvcmVEaWFsb2dXYXNPcGVuZWQ7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgZXh0cmEgY2hlY2ssIGJlY2F1c2UgSUUgY2FuIHNldCB0aGUgYGFjdGl2ZUVsZW1lbnRgIHRvIG51bGwgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJlc3RvcmVGb2N1cyAmJiB0b0ZvY3VzICYmIHR5cGVvZiB0b0ZvY3VzLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b0ZvY3VzLmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VHJhbnNmb3JtT3JpZ2luKCkge1xuICAgICAgICB0aGlzLmNsaWNrUG9zaXRpb25lci5ydW5UYXNrVXNlTGFzdFBvc2l0aW9uKGxhc3RQb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAobGFzdFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyRWxlbWVudDogSFRNTEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSBgJHtsYXN0UG9zaXRpb24ueCAtIGNvbnRhaW5lckVsZW1lbnQub2Zmc2V0TGVmdH1weCAke2xhc3RQb3NpdGlvbi55IC1cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5vZmZzZXRUb3B9cHggMHB4YDtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50LnN0eWxlWyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSB0cmFuc2Zvcm1PcmlnaW47XG4gICAgICAgICAgICAgICAgLy8g5omL5Yqo5L+u5pS55Yqo55S754q25oCB5Li65LuOIHZvaWQg5YiwIGVudGVyLCDlvIDlkK/liqjnlLtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnZW50ZXInO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnksXG4gICAgICAgIHB1YmxpYyBjb25maWc6IFRoeURpYWxvZ0NvbmZpZyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIGNsaWNrUG9zaXRpb25lcjogVGh5Q2xpY2tQb3NpdGlvbmVyLFxuICAgICAgICBwcml2YXRlIGZvY3VzVHJhcEZhY3Rvcnk6IEZvY3VzVHJhcEZhY3RvcnlcbiAgICApIHtcbiAgICAgICAgc3VwZXIoZGlhbG9nVXBwZXJPdmVybGF5T3B0aW9ucywgY2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbk9wZW5pbmdEb25lID0gdGhpcy5hbmltYXRpb25TdGF0ZUNoYW5nZWQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnBoYXNlTmFtZSA9PT0gJ2RvbmUnICYmIGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ2xvc2luZ0RvbmUgPSB0aGlzLmFuaW1hdGlvblN0YXRlQ2hhbmdlZC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChldmVudDogQW5pbWF0aW9uRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucGhhc2VOYW1lID09PSAnZG9uZScgJiYgZXZlbnQudG9TdGF0ZSA9PT0gJ2V4aXQnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBiZWZvcmVBdHRhY2hQb3J0YWwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtT3JpZ2luKCk7XG4gICAgICAgIHRoaXMuc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgIH1cblxuICAgIC8qKiBDYWxsYmFjaywgaW52b2tlZCB3aGVuZXZlciBhbiBhbmltYXRpb24gb24gdGhlIGhvc3QgY29tcGxldGVzLiAqL1xuICAgIG9uQW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJykge1xuICAgICAgICAgICAgdGhpcy50cmFwRm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50b1N0YXRlID09PSAnZXhpdCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZUNoYW5nZWQuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIENhbGxiYWNrLCBpbnZva2VkIHdoZW4gYW4gYW5pbWF0aW9uIG9uIHRoZSBob3N0IHN0YXJ0cy4gKi9cbiAgICBvbkFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlQ2hhbmdlZC5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbiJdfQ==