import { Directive, Input, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { instanceOfDateEntry, instanceOfRangeEntry } from './standard-types';
import * as ɵngcc0 from '@angular/core';
const DATE_PICKER_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    // tslint:disable-next-line: no-use-before-declare
    useExisting: forwardRef(() => DatePickerRequiredValidator),
    multi: true
};
export class DatePickerRequiredValidator {
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value != null && value !== false && `${value}` !== 'false';
    }
    validate(control) {
        return this.required ? this.validateRequired(control) : null;
    }
    validateRequired(control) {
        return isEmptyInputDateValue(control.value) ? { required: true } : null;
    }
}
DatePickerRequiredValidator.ɵfac = function DatePickerRequiredValidator_Factory(t) { return new (t || DatePickerRequiredValidator)(); };
DatePickerRequiredValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatePickerRequiredValidator, selectors: [["", "thyDatePicker", "", "required", "", "formControlName", ""], ["", "thyDatePicker", "", "required", "", "formControl", ""], ["", "thyDatePicker", "", "required", "", "ngModel", ""], ["thy-date-picker", "required", "", "formControlName", ""], ["thy-date-picker", "required", "", "formControl", ""], ["thy-date-picker", "required", "", "ngModel", ""]], inputs: { required: "required" }, features: [ɵngcc0.ɵɵProvidersFeature([DATE_PICKER_REQUIRED_VALIDATOR])] });
DatePickerRequiredValidator.propDecorators = {
    required: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerRequiredValidator, [{
        type: Directive,
        args: [{
                selector: '[thyDatePicker][required][formControlName],[thyDatePicker][required][formControl],[thyDatePicker][required][ngModel],thy-date-picker[required][formControlName],thy-date-picker[required][formControl],thy-date-picker[required][ngModel]',
                providers: [DATE_PICKER_REQUIRED_VALIDATOR]
            }]
    }], null, { required: [{
            type: Input
        }] }); })();
const RANGE_PICKER_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    // tslint:disable-next-line: no-use-before-declare
    useExisting: forwardRef(() => RangePickerRequiredValidator),
    multi: true
};
export class RangePickerRequiredValidator {
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value != null && value !== false && `${value}` !== 'false';
    }
    validate(control) {
        return this.required ? this.validateRequired(control) : null;
    }
    validateRequired(control) {
        return isEmptyInputRangeValue(control.value) ? { required: true } : null;
    }
}
RangePickerRequiredValidator.ɵfac = function RangePickerRequiredValidator_Factory(t) { return new (t || RangePickerRequiredValidator)(); };
RangePickerRequiredValidator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RangePickerRequiredValidator, selectors: [["", "thyRangePicker", "", "required", "", "formControlName", ""], ["", "thyRangePicker", "", "required", "", "formControl", ""], ["", "thyRangePicker", "", "required", "", "ngModel", ""], ["thy-range-picker", "required", "", "formControlName", ""], ["thy-range-picker", "required", "", "formControl", ""], ["thy-range-picker", "required", "", "ngModel", ""]], inputs: { required: "required" }, features: [ɵngcc0.ɵɵProvidersFeature([RANGE_PICKER_REQUIRED_VALIDATOR])] });
RangePickerRequiredValidator.propDecorators = {
    required: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RangePickerRequiredValidator, [{
        type: Directive,
        args: [{
                selector: '[thyRangePicker][required][formControlName],[thyRangePicker][required][formControl],[thyRangePicker][required][ngModel],thy-range-picker[required][formControlName],thy-range-picker[required][formControl],thy-range-picker[required][ngModel]',
                providers: [RANGE_PICKER_REQUIRED_VALIDATOR]
            }]
    }], null, { required: [{
            type: Input
        }] }); })();
function isEmptyInputRangeValue(value) {
    return value == null || (instanceOfRangeEntry(value) && (value.begin == null || value.end == null));
}
function isEmptyInputDateValue(value) {
    return value == null || (instanceOfDateEntry(value) && value.date == null);
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2VyLnZhbGlkYXRvcnMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kYXRlLXBpY2tlci9waWNrZXIudmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBa0IsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdFLE9BQU8sRUFBRSxhQUFhLEVBQWdELE1BQU0sZ0JBQWdCLENBQUM7QUFDN0YsT0FBTyxFQUF5QixtQkFBbUIsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDOztBQUVwRyxNQUFNLDhCQUE4QixHQUFtQjtBQUN2RCxJQUFJLE9BQU8sRUFBRSxhQUFhO0FBQzFCLElBQUksa0RBQWtEO0FBQ3RELElBQUksV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQywyQkFBMkIsQ0FBQztBQUM5RCxJQUFJLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxDQUFDO0FBT0YsTUFBTSxPQUFPLDJCQUEyQjtBQUFHLElBR3ZDLElBQ0ksUUFBUTtBQUFLLFFBQ2IsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0FBQzlCLElBQUksQ0FBQztBQUNMLElBQ0ksSUFBSSxRQUFRLENBQUMsS0FBdUI7QUFDeEMsUUFBUSxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLLEtBQUssSUFBSSxHQUFHLEtBQUssRUFBRSxLQUFLLE9BQU8sQ0FBQztBQUNwRixJQUFJLENBQUM7QUFDTCxJQUNJLFFBQVEsQ0FBQyxPQUF3QjtBQUFJLFFBQ2pDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDckUsSUFBSSxDQUFDO0FBQ0wsSUFDWSxnQkFBZ0IsQ0FBQyxPQUF3QjtBQUFJLFFBQ2pELE9BQU8scUJBQXFCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2hGLElBQUksQ0FBQztBQUNMO3VEQXhCQyxTQUFTLFNBQUMsa0JBQ1AsUUFBUSxFQUNKO3VNQUEyTyxrQkFDL08sU0FBUyxFQUFFLENBQUMsOEJBQThCLENBQUMsY0FDOUMsMlNBQ0k7QUFBQztBQUErQyx1QkFHaEQsS0FBSztBQUNUOzs7Ozs7Ozs7b0JBQUU7QUFpQkgsTUFBTSwrQkFBK0IsR0FBbUI7QUFDeEQsSUFBSSxPQUFPLEVBQUUsYUFBYTtBQUMxQixJQUFJLGtEQUFrRDtBQUN0RCxJQUFJLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsNEJBQTRCLENBQUM7QUFDL0QsSUFBSSxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsQ0FBQztBQU9GLE1BQU0sT0FBTyw0QkFBNEI7QUFBRyxJQUd4QyxJQUNJLFFBQVE7QUFBSyxRQUNiLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUM5QixJQUFJLENBQUM7QUFDTCxJQUNJLElBQUksUUFBUSxDQUFDLEtBQXVCO0FBQ3hDLFFBQVEsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLLElBQUksR0FBRyxLQUFLLEVBQUUsS0FBSyxPQUFPLENBQUM7QUFDcEYsSUFBSSxDQUFDO0FBQ0wsSUFDSSxRQUFRLENBQUMsT0FBd0I7QUFBSSxRQUNqQyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3JFLElBQUksQ0FBQztBQUNMLElBQ1ksZ0JBQWdCLENBQUMsT0FBd0I7QUFBSSxRQUNqRCxPQUFPLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNqRixJQUFJLENBQUM7QUFDTDt3REF4QkMsU0FBUyxTQUFDLGtCQUNQLFFBQVEsRUFDSjsyTUFBaVAsa0JBQ3JQLFNBQVMsRUFBRSxDQUFDLCtCQUErQixDQUFDLGNBQy9DLCtTQUNJO0FBQUM7QUFBZ0QsdUJBR2pELEtBQUs7QUFDVDs7Ozs7Ozs7O29CQUFFO0FBaUJILFNBQVMsc0JBQXNCLENBQUMsS0FBaUI7QUFBSSxJQUNqRCxPQUFPLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN4RyxDQUFDO0FBRUQsU0FBUyxxQkFBcUIsQ0FBQyxLQUFnQjtBQUFJLElBQy9DLE9BQU8sS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUM7QUFDL0UsQ0FBQztBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgU3RhdGljUHJvdmlkZXIsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGF0ZUVudHJ5LCBSYW5nZUVudHJ5LCBpbnN0YW5jZU9mRGF0ZUVudHJ5LCBpbnN0YW5jZU9mUmFuZ2VFbnRyeSB9IGZyb20gJy4vc3RhbmRhcmQtdHlwZXMnO1xuXG5jb25zdCBEQVRFX1BJQ0tFUl9SRVFVSVJFRF9WQUxJREFUT1I6IFN0YXRpY1Byb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11c2UtYmVmb3JlLWRlY2xhcmVcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlUGlja2VyUmVxdWlyZWRWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjpcbiAgICAgICAgJ1t0aHlEYXRlUGlja2VyXVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSxbdGh5RGF0ZVBpY2tlcl1bcmVxdWlyZWRdW2Zvcm1Db250cm9sXSxbdGh5RGF0ZVBpY2tlcl1bcmVxdWlyZWRdW25nTW9kZWxdLHRoeS1kYXRlLXBpY2tlcltyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSx0aHktZGF0ZS1waWNrZXJbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSx0aHktZGF0ZS1waWNrZXJbcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICBwcm92aWRlcnM6IFtEQVRFX1BJQ0tFUl9SRVFVSVJFRF9WQUxJREFUT1JdXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJSZXF1aXJlZFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG4gICAgcHJpdmF0ZSBfcmVxdWlyZWQhOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgcmVxdWlyZWQoKTogYm9vbGVhbiB8IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1aXJlZDtcbiAgICB9XG5cbiAgICBzZXQgcmVxdWlyZWQodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiBgJHt2YWx1ZX1gICE9PSAnZmFsc2UnO1xuICAgIH1cblxuICAgIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWQgPyB0aGlzLnZhbGlkYXRlUmVxdWlyZWQoY29udHJvbCkgOiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgdmFsaWRhdGVSZXF1aXJlZChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBpc0VtcHR5SW5wdXREYXRlVmFsdWUoY29udHJvbC52YWx1ZSkgPyB7IHJlcXVpcmVkOiB0cnVlIH0gOiBudWxsO1xuICAgIH1cbn1cblxuY29uc3QgUkFOR0VfUElDS0VSX1JFUVVJUkVEX1ZBTElEQVRPUjogU3RhdGljUHJvdmlkZXIgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVzZS1iZWZvcmUtZGVjbGFyZVxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlUGlja2VyUmVxdWlyZWRWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjpcbiAgICAgICAgJ1t0aHlSYW5nZVBpY2tlcl1bcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0sW3RoeVJhbmdlUGlja2VyXVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xdLFt0aHlSYW5nZVBpY2tlcl1bcmVxdWlyZWRdW25nTW9kZWxdLHRoeS1yYW5nZS1waWNrZXJbcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0sdGh5LXJhbmdlLXBpY2tlcltyZXF1aXJlZF1bZm9ybUNvbnRyb2xdLHRoeS1yYW5nZS1waWNrZXJbcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICBwcm92aWRlcnM6IFtSQU5HRV9QSUNLRVJfUkVRVUlSRURfVkFMSURBVE9SXVxufSlcbmV4cG9ydCBjbGFzcyBSYW5nZVBpY2tlclJlcXVpcmVkVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yIHtcbiAgICBwcml2YXRlIF9yZXF1aXJlZCE6IGJvb2xlYW47XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCByZXF1aXJlZCgpOiBib29sZWFuIHwgc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkO1xuICAgIH1cblxuICAgIHNldCByZXF1aXJlZCh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yZXF1aXJlZCA9IHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIGAke3ZhbHVlfWAgIT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZCA/IHRoaXMudmFsaWRhdGVSZXF1aXJlZChjb250cm9sKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVJlcXVpcmVkKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIGlzRW1wdHlJbnB1dFJhbmdlVmFsdWUoY29udHJvbC52YWx1ZSkgPyB7IHJlcXVpcmVkOiB0cnVlIH0gOiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eUlucHV0UmFuZ2VWYWx1ZSh2YWx1ZTogUmFuZ2VFbnRyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IChpbnN0YW5jZU9mUmFuZ2VFbnRyeSh2YWx1ZSkgJiYgKHZhbHVlLmJlZ2luID09IG51bGwgfHwgdmFsdWUuZW5kID09IG51bGwpKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eUlucHV0RGF0ZVZhbHVlKHZhbHVlOiBEYXRlRW50cnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAoaW5zdGFuY2VPZkRhdGVFbnRyeSh2YWx1ZSkgJiYgdmFsdWUuZGF0ZSA9PSBudWxsKTtcbn1cbiJdfQ==