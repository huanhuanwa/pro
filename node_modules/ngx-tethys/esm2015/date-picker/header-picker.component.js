import { ChangeDetectorRef, Component, Input } from '@angular/core';
import { AbstractPickerComponent } from './abstract-picker.component';
import { TinyDate } from 'ngx-tethys/util';
import * as ɵngcc0 from '@angular/core';
export class HeaderPickerComponent extends AbstractPickerComponent {
    constructor(cdr) {
        super(cdr);
    }
    ngOnInit() {
        super.ngOnInit();
        this.panelMode = this.endPanelMode;
        const allHeaderPanels = ['decade', 'year', 'month'];
        this.supportPanels = allHeaderPanels.slice(0, allHeaderPanels.indexOf(this.endPanelMode) + 1);
    }
    onPanelModeChange(mode) {
        if (this.supportPanels.indexOf(mode) > -1) {
            this.panelMode = mode;
        }
        else {
            // Since the default "click year" logic can be "year panel" -> "date panel", we need force to the end panel otherwise
            this.panelMode = this.endPanelMode;
        }
    }
    onChooseValue(mode, value) {
        if (this.endPanelMode === mode) {
            super.onValueChange(value);
            this.closeOverlay();
        }
    }
    onOpenChange(open) {
        if (!open) {
            this.cleanUp();
        }
        this.thyOpenChange.emit(open);
    }
    // Restore some initial props to let open as new in next time
    cleanUp() {
        this.panelMode = this.endPanelMode;
    }
}
HeaderPickerComponent.ɵfac = function HeaderPickerComponent_Factory(t) { return new (t || HeaderPickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
HeaderPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeaderPickerComponent, selectors: [["ng-component"]], inputs: { thyPlaceHolder: "thyPlaceHolder", thyDefaultValue: "thyDefaultValue", thyFormat: "thyFormat" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function HeaderPickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
HeaderPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
HeaderPickerComponent.propDecorators = {
    thyPlaceHolder: [{ type: Input }],
    thyDefaultValue: [{ type: Input }],
    thyFormat: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeaderPickerComponent, [{
        type: Component,
        args: [{
                template: ``
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { thyPlaceHolder: [{
            type: Input
        }], thyDefaultValue: [{
            type: Input
        }], thyFormat: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhZGVyLXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kYXRlLXBpY2tlci9oZWFkZXItcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBaUQsTUFBTSxlQUFlLENBQUM7QUFDbkgsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFdEUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDOztBQUszQyxNQUFNLE9BQU8scUJBQXNCLFNBQVEsdUJBQXVCO0FBQUcsSUFXakUsWUFBWSxHQUFzQjtBQUN0QyxRQUFRLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQixJQUFJLENBQUM7QUFDTCxJQUNJLFFBQVE7QUFBSyxRQUNULEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUN6QixRQUNRLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztBQUMzQyxRQUNRLE1BQU0sZUFBZSxHQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDekUsUUFBUSxJQUFJLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3RHLElBQUksQ0FBQztBQUNMLElBQ0ksaUJBQWlCLENBQUMsSUFBZTtBQUFJLFFBQ2pDLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDbkQsWUFBWSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztBQUNsQyxTQUFTO0FBQUMsYUFBSztBQUNmLFlBQVkscUhBQXFIO0FBQ2pJLFlBQVksSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQy9DLFNBQVM7QUFDVCxJQUFJLENBQUM7QUFDTCxJQUNJLGFBQWEsQ0FBQyxJQUF3QixFQUFFLEtBQXNCO0FBQUksUUFDOUQsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksRUFBRTtBQUN4QyxZQUFZLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkMsWUFDWSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDaEMsU0FBUztBQUNULElBQUksQ0FBQztBQUNMLElBQ0ksWUFBWSxDQUFDLElBQWE7QUFBSSxRQUMxQixJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ25CLFlBQVksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzNCLFNBQVM7QUFDVCxRQUFRLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RDLElBQUksQ0FBQztBQUNMLElBQ0ksNkRBQTZEO0FBQ2pFLElBQVksT0FBTztBQUFLLFFBQ2hCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztBQUMzQyxJQUFJLENBQUM7QUFDTDtpREF2REMsU0FBUyxTQUFDLGtCQUNQLFFBQVEsRUFBRSxFQUFFLGNBQ2Y7b1hBQ0k7QUFBQztBQUErQyxZQVI1QyxpQkFBaUI7QUFBRztBQUFHO0FBQXlDLDZCQVNwRSxLQUFLO0FBQUssOEJBRVYsS0FBSztBQUFLLHdCQUNWLEtBQUs7QUFBSTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vYWJzdHJhY3QtcGlja2VyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYW5lbE1vZGUsIENvbXBhdGlibGVWYWx1ZSB9IGZyb20gJy4vc3RhbmRhcmQtdHlwZXMnO1xuaW1wb3J0IHsgVGlueURhdGUgfSBmcm9tICduZ3gtdGV0aHlzL3V0aWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICB0ZW1wbGF0ZTogYGBcbn0pXG5leHBvcnQgY2xhc3MgSGVhZGVyUGlja2VyQ29tcG9uZW50IGV4dGVuZHMgQWJzdHJhY3RQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gICAgQElucHV0KCkgdGh5UGxhY2VIb2xkZXI6IHN0cmluZztcblxuICAgIEBJbnB1dCgpIHRoeURlZmF1bHRWYWx1ZTogVGlueURhdGU7XG4gICAgQElucHV0KCkgdGh5Rm9ybWF0OiBzdHJpbmc7XG5cbiAgICBlbmRQYW5lbE1vZGU6IFN1cHBvcnRIZWFkZXJQYW5lbDsgLy8gd291bGQgcmV3cml0ZSBieSBzdWIgY2xhc3NcbiAgICBwYW5lbE1vZGU6IFBhbmVsTW9kZTtcblxuICAgIHByaXZhdGUgc3VwcG9ydFBhbmVsczogUGFuZWxNb2RlW107XG5cbiAgICBjb25zdHJ1Y3RvcihjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHN1cGVyKGNkcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5wYW5lbE1vZGUgPSB0aGlzLmVuZFBhbmVsTW9kZTtcblxuICAgICAgICBjb25zdCBhbGxIZWFkZXJQYW5lbHM6IFBhbmVsTW9kZVtdID0gWydkZWNhZGUnLCAneWVhcicsICdtb250aCddO1xuICAgICAgICB0aGlzLnN1cHBvcnRQYW5lbHMgPSBhbGxIZWFkZXJQYW5lbHMuc2xpY2UoMCwgYWxsSGVhZGVyUGFuZWxzLmluZGV4T2YodGhpcy5lbmRQYW5lbE1vZGUpICsgMSk7XG4gICAgfVxuXG4gICAgb25QYW5lbE1vZGVDaGFuZ2UobW9kZTogUGFuZWxNb2RlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRQYW5lbHMuaW5kZXhPZihtb2RlKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsTW9kZSA9IG1vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgZGVmYXVsdCBcImNsaWNrIHllYXJcIiBsb2dpYyBjYW4gYmUgXCJ5ZWFyIHBhbmVsXCIgLT4gXCJkYXRlIHBhbmVsXCIsIHdlIG5lZWQgZm9yY2UgdG8gdGhlIGVuZCBwYW5lbCBvdGhlcndpc2VcbiAgICAgICAgICAgIHRoaXMucGFuZWxNb2RlID0gdGhpcy5lbmRQYW5lbE1vZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNob29zZVZhbHVlKG1vZGU6IFN1cHBvcnRIZWFkZXJQYW5lbCwgdmFsdWU6IENvbXBhdGlibGVWYWx1ZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5lbmRQYW5lbE1vZGUgPT09IG1vZGUpIHtcbiAgICAgICAgICAgIHN1cGVyLm9uVmFsdWVDaGFuZ2UodmFsdWUpO1xuXG4gICAgICAgICAgICB0aGlzLmNsb3NlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25PcGVuQ2hhbmdlKG9wZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoeU9wZW5DaGFuZ2UuZW1pdChvcGVuKTtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHNvbWUgaW5pdGlhbCBwcm9wcyB0byBsZXQgb3BlbiBhcyBuZXcgaW4gbmV4dCB0aW1lXG4gICAgcHJpdmF0ZSBjbGVhblVwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhbmVsTW9kZSA9IHRoaXMuZW5kUGFuZWxNb2RlO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgU3VwcG9ydEhlYWRlclBhbmVsID0gJ3llYXInIHwgJ21vbnRoJztcbiJdfQ==