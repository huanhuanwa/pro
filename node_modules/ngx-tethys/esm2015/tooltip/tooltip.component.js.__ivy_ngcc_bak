import { Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, HostBinding, ElementRef, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { thyTooltipAnimations } from './tooltip-animations';
import { UpdateHostClassService } from 'ngx-tethys/core';
import { coerceArray } from 'ngx-tethys/util';
export class ThyTooltipComponent {
    constructor(changeDetectorRef, updateHostClassService, elementRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.updateHostClassService = updateHostClassService;
        this.addTooltipContainerClass = true;
        this.onHide = new Subject();
        this.closeOnInteraction = false;
        this.visibility = 'initial';
        this.tooltipClasses = [];
        this.isTemplateRef = false;
        this.updateHostClassService.initializeElement(elementRef);
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this._content = value;
        this.isTemplateRef = value instanceof TemplateRef;
    }
    updateClasses() {
        let classes = [];
        if (this.tooltipClasses) {
            classes = classes.concat(this.tooltipClasses);
        }
        this.updateHostClassService.updateClass(classes);
    }
    ngOnInit() { }
    markForCheck() {
        this.changeDetectorRef.markForCheck();
    }
    isVisible() {
        return this.visibility === 'visible';
    }
    show(delay) {
        // Cancel the delayed hide if it is scheduled
        if (this.hideTimeoutId) {
            clearTimeout(this.hideTimeoutId);
            this.hideTimeoutId = null;
        }
        // Body interactions should cancel the tooltip if there is a delay in showing.
        this.closeOnInteraction = true;
        this.showTimeoutId = setTimeout(() => {
            this.visibility = 'visible';
            this.showTimeoutId = null;
            this.markForCheck();
        }, delay);
    }
    hide(delay) {
        // Cancel the delayed show if it is scheduled
        if (this.showTimeoutId) {
            clearTimeout(this.showTimeoutId);
            this.showTimeoutId = null;
        }
        this.hideTimeoutId = setTimeout(() => {
            this.visibility = 'hidden';
            this.hideTimeoutId = null;
            this.markForCheck();
        }, delay);
    }
    animationStart() {
        this.closeOnInteraction = false;
    }
    animationDone(event) {
        const toState = event.toState;
        if (toState === 'hidden' && !this.isVisible()) {
            this.onHide.next();
        }
        if (toState === 'visible' || toState === 'hidden') {
            this.closeOnInteraction = true;
        }
    }
    afterHidden() {
        return this.onHide.asObservable();
    }
    setTooltipClass(classes) {
        this.tooltipClasses = coerceArray(classes);
        this.updateClasses();
        // this.markForCheck();
    }
}
ThyTooltipComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-tooltip',
                template: "<div class=\"thy-tooltip-arrow\"></div>\n<div class=\"thy-tooltip-content\">\n  <ng-container *ngIf=\"isTemplateRef; else text\">\n    <ng-container *ngTemplateOutlet=\"content; context: { $implicit: data }\"></ng-container>\n  </ng-container>\n  <ng-template #text>\n    {{ content }}\n  </ng-template>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [thyTooltipAnimations.tooltipState],
                host: {
                    '[@state]': 'visibility',
                    '(@state.start)': 'animationStart()',
                    '(@state.done)': 'animationDone($event)'
                },
                providers: [UpdateHostClassService]
            },] }
];
ThyTooltipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: UpdateHostClassService },
    { type: ElementRef }
];
ThyTooltipComponent.propDecorators = {
    addTooltipContainerClass: [{ type: HostBinding, args: [`class.thy-tooltip`,] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbHRpcC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdG9vbHRpcC90b29sdGlwLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULGlCQUFpQixFQUNqQix1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFdBQVcsRUFDWCxVQUFVLEVBQ1YsV0FBVyxFQUVkLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJM0MsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDNUQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBZTlDLE1BQU0sT0FBTyxtQkFBbUI7SUF3QzVCLFlBQ1ksaUJBQW9DLEVBQ3BDLHNCQUE4QyxFQUN0RCxVQUFtQztRQUYzQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUF6Q3hCLDZCQUF3QixHQUFHLElBQUksQ0FBQztRQU1qRCxXQUFNLEdBQWtCLElBQUksT0FBTyxFQUFFLENBQUM7UUFFL0MsdUJBQWtCLEdBQUcsS0FBSyxDQUFDO1FBRW5DLGVBQVUsR0FBeUIsU0FBUyxDQUFDO1FBTTdDLG1CQUFjLEdBQWEsRUFBRSxDQUFDO1FBRTlCLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBMEJsQixJQUFJLENBQUMsc0JBQXNCLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQXpCRCxJQUFJLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVELElBQUksT0FBTyxDQUFDLEtBQXdDO1FBQ2hELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxZQUFZLFdBQVcsQ0FBQztJQUN0RCxDQUFDO0lBRU8sYUFBYTtRQUNqQixJQUFJLE9BQU8sR0FBYSxFQUFFLENBQUM7UUFFM0IsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3JCLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNqRDtRQUVELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQVVELFFBQVEsS0FBSSxDQUFDO0lBRWIsWUFBWTtRQUNSLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBRUQsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyxTQUFTLENBQUM7SUFDekMsQ0FBQztJQUVELElBQUksQ0FBQyxLQUFhO1FBQ2QsNkNBQTZDO1FBQzdDLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNwQixZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1NBQzdCO1FBRUQsOEVBQThFO1FBQzlFLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7UUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO1lBQzVCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1lBQzFCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4QixDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDZCxDQUFDO0lBRUQsSUFBSSxDQUFDLEtBQWE7UUFDZCw2Q0FBNkM7UUFDN0MsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3BCLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7U0FDN0I7UUFFRCxJQUFJLENBQUMsYUFBYSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUM7WUFDM0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDMUIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3hCLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNkLENBQUM7SUFFRCxjQUFjO1FBQ1YsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztJQUNwQyxDQUFDO0lBRUQsYUFBYSxDQUFDLEtBQXFCO1FBQy9CLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUErQixDQUFDO1FBQ3RELElBQUksT0FBTyxLQUFLLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtZQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3RCO1FBQ0QsSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLE9BQU8sS0FBSyxRQUFRLEVBQUU7WUFDL0MsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztTQUNsQztJQUNMLENBQUM7SUFFRCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RDLENBQUM7SUFFRCxlQUFlLENBQUMsT0FBMEI7UUFDdEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3JCLHVCQUF1QjtJQUMzQixDQUFDOzs7WUEzSEosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxhQUFhO2dCQUN2QixxVUFBdUM7Z0JBQ3ZDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsVUFBVSxFQUFFLENBQUMsb0JBQW9CLENBQUMsWUFBWSxDQUFDO2dCQUMvQyxJQUFJLEVBQUU7b0JBQ0YsVUFBVSxFQUFFLFlBQVk7b0JBQ3hCLGdCQUFnQixFQUFFLGtCQUFrQjtvQkFDcEMsZUFBZSxFQUFFLHVCQUF1QjtpQkFDM0M7Z0JBQ0QsU0FBUyxFQUFFLENBQUMsc0JBQXNCLENBQUM7YUFDdEM7OztZQTFCRyxpQkFBaUI7WUFXWixzQkFBc0I7WUFUM0IsVUFBVTs7O3VDQTBCVCxXQUFXLFNBQUMsbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgRWxlbWVudFJlZixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5pbXBvcnQgeyBUaHlUb29sdGlwVmlzaWJpbGl0eSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IHRoeVRvb2x0aXBBbmltYXRpb25zIH0gZnJvbSAnLi90b29sdGlwLWFuaW1hdGlvbnMnO1xuaW1wb3J0IHsgVXBkYXRlSG9zdENsYXNzU2VydmljZSB9IGZyb20gJ25neC10ZXRoeXMvY29yZSc7XG5pbXBvcnQgeyBjb2VyY2VBcnJheSB9IGZyb20gJ25neC10ZXRoeXMvdXRpbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndGh5LXRvb2x0aXAnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90b29sdGlwLmNvbXBvbmVudC5odG1sJyxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIGFuaW1hdGlvbnM6IFt0aHlUb29sdGlwQW5pbWF0aW9ucy50b29sdGlwU3RhdGVdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tAc3RhdGVdJzogJ3Zpc2liaWxpdHknLFxuICAgICAgICAnKEBzdGF0ZS5zdGFydCknOiAnYW5pbWF0aW9uU3RhcnQoKScsXG4gICAgICAgICcoQHN0YXRlLmRvbmUpJzogJ2FuaW1hdGlvbkRvbmUoJGV2ZW50KSdcbiAgICB9LFxuICAgIHByb3ZpZGVyczogW1VwZGF0ZUhvc3RDbGFzc1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFRoeVRvb2x0aXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIEBIb3N0QmluZGluZyhgY2xhc3MudGh5LXRvb2x0aXBgKSBhZGRUb29sdGlwQ29udGFpbmVyQ2xhc3MgPSB0cnVlO1xuXG4gICAgX2NvbnRlbnQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPEhUTUxFbGVtZW50PjtcblxuICAgIGRhdGE6IGFueTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgb25IaWRlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcblxuICAgIHByaXZhdGUgY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG5cbiAgICB2aXNpYmlsaXR5OiBUaHlUb29sdGlwVmlzaWJpbGl0eSA9ICdpbml0aWFsJztcblxuICAgIHNob3dUaW1lb3V0SWQ6IG51bWJlciB8IG51bGwgfCBhbnk7XG5cbiAgICBoaWRlVGltZW91dElkOiBudW1iZXIgfCBudWxsIHwgYW55O1xuXG4gICAgdG9vbHRpcENsYXNzZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICBpc1RlbXBsYXRlUmVmID0gZmFsc2U7XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodmFsdWU6IHN0cmluZyB8IFRlbXBsYXRlUmVmPEhUTUxFbGVtZW50Pikge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaXNUZW1wbGF0ZVJlZiA9IHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDbGFzc2VzKCkge1xuICAgICAgICBsZXQgY2xhc3Nlczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBpZiAodGhpcy50b29sdGlwQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KHRoaXMudG9vbHRpcENsYXNzZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVIb3N0Q2xhc3NTZXJ2aWNlLnVwZGF0ZUNsYXNzKGNsYXNzZXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJpdmF0ZSB1cGRhdGVIb3N0Q2xhc3NTZXJ2aWNlOiBVcGRhdGVIb3N0Q2xhc3NTZXJ2aWNlLFxuICAgICAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PlxuICAgICkge1xuICAgICAgICB0aGlzLnVwZGF0ZUhvc3RDbGFzc1NlcnZpY2UuaW5pdGlhbGl6ZUVsZW1lbnQoZWxlbWVudFJlZik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7fVxuXG4gICAgbWFya0ZvckNoZWNrKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIHNob3coZGVsYXk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlbGF5ZWQgaGlkZSBpZiBpdCBpcyBzY2hlZHVsZWRcbiAgICAgICAgaWYgKHRoaXMuaGlkZVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQm9keSBpbnRlcmFjdGlvbnMgc2hvdWxkIGNhbmNlbCB0aGUgdG9vbHRpcCBpZiB0aGVyZSBpcyBhIGRlbGF5IGluIHNob3dpbmcuXG4gICAgICAgIHRoaXMuY2xvc2VPbkludGVyYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaG93VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnNob3dUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cblxuICAgIGhpZGUoZGVsYXk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlbGF5ZWQgc2hvdyBpZiBpdCBpcyBzY2hlZHVsZWRcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnNob3dUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWRlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIHRoaXMuaGlkZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9TdGF0ZSA9IGV2ZW50LnRvU3RhdGUgYXMgVGh5VG9vbHRpcFZpc2liaWxpdHk7XG4gICAgICAgIGlmICh0b1N0YXRlID09PSAnaGlkZGVuJyAmJiAhdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5vbkhpZGUubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1N0YXRlID09PSAndmlzaWJsZScgfHwgdG9TdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VPbkludGVyYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVySGlkZGVuKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkhpZGUuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgc2V0VG9vbHRpcENsYXNzKGNsYXNzZXM6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcENsYXNzZXMgPSBjb2VyY2VBcnJheShjbGFzc2VzKTtcbiAgICAgICAgdGhpcy51cGRhdGVDbGFzc2VzKCk7XG4gICAgICAgIC8vIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuIl19