import { getFlexiblePositions, ThyAbstractOverlayService } from 'ngx-tethys/core';
import { isFunction } from 'ngx-tethys/util';
import { of, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';
import { coerceArray, coerceElement } from '@angular/cdk/coercion';
import { FlexibleConnectedPositionStrategy, Overlay, OverlayContainer, ViewportRuler } from '@angular/cdk/overlay';
import { Platform } from '@angular/cdk/platform';
import { ComponentPortal } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, Injector, NgZone, Optional } from '@angular/core';
import { ThyPopoverContainerComponent } from './popover-container.component';
import { ThyInternalPopoverRef, ThyPopoverRef } from './popover-ref';
import { THY_POPOVER_DEFAULT_CONFIG, THY_POPOVER_DEFAULT_CONFIG_VALUE, THY_POPOVER_SCROLL_STRATEGY, ThyPopoverConfig } from './popover.config';
import { popoverUpperOverlayOptions } from './popover.options';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "./popover.config";
import * as i3 from "@angular/cdk/scrolling";
import * as i4 from "@angular/common";
import * as i5 from "@angular/cdk/platform";
export class ThyPopover extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig, scrollStrategy, ngZone, _viewportRuler, _document, _platform, _overlayContainer) {
        super(popoverUpperOverlayOptions, overlay, injector, Object.assign(Object.assign({}, THY_POPOVER_DEFAULT_CONFIG_VALUE), defaultConfig), scrollStrategy);
        this.ngZone = ngZone;
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        this.ngUnsubscribe$ = new Subject();
        this.originInstancesMap = new Map();
    }
    buildPositionStrategy(config) {
        const origin = config.originPosition ? config.originPosition : config.origin;
        // const positionStrategy = this.overlay.position().flexibleConnectedTo(origin);
        const positionStrategy = new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        const positions = getFlexiblePositions(config.placement, config.offset, 'thy-popover');
        positionStrategy.withPositions(positions);
        positionStrategy.withGrowAfterOpen(true);
        positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {
            if (change.scrollableViewProperties.isOverlayClipped) {
                // After position changes occur and the overlay is clipped by
                // a parent scrollable then close the tooltip.
                this.ngZone.run(() => this.close());
            }
        });
        return positionStrategy;
    }
    buildScrollStrategy(config) {
        if (config.scrollStrategy) {
            return config.scrollStrategy;
        }
        else if (this.scrollStrategy && isFunction(this.scrollStrategy)) {
            return this.scrollStrategy();
        }
        else {
            this.overlay.scrollStrategies.block();
        }
    }
    buildOverlayConfig(config) {
        const positionStrategy = this.buildPositionStrategy(config);
        const overlayConfig = this.buildBaseOverlayConfig(config);
        overlayConfig.positionStrategy = positionStrategy;
        overlayConfig.scrollStrategy = this.buildScrollStrategy(config);
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThyPopoverConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThyPopoverContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalPopoverRef(overlayRef, containerInstance, config);
    }
    createInjector(config, popoverRef, popoverContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            { provide: ThyPopoverContainerComponent, useValue: popoverContainer },
            {
                provide: ThyPopoverRef,
                useValue: popoverRef
            }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    originElementAddActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.add(...coerceArray(config.originActiveClass));
        }
    }
    originElementRemoveActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.remove(...coerceArray(config.originActiveClass));
        }
    }
    ensureCloseClosest(origin) {
        let closeAndEnd = false;
        this.originInstancesMap.forEach((value, key) => {
            if (value.config.manualClosure) {
                if (key === origin) {
                    value.popoverRef.close();
                    closeAndEnd = true;
                }
            }
            else {
                if (key === origin) {
                    closeAndEnd = true;
                }
                value.popoverRef.close();
            }
        });
        return closeAndEnd;
    }
    open(componentOrTemplateRef, config) {
        const originElement = coerceElement(config.origin);
        // 默认关闭之前的弹出框
        // 1. 当之前的 Popover 设置 manualClosure 为 true 时, 弹出其他 Popover 时不自动关闭 manualClosure 为 true 的 Popover
        // 2. 当前的 Origin 对应的 Popover 已经弹出，不管 manualClosure 设置为何，直接关闭并返回
        if (this.ensureCloseClosest(originElement)) {
            return;
        }
        const popoverRef = this.openUpperOverlay(componentOrTemplateRef, config);
        config = popoverRef.containerInstance.config;
        popoverRef.afterClosed().subscribe(() => {
            this.originElementRemoveActiveClass(config);
            this.originInstancesMap.delete(originElement);
        });
        this.originElementAddActiveClass(config);
        this.originInstancesMap.set(originElement, {
            config,
            popoverRef
        });
        return popoverRef;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyPopover.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyPopover_Factory() { return new ThyPopover(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i2.THY_POPOVER_DEFAULT_CONFIG, 8), i0.ɵɵinject(i2.THY_POPOVER_SCROLL_STRATEGY), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.ViewportRuler), i0.ɵɵinject(i4.DOCUMENT, 8), i0.ɵɵinject(i5.Platform), i0.ɵɵinject(i1.OverlayContainer)); }, token: ThyPopover, providedIn: "root" });
ThyPopover.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ThyPopover.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThyPopoverConfig, decorators: [{ type: Optional }, { type: Inject, args: [THY_POPOVER_DEFAULT_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [THY_POPOVER_SCROLL_STRATEGY,] }] },
    { type: NgZone },
    { type: ViewportRuler },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: Platform },
    { type: OverlayContainer }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3BvcG92ZXIvcG9wb3Zlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2xGLE9BQU8sRUFBeUIsVUFBVSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEUsT0FBTyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ25FLE9BQU8sRUFFSCxpQ0FBaUMsRUFFakMsT0FBTyxFQUVQLGdCQUFnQixFQUloQixhQUFhLEVBQ2hCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ2pELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFjLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBYSxRQUFRLEVBQStCLE1BQU0sZUFBZSxDQUFDO0FBRW5JLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQzdFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUNILDBCQUEwQixFQUMxQixnQ0FBZ0MsRUFDaEMsMkJBQTJCLEVBQzNCLGdCQUFnQixFQUNuQixNQUFNLGtCQUFrQixDQUFDO0FB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Q0FBQztJQUVELFdBQVc7UUFDUCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQzs7OztZQTVMSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQXpCRyxPQUFPO1lBVzhCLFFBQVE7WUFRN0MsZ0JBQWdCLHVCQXlIWCxRQUFRLFlBQ1IsTUFBTSxTQUFDLDBCQUEwQjs0Q0FFakMsTUFBTSxTQUFDLDJCQUEyQjtZQXBJUSxNQUFNO1lBTHJELGFBQWE7NENBNklSLFFBQVEsWUFBSSxNQUFNLFNBQUMsUUFBUTtZQTNJM0IsUUFBUTtZQU5iLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZsZXhpYmxlUG9zaXRpb25zLCBUaHlBYnN0cmFjdE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSAnbmd4LXRldGh5cy9jb3JlJztcbmltcG9ydCB7IEZ1bmN0aW9uUHJvcCwgaGVscGVycywgaXNGdW5jdGlvbiB9IGZyb20gJ25neC10ZXRoeXMvdXRpbCc7XG5pbXBvcnQgeyBvZiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IGNvZXJjZUFycmF5LCBjb2VyY2VFbGVtZW50IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50VHlwZSxcbiAgICBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksXG4gICAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5T3JpZ2luLFxuICAgIE92ZXJsYXksXG4gICAgT3ZlcmxheUNvbmZpZyxcbiAgICBPdmVybGF5Q29udGFpbmVyLFxuICAgIE92ZXJsYXlSZWYsXG4gICAgUG9zaXRpb25TdHJhdGVneSxcbiAgICBTY3JvbGxTdHJhdGVneSxcbiAgICBWaWV3cG9ydFJ1bGVyXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3RvciwgTmdab25lLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBTdGF0aWNQcm92aWRlciwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVGh5UG9wb3ZlckNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFRoeUludGVybmFsUG9wb3ZlclJlZiwgVGh5UG9wb3ZlclJlZiB9IGZyb20gJy4vcG9wb3Zlci1yZWYnO1xuaW1wb3J0IHtcbiAgICBUSFlfUE9QT1ZFUl9ERUZBVUxUX0NPTkZJRyxcbiAgICBUSFlfUE9QT1ZFUl9ERUZBVUxUX0NPTkZJR19WQUxVRSxcbiAgICBUSFlfUE9QT1ZFUl9TQ1JPTExfU1RSQVRFR1ksXG4gICAgVGh5UG9wb3ZlckNvbmZpZ1xufSBmcm9tICcuL3BvcG92ZXIuY29uZmlnJztcbmltcG9ydCB7IHBvcG92ZXJVcHBlck92ZXJsYXlPcHRpb25zIH0gZnJvbSAnLi9wb3BvdmVyLm9wdGlvbnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRoeVBvcG92ZXIgZXh0ZW5kcyBUaHlBYnN0cmFjdE92ZXJsYXlTZXJ2aWNlPFRoeVBvcG92ZXJDb25maWcsIFRoeVBvcG92ZXJDb250YWluZXJDb21wb25lbnQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5nVW5zdWJzY3JpYmUkID0gbmV3IFN1YmplY3QoKTtcblxuICAgIHByaXZhdGUgb3JpZ2luSW5zdGFuY2VzTWFwID0gbmV3IE1hcDxcbiAgICAgICAgRWxlbWVudFJlZiB8IEhUTUxFbGVtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWc6IFRoeVBvcG92ZXJDb25maWc7XG4gICAgICAgICAgICBwb3BvdmVyUmVmOiBUaHlQb3BvdmVyUmVmPGFueSwgYW55PjtcbiAgICAgICAgfVxuICAgID4oKTtcblxuICAgIHByaXZhdGUgYnVpbGRQb3NpdGlvblN0cmF0ZWd5PFREYXRhPihjb25maWc6IFRoeVBvcG92ZXJDb25maWc8VERhdGE+KTogUG9zaXRpb25TdHJhdGVneSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5T3JpZ2luID0gY29uZmlnLm9yaWdpblBvc2l0aW9uID8gY29uZmlnLm9yaWdpblBvc2l0aW9uIDogY29uZmlnLm9yaWdpbjtcbiAgICAgICAgLy8gY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IHRoaXMub3ZlcmxheS5wb3NpdGlvbigpLmZsZXhpYmxlQ29ubmVjdGVkVG8ob3JpZ2luKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IG5ldyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3koXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyLFxuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybSxcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlDb250YWluZXJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gZ2V0RmxleGlibGVQb3NpdGlvbnMoY29uZmlnLnBsYWNlbWVudCwgY29uZmlnLm9mZnNldCwgJ3RoeS1wb3BvdmVyJyk7XG4gICAgICAgIHBvc2l0aW9uU3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICAgICAgICBwb3NpdGlvblN0cmF0ZWd5LndpdGhHcm93QWZ0ZXJPcGVuKHRydWUpO1xuICAgICAgICBwb3NpdGlvblN0cmF0ZWd5LnBvc2l0aW9uQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnNjcm9sbGFibGVWaWV3UHJvcGVydGllcy5pc092ZXJsYXlDbGlwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgcG9zaXRpb24gY2hhbmdlcyBvY2N1ciBhbmQgdGhlIG92ZXJsYXkgaXMgY2xpcHBlZCBieVxuICAgICAgICAgICAgICAgIC8vIGEgcGFyZW50IHNjcm9sbGFibGUgdGhlbiBjbG9zZSB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvblN0cmF0ZWd5O1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRTY3JvbGxTdHJhdGVneShjb25maWc6IFRoeVBvcG92ZXJDb25maWcpOiBTY3JvbGxTdHJhdGVneSB7XG4gICAgICAgIGlmIChjb25maWcuc2Nyb2xsU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc2Nyb2xsU3RyYXRlZ3k7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxTdHJhdGVneSAmJiBpc0Z1bmN0aW9uKHRoaXMuc2Nyb2xsU3RyYXRlZ3kpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxTdHJhdGVneSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBidWlsZE92ZXJsYXlDb25maWc8VERhdGE+KGNvbmZpZzogVGh5UG9wb3ZlckNvbmZpZzxURGF0YT4pOiBPdmVybGF5Q29uZmlnIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IHRoaXMuYnVpbGRQb3NpdGlvblN0cmF0ZWd5KGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLmJ1aWxkQmFzZU92ZXJsYXlDb25maWcoY29uZmlnKTtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5ID0gcG9zaXRpb25TdHJhdGVneTtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy5zY3JvbGxTdHJhdGVneSA9IHRoaXMuYnVpbGRTY3JvbGxTdHJhdGVneShjb25maWcpO1xuICAgICAgICByZXR1cm4gb3ZlcmxheUNvbmZpZztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXR0YWNoVXBwZXJPdmVybGF5Q29udGFpbmVyKG92ZXJsYXk6IE92ZXJsYXlSZWYsIGNvbmZpZzogVGh5UG9wb3ZlckNvbmZpZzxhbnk+KTogVGh5UG9wb3ZlckNvbnRhaW5lckNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0IHVzZXJJbmplY3RvciA9IGNvbmZpZyAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZiAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZi5pbmplY3RvcjtcbiAgICAgICAgY29uc3QgaW5qZWN0b3IgPSBJbmplY3Rvci5jcmVhdGUoe1xuICAgICAgICAgICAgcGFyZW50OiB1c2VySW5qZWN0b3IgfHwgdGhpcy5pbmplY3RvcixcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogVGh5UG9wb3ZlckNvbmZpZywgdXNlVmFsdWU6IGNvbmZpZyB9XVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChUaHlQb3BvdmVyQ29udGFpbmVyQ29tcG9uZW50LCBjb25maWcudmlld0NvbnRhaW5lclJlZiwgaW5qZWN0b3IpO1xuICAgICAgICBjb25zdCBjb250YWluZXJSZWYgPSBvdmVybGF5LmF0dGFjaDxUaHlQb3BvdmVyQ29udGFpbmVyQ29tcG9uZW50Pihjb250YWluZXJQb3J0YWwpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBjcmVhdGVVcHBlck92ZXJsYXlSZWY8VD4oXG4gICAgICAgIG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYsXG4gICAgICAgIGNvbnRhaW5lckluc3RhbmNlOiBUaHlQb3BvdmVyQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBjb25maWc6IFRoeVBvcG92ZXJDb25maWc8YW55PlxuICAgICk6IFRoeUludGVybmFsUG9wb3ZlclJlZjxUPiB7XG4gICAgICAgIHJldHVybiBuZXcgVGh5SW50ZXJuYWxQb3BvdmVyUmVmPFQ+KG92ZXJsYXlSZWYsIGNvbnRhaW5lckluc3RhbmNlLCBjb25maWcpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmplY3RvcjxUPihcbiAgICAgICAgY29uZmlnOiBUaHlQb3BvdmVyQ29uZmlnLFxuICAgICAgICBwb3BvdmVyUmVmOiBUaHlQb3BvdmVyUmVmPFQ+LFxuICAgICAgICBwb3BvdmVyQ29udGFpbmVyOiBUaHlQb3BvdmVyQ29udGFpbmVyQ29tcG9uZW50XG4gICAgKTogSW5qZWN0b3Ige1xuICAgICAgICBjb25zdCB1c2VySW5qZWN0b3IgPSBjb25maWcgJiYgY29uZmlnLnZpZXdDb250YWluZXJSZWYgJiYgY29uZmlnLnZpZXdDb250YWluZXJSZWYuaW5qZWN0b3I7XG5cbiAgICAgICAgY29uc3QgaW5qZWN0aW9uVG9rZW5zOiBTdGF0aWNQcm92aWRlcltdID0gW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBUaHlQb3BvdmVyQ29udGFpbmVyQ29tcG9uZW50LCB1c2VWYWx1ZTogcG9wb3ZlckNvbnRhaW5lciB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRoeVBvcG92ZXJSZWYsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHBvcG92ZXJSZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoY29uZmlnLmRpcmVjdGlvbiAmJiAoIXVzZXJJbmplY3RvciB8fCAhdXNlckluamVjdG9yLmdldDxEaXJlY3Rpb25hbGl0eSB8IG51bGw+KERpcmVjdGlvbmFsaXR5LCBudWxsKSkpIHtcbiAgICAgICAgICAgIGluamVjdGlvblRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBEaXJlY3Rpb25hbGl0eSxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29uZmlnLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBvZigpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSW5qZWN0b3IuY3JlYXRlKHsgcGFyZW50OiB1c2VySW5qZWN0b3IgfHwgdGhpcy5pbmplY3RvciwgcHJvdmlkZXJzOiBpbmplY3Rpb25Ub2tlbnMgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvcmlnaW5FbGVtZW50QWRkQWN0aXZlQ2xhc3MoY29uZmlnOiBUaHlQb3BvdmVyQ29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcub3JpZ2luQWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvZXJjZUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KGNvbmZpZy5vcmlnaW4pLmNsYXNzTGlzdC5hZGQoLi4uY29lcmNlQXJyYXkoY29uZmlnLm9yaWdpbkFjdGl2ZUNsYXNzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9yaWdpbkVsZW1lbnRSZW1vdmVBY3RpdmVDbGFzcyhjb25maWc6IFRoeVBvcG92ZXJDb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5vcmlnaW5BY3RpdmVDbGFzcykge1xuICAgICAgICAgICAgY29lcmNlRWxlbWVudDxIVE1MRWxlbWVudD4oY29uZmlnLm9yaWdpbikuY2xhc3NMaXN0LnJlbW92ZSguLi5jb2VyY2VBcnJheShjb25maWcub3JpZ2luQWN0aXZlQ2xhc3MpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBvdmVybGF5OiBPdmVybGF5LFxuICAgICAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgIEBPcHRpb25hbCgpXG4gICAgICAgIEBJbmplY3QoVEhZX1BPUE9WRVJfREVGQVVMVF9DT05GSUcpXG4gICAgICAgIGRlZmF1bHRDb25maWc6IFRoeVBvcG92ZXJDb25maWcsXG4gICAgICAgIEBJbmplY3QoVEhZX1BPUE9WRVJfU0NST0xMX1NUUkFURUdZKVxuICAgICAgICBzY3JvbGxTdHJhdGVneTogRnVuY3Rpb25Qcm9wPFNjcm9sbFN0cmF0ZWd5PixcbiAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJpdmF0ZSBfdmlld3BvcnRSdWxlcjogVmlld3BvcnRSdWxlcixcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgcHJpdmF0ZSBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgICAgICBwcml2YXRlIF9vdmVybGF5Q29udGFpbmVyOiBPdmVybGF5Q29udGFpbmVyXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgcG9wb3ZlclVwcGVyT3ZlcmxheU9wdGlvbnMsXG4gICAgICAgICAgICBvdmVybGF5LFxuICAgICAgICAgICAgaW5qZWN0b3IsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4uVEhZX1BPUE9WRVJfREVGQVVMVF9DT05GSUdfVkFMVUUsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbnN1cmVDbG9zZUNsb3Nlc3Qob3JpZ2luOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBsZXQgY2xvc2VBbmRFbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5JbnN0YW5jZXNNYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpZy5tYW51YWxDbG9zdXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gb3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnBvcG92ZXJSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VBbmRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gb3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQW5kRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUucG9wb3ZlclJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb3NlQW5kRW5kO1xuICAgIH1cblxuICAgIG9wZW48VCwgVERhdGEgPSBhbnksIFRSZXN1bHQgPSBhbnk+KFxuICAgICAgICBjb21wb25lbnRPclRlbXBsYXRlUmVmOiBDb21wb25lbnRUeXBlPFQ+IHwgVGVtcGxhdGVSZWY8VD4sXG4gICAgICAgIGNvbmZpZz86IFRoeVBvcG92ZXJDb25maWc8VERhdGE+XG4gICAgKTogVGh5UG9wb3ZlclJlZjxULCBUUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbkVsZW1lbnQgPSBjb2VyY2VFbGVtZW50KGNvbmZpZy5vcmlnaW4pO1xuICAgICAgICAvLyDpu5jorqTlhbPpl63kuYvliY3nmoTlvLnlh7rmoYZcbiAgICAgICAgLy8gMS4g5b2T5LmL5YmN55qEIFBvcG92ZXIg6K6+572uIG1hbnVhbENsb3N1cmUg5Li6IHRydWUg5pe2LCDlvLnlh7rlhbbku5YgUG9wb3ZlciDml7bkuI3oh6rliqjlhbPpl60gbWFudWFsQ2xvc3VyZSDkuLogdHJ1ZSDnmoQgUG9wb3ZlclxuICAgICAgICAvLyAyLiDlvZPliY3nmoQgT3JpZ2luIOWvueW6lOeahCBQb3BvdmVyIOW3sue7j+W8ueWHuu+8jOS4jeeuoSBtYW51YWxDbG9zdXJlIOiuvue9ruS4uuS9le+8jOebtOaOpeWFs+mXreW5tui/lOWbnlxuICAgICAgICBpZiAodGhpcy5lbnN1cmVDbG9zZUNsb3Nlc3Qob3JpZ2luRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcG92ZXJSZWYgPSB0aGlzLm9wZW5VcHBlck92ZXJsYXkoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgY29uZmlnKSBhcyBUaHlQb3BvdmVyUmVmPFQ+O1xuICAgICAgICBjb25maWcgPSBwb3BvdmVyUmVmLmNvbnRhaW5lckluc3RhbmNlLmNvbmZpZztcbiAgICAgICAgcG9wb3ZlclJlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbkVsZW1lbnRSZW1vdmVBY3RpdmVDbGFzcyhjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5JbnN0YW5jZXNNYXAuZGVsZXRlKG9yaWdpbkVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9yaWdpbkVsZW1lbnRBZGRBY3RpdmVDbGFzcyhjb25maWcpO1xuICAgICAgICB0aGlzLm9yaWdpbkluc3RhbmNlc01hcC5zZXQob3JpZ2luRWxlbWVudCwge1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgcG9wb3ZlclJlZlxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcG9wb3ZlclJlZjtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfVxufVxuIl19