(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/core/testing'), require('ngx-tethys/icon'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('ngx-tethys/testing', ['exports', '@angular/core', '@angular/core/testing', 'ngx-tethys/icon', '@angular/platform-browser'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-tethys'] = global['ngx-tethys'] || {}, global['ngx-tethys'].testing = {}), global.ng.core, global.ng.core.testing, global['ngx-tethys'].icon, global.ng.platformBrowser));
}(this, (function (exports, core, testing, icon, platformBrowser) { 'use strict';

    /**
     * Creates a browser MouseEvent with the specified options.
     * @docs-private
     */
    function createMouseEvent(type, clientX, clientY, button, modifiers, relatedTarget) {
        if (clientX === void 0) { clientX = 0; }
        if (clientY === void 0) { clientY = 0; }
        if (button === void 0) { button = 0; }
        if (modifiers === void 0) { modifiers = {}; }
        var event = document.createEvent('MouseEvent');
        var originalPreventDefault = event.preventDefault.bind(event);
        // Note: We cannot determine the position of the mouse event based on the screen
        // because the dimensions and position of the browser window are not available
        // To provide reasonable `screenX` and `screenY` coordinates, we simply use the
        // client coordinates as if the browser is opened in fullscreen.
        var screenX = clientX;
        var screenY = clientY;
        event.initMouseEvent(type, 
        /* canBubble */ true, 
        /* cancelable */ true, 
        /* view */ window, 
        /* detail */ 0, 
        /* screenX */ screenX, 
        /* screenY */ screenY, 
        /* clientX */ clientX, 
        /* clientY */ clientY, 
        /* ctrlKey */ !!modifiers.control, 
        /* altKey */ !!modifiers.alt, 
        /* shiftKey */ !!modifiers.shift, 
        /* metaKey */ !!modifiers.meta, 
        /* button */ button, 
        /* relatedTarget */ relatedTarget);
        // `initMouseEvent` doesn't allow us to pass the `buttons` and
        // defaults it to 0 which looks like a fake event.
        defineReadonlyEventProperty(event, 'buttons', 1);
        // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
        event.preventDefault = function () {
            defineReadonlyEventProperty(event, 'defaultPrevented', true);
            return originalPreventDefault();
        };
        return event;
    }
    /**
     * Creates a browser `PointerEvent` with the specified options. Pointer events
     * by default will appear as if they are the primary pointer of their type.
     * https://www.w3.org/TR/pointerevents2/#dom-pointerevent-isprimary.
     *
     * For example, if pointer events for a multi-touch interaction are created, the non-primary
     * pointer touches would need to be represented by non-primary pointer events.
     *
     * @docs-private
     */
    function createPointerEvent(type, clientX, clientY, options) {
        if (clientX === void 0) { clientX = 0; }
        if (clientY === void 0) { clientY = 0; }
        if (options === void 0) { options = { isPrimary: true }; }
        return new PointerEvent(type, Object.assign({ bubbles: true, cancelable: true, view: window, clientX: clientX,
            clientY: clientY }, options));
    }
    /**
     * Creates a browser TouchEvent with the specified pointer coordinates.
     * @docs-private
     */
    function createTouchEvent(type, pageX, pageY) {
        if (pageX === void 0) { pageX = 0; }
        if (pageY === void 0) { pageY = 0; }
        // In favor of creating events that work for most of the browsers, the event is created
        // as a basic UI Event. The necessary details for the event will be set manually.
        var event = document.createEvent('UIEvent');
        var touchDetails = { pageX: pageX, pageY: pageY };
        // TS3.6 removes the initUIEvent method and suggests porting to "new UIEvent()".
        event.initUIEvent(type, true, true, window, 0);
        // Most of the browsers don't have a "initTouchEvent" method that can be used to define
        // the touch details.
        defineReadonlyEventProperty(event, 'touches', [touchDetails]);
        defineReadonlyEventProperty(event, 'targetTouches', [touchDetails]);
        defineReadonlyEventProperty(event, 'changedTouches', [touchDetails]);
        return event;
    }
    /**
     * Creates a keyboard event with the specified key and modifiers.
     * @docs-private
     */
    function createKeyboardEvent(type, keyCode, key, modifiers) {
        if (keyCode === void 0) { keyCode = 0; }
        if (key === void 0) { key = ''; }
        if (modifiers === void 0) { modifiers = {}; }
        var event = document.createEvent('KeyboardEvent');
        var originalPreventDefault = event.preventDefault.bind(event);
        // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.
        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyEvent.
        if (event.initKeyEvent !== undefined) {
            event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);
        }
        else {
            // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string
            // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent
            var modifiersList = '';
            if (modifiers.control) {
                modifiersList += 'Control ';
            }
            if (modifiers.alt) {
                modifiersList += 'Alt ';
            }
            if (modifiers.shift) {
                modifiersList += 'Shift ';
            }
            if (modifiers.meta) {
                modifiersList += 'Meta ';
            }
            // TS3.6 removed the `initKeyboardEvent` method and suggested porting to
            // `new KeyboardEvent()` constructor. We cannot use that as we support IE11.
            // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent.
            event.initKeyboardEvent(type, true /* canBubble */, true /* cancelable */, window /* view */, 0 /* char */, key /* key */, 0 /* location */, modifiersList.trim() /* modifiersList */, false /* repeat */);
        }
        // Webkit Browsers don't set the keyCode when calling the init function.
        // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735
        defineReadonlyEventProperty(event, 'keyCode', keyCode);
        defineReadonlyEventProperty(event, 'key', key);
        defineReadonlyEventProperty(event, 'ctrlKey', !!modifiers.control);
        defineReadonlyEventProperty(event, 'altKey', !!modifiers.alt);
        defineReadonlyEventProperty(event, 'shiftKey', !!modifiers.shift);
        defineReadonlyEventProperty(event, 'metaKey', !!modifiers.meta);
        // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
        event.preventDefault = function () {
            defineReadonlyEventProperty(event, 'defaultPrevented', true);
            return originalPreventDefault();
        };
        return event;
    }
    /**
     * Creates a fake event object with any desired event type.
     * @docs-private
     */
    function createFakeEvent(type, canBubble, cancelable) {
        if (canBubble === void 0) { canBubble = false; }
        if (cancelable === void 0) { cancelable = true; }
        var event = document.createEvent('Event');
        event.initEvent(type, canBubble, cancelable);
        return event;
    }
    function createDragEvent(type, dataTransfer, canBubble, cancelable) {
        if (dataTransfer === void 0) { dataTransfer = null; }
        if (canBubble === void 0) { canBubble = false; }
        if (cancelable === void 0) { cancelable = true; }
        var event = document.createEvent('DragEvent');
        event.initEvent(type, canBubble, cancelable);
        defineReadonlyEventProperty(event, 'dataTransfer', dataTransfer);
        return event;
    }
    /**
     * Defines a readonly property on the given event object. Readonly properties on an event object
     * are always set as configurable as that matches default readonly properties for DOM event objects.
     */
    function defineReadonlyEventProperty(event, propertyName, value) {
        Object.defineProperty(event, propertyName, { get: function () { return value; }, configurable: true });
    }

    /**
     * Utility to dispatch any event on a Node.
     * @docs-private
     */
    function dispatchEvent(node, event) {
        node.dispatchEvent(event);
        return event;
    }
    /**
     * Shorthand to dispatch a fake event on a specified node.
     * @docs-private
     */
    function dispatchFakeEvent(node, type, canBubble) {
        return dispatchEvent(node, createFakeEvent(type, canBubble));
    }
    /**
     * Shorthand to dispatch a keyboard event with a specified key code and
     * optional modifiers.
     * @docs-private
     */
    function dispatchKeyboardEvent(node, type, keyCode, key, modifiers) {
        return dispatchEvent(node, createKeyboardEvent(type, keyCode, key, modifiers));
    }
    /**
     * Shorthand to dispatch a mouse event on the specified coordinates.
     * @docs-private
     */
    function dispatchMouseEvent(node, type, clientX, clientY, button, modifiers, relatedTarget) {
        if (clientX === void 0) { clientX = 0; }
        if (clientY === void 0) { clientY = 0; }
        return dispatchEvent(node, createMouseEvent(type, clientX, clientY, button, modifiers, relatedTarget));
    }
    /**
     * Shorthand to dispatch a pointer event on the specified coordinates.
     * @docs-private
     */
    function dispatchPointerEvent(node, type, clientX, clientY, options) {
        if (clientX === void 0) { clientX = 0; }
        if (clientY === void 0) { clientY = 0; }
        return dispatchEvent(node, createPointerEvent(type, clientX, clientY, options));
    }
    /**
     * Shorthand to dispatch a touch event on the specified coordinates.
     * @docs-private
     */
    function dispatchTouchEvent(node, type, x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        return dispatchEvent(node, createTouchEvent(type, x, y));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Patches an elements focus and blur methods to emit events consistently and predictably.
     * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,
     * while others won't fire them at all if the browser window is not focused.
     */
    function patchElementFocus(element) {
        element.focus = function () { return dispatchFakeEvent(element, 'focus'); };
        element.blur = function () { return dispatchFakeEvent(element, 'blur'); };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Focuses an input, sets its value and dispatches
     * the `input` event, simulating the user typing.
     * @param value Value to be set on the input.
     * @param element Element onto which to set the value.
     */
    function typeInElement(value, element) {
        element.focus();
        element.value = value;
        dispatchFakeEvent(element, 'input');
    }

    var bypassSanitizeProvider = {
        provide: core.Sanitizer,
        useValue: {
            sanitize: function (context, html) { return html; }
        }
    };
    var defaultInlineIconSet = "\n  <svg>\n    <defs>\n        <svg id=\"inbox\"></svg>\n        <svg id=\"close\"></svg>\n        <svg id=\"close-bold\"></svg>\n        <svg id=\"calendar-check\"></svg>\n        <svg id=\"calendar\"></svg>\n        <svg id=\"angle-down\"></svg>\n        <svg id=\"check\"></svg>\n        <svg id=\"application-fill\"></svg>\n        <svg id=\"angle-right\"></svg>\n        <svg id=\"minus-circle-fill\"></svg>\n        <svg id=\"check-circle-fill\"></svg>\n        <svg id=\"waring-fill\"></svg>\n        <svg id=\"close-circle-fill\"></svg>\n        <svg id=\"question-circle-fill\"></svg>\n        <svg id=\"more-bold\"></svg>\n        <svg id=\"filter\"></svg>\n        <svg id=\"close-circle-bold-fill\"></svg>\n    </defs>\n  </svg>\n";
    var defaultSvgHtml = "\n<svg viewBox=\"0 0 16 16\" id=\"close1\" xmlns=\"http://www.w3.org/2000/svg\">\n   <path d=\"M7.978 11.997l-.005.006L2.3 6.33l.83-.831 4.848 4.848L12.826 5.5l.83.83-5.673 5.673-.005-.006z\"/>\n</svg>";
    var injectDefaultSvgIconSet = function () {
        testing.inject([icon.ThyIconRegistry, platformBrowser.DomSanitizer], function (iconRegistry, domSanitizer) {
            iconRegistry.addSvgIconSetLiteral(domSanitizer.bypassSecurityTrustHtml(defaultInlineIconSet));
        })();
    };

    function removeFromArray(array, item) {
        var index = array.indexOf(item);
        if (index >= 0) {
            array.splice(index, 1);
        }
    }
    var FakeDataTransferItem = /** @class */ (function () {
        function FakeDataTransferItem(file, kind) {
            this.file = file;
            this.kind = kind;
        }
        FakeDataTransferItem.prototype.getAsFile = function () {
            return this.file;
        };
        FakeDataTransferItem.prototype.getAsString = function (callback) {
            throw new Error('Method not implemented.');
        };
        FakeDataTransferItem.prototype.webkitGetAsEntry = function () {
            return this.file;
        };
        return FakeDataTransferItem;
    }());
    var FakeDataTransfer = /** @class */ (function () {
        function FakeDataTransfer(files, items) {
            this.dataByFormat = {};
            this.dropEffect = 'none';
            this.effectAllowed = 'all';
            this.types = [];
            this.getData = function (dataFormat) {
                return this.dataByFormat[dataFormat];
            };
            this.setDragImage = function () {
                // don't do anything (the stub just makes sure there is no error thrown if someone tries to call the method)
            };
            this.files = files;
            this.items = items;
        }
        FakeDataTransfer.prototype.clearData = function (dataFormat) {
            if (dataFormat) {
                delete this.dataByFormat[dataFormat];
                removeFromArray(this.types, dataFormat);
            }
            else {
                this.dataByFormat = {};
                this.types = [];
            }
        };
        FakeDataTransfer.prototype.setData = function (dataFormat, data) {
            this.dataByFormat[dataFormat] = data;
            if (this.types.indexOf(dataFormat) < 0) {
                this.types.push(dataFormat);
            }
            return true;
        };
        return FakeDataTransfer;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.FakeDataTransfer = FakeDataTransfer;
    exports.FakeDataTransferItem = FakeDataTransferItem;
    exports.bypassSanitizeProvider = bypassSanitizeProvider;
    exports.createDragEvent = createDragEvent;
    exports.createFakeEvent = createFakeEvent;
    exports.createKeyboardEvent = createKeyboardEvent;
    exports.createMouseEvent = createMouseEvent;
    exports.createPointerEvent = createPointerEvent;
    exports.createTouchEvent = createTouchEvent;
    exports.defaultInlineIconSet = defaultInlineIconSet;
    exports.defaultSvgHtml = defaultSvgHtml;
    exports.dispatchEvent = dispatchEvent;
    exports.dispatchFakeEvent = dispatchFakeEvent;
    exports.dispatchKeyboardEvent = dispatchKeyboardEvent;
    exports.dispatchMouseEvent = dispatchMouseEvent;
    exports.dispatchPointerEvent = dispatchPointerEvent;
    exports.dispatchTouchEvent = dispatchTouchEvent;
    exports.injectDefaultSvgIconSet = injectDefaultSvgIconSet;
    exports.patchElementFocus = patchElementFocus;
    exports.typeInElement = typeInElement;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-tethys-testing.umd.js.map
