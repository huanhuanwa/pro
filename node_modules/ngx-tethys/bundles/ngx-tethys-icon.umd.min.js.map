{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","../../src/icon/icon-registry.ts","../../src/icon/config.ts","../../src/icon/icon.component.ts","../../src/icon/icon.module.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","SvgIconConfig","data","nodeName","this","svgElement","url","ThyIconRegistry","sanitizer","httpClient","document","defaultFontSetClass","internalIconMode","svgIconConfigs","Map","svgIconSetConfigs","inProgressUrlFetches","defineProperty","prototype","getIconNameNotFoundError","iconName","Error","getIconFailedToSanitizeLiteralError","literal","internalAddSvgIconSet","namespace","config","configNamespace","get","set","cloneSvg","svg","cloneNode","fetchUrl","safeUrl","_this","sanitize","SecurityContext","RESOURCE_URL","inProgressFetch","req","responseType","pipe","finalize","delete","share","toSvgElement","element","svgElementFromString","childNodes","length","nodeType","ELEMENT_NODE","appendChild","extractSvgIconFromIconSet","iconSet","iconSource","querySelector","iconElement","removeAttribute","toLowerCase","setSvgAttributes","extractIconWithNameFromIconSetConfigs","iconSetConfigs","foundIcon","str","div","createElement","innerHTML","setAttribute","createSvgElementForSingleIcon","responseText","loadSvgIconFromConfig","map","svgText","loadSvgIconSetFromConfig","of","getSvgFromConfig","tap","getSvgFromIconSetConfigs","name","namedIcon","iconSetFetchRequests","filter","iconSetConfig","catchError","err","console","message","forkJoin","internalAddSvgIconConfig","buildIconKey","splitIconName","parts","split","addSvgIconSetInNamespace","addSvgIconSet","addSvgIconSetLiteralInNamespace","sanitizedLiteral","HTML","addSvgIconSetLiteral","addSvgIconInNamespace","addSvgIcon","addSvgIconLiteral","addSvgIconLiteralInNamespace","getDefaultFontSetClass","getFontSetClassByAlias","fontSet","getSvgIcon","key","throwError","setIconMode","mode","Injectable","args","providedIn","DomSanitizer","HttpClient","Inject","DOCUMENT","printErrorWhenNotFound","getWhetherPrintErrorWhenIconNotFound","iconSuffixMap","fill","twotone","ThyIconComponent","updateHostClassService","render","elementRef","iconRegistry","className","isInitialized","iconType","initializeElement","nativeElement","ngOnInit","updateClasses","ngOnChanges","changes","setStyleRotate","coerceBooleanProperty","iconLegging","addClass","removeClass","_a","iconMode","buildIconNameByType","take","subscribe","setSvgElement","updateClass","fontSetClass","undefined","iconRotate","setStyle","clearSvgElement","styleTags","querySelectorAll","textContent","allPaths","forEach","child","index","getAttribute","includes","iconTwotoneColor","iconLinearGradient","setBaseUrl","clearTitleElement","layoutElement","childCount","removeChild","indexOf","suffix","style","cssText","replace","location","pathname","clipPath","remove","Component","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","providers","UpdateHostClassService","Renderer2","ElementRef","HostBinding","Input","NgModule","declarations","imports","CommonModule","FormsModule","HttpClientModule","exports"],"mappings":"iqCAyG6BA,OAAOC,gBAwBpBC,EAAOC,EAAGC,GACtB,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBK,EAAYC,EAA3BC,EAAIL,EAAEM,KAAKR,GAAOS,EAAK,GAC3B,IACI,WAAc,IAANR,GAAgBA,KAAM,MAAQI,EAAIE,EAAEG,QAAQC,MAAMF,EAAGG,KAAKP,EAAEQ,OAExE,MAAOC,GAASR,EAAI,CAAEQ,MAAOA,WAEzB,IACQT,IAAMA,EAAEM,OAAST,EAAIK,EAAU,SAAIL,EAAEM,KAAKD,WAExC,GAAID,EAAG,MAAMA,EAAEQ,OAE7B,OAAOL,EAoDcZ,OAAOC,OC5LhC,IAAAiB,EAII,SAAYC,GAGDA,EAAaC,SAChBC,KAAKC,WAAaH,EAElBE,KAAKE,IAAMJ,gBAqBnB,SAAAK,EAAoBC,EAAiCC,EAAkDC,GAAnFN,KAAAI,UAAAA,EAAiCJ,KAAAK,WAAAA,EAAkDL,KAAAM,SAAAA,EAV/FN,KAAAO,oBAAsB,UACtBP,KAAAQ,iBAA6B,MAC7BR,KAAAS,eAAiB,IAAIC,IACrBV,KAAAW,kBAAoB,IAAID,IACxBV,KAAAY,qBAAuB,IAAIF,WAEnC/B,OAAAkC,eAAWV,EAAAW,UAAA,WAAQ,KAAnB,WACI,OAAOd,KAAKQ,kDAKRL,EAAAW,UAAAC,yBAAA,SAAyBC,GAC7B,OAAOC,MAAM,sCAAsCD,EAAQ,MAGvDb,EAAAW,UAAAI,oCAAA,SAAoCC,GACxC,OAAOF,MACH,2HACsDE,EAAO,OAI7DhB,EAAAW,UAAAM,sBAAA,SAAsBC,EAAmBC,GAC7C,IAAMC,EAAkBvB,KAAKW,kBAAkBa,IAAIH,GAQnD,OANIE,EACAA,EAAgB7B,KAAK4B,GAErBtB,KAAKW,kBAAkBc,IAAIJ,EAAW,CAACC,IAGpCtB,MAGHG,EAAAW,UAAAY,SAAA,SAASC,GACb,OAAOA,EAAIC,WAAU,IAGjBzB,EAAAW,UAAAe,SAAA,SAASC,GAAT,IAAAC,EAAA/B,KACJ,GAAe,MAAX8B,EACA,MAAMb,MAAM,+BAA+Ba,EAAO,MAGtD,IAAM5B,EAAMF,KAAKI,UAAU4B,SAASC,EAAAA,gBAAgBC,aAAcJ,GAElE,IAAK5B,EACD,MAAM,IAAIe,MACN,yHACsDf,EAAG,MAOjE,IAAMiC,EAAkBnC,KAAKY,qBAAqBY,IAAItB,GAEtD,GAAIiC,EACA,OAAOA,EAIP,IAAMC,EAAMpC,KAAKK,WAAWmB,IAAItB,EAAK,CAAEmC,aAAc,SAAUC,KAC3DC,EAAAA,UAAS,WAAM,OAAAR,EAAKnB,qBAAqB4B,OAAOtC,MAChDuC,EAAAA,SAIJ,OADAzC,KAAKY,qBAAqBa,IAAIvB,EAAKkC,GAC5BA,GAIPjC,EAAAW,UAAA4B,aAAA,SAAaC,GAGjB,IAFA,IAAMhB,EAAM3B,KAAK4C,qBAAqB,eAE7BvD,EAAI,EAAGA,EAAIsD,EAAQE,WAAWC,OAAQzD,IACvCsD,EAAQE,WAAWxD,GAAG0D,WAAa/C,KAAKM,SAAS0C,cACjDrB,EAAIsB,YAAYN,EAAQE,WAAWxD,GAAGuC,WAAU,IAIxD,OAAOD,GAGHxB,EAAAW,UAAAoC,0BAAA,SAA0BC,EAAqBnC,GAGnD,IAAMoC,EAAaD,EAAQE,cAAc,QAAQrC,EAAQ,MAEzD,IAAKoC,EACD,OAAO,KAKX,IAAME,EAAcF,EAAWxB,WAAU,GAKzC,GAJA0B,EAAYC,gBAAgB,MAIe,QAAvCD,EAAYvD,SAASyD,cACrB,OAAOxD,KAAKyD,iBAAiBH,GAMjC,GAA2C,WAAvCA,EAAYvD,SAASyD,cACrB,OAAOxD,KAAKyD,iBAAiBzD,KAAK0C,aAAaY,IAQnD,IAAM3B,EAAM3B,KAAK4C,qBAAqB,eAItC,OAFAjB,EAAIsB,YAAYK,GAETtD,KAAKyD,iBAAiB9B,IAGzBxB,EAAAW,UAAA4C,sCAAA,SAAsC1C,EAAkB2C,GAE5D,IAAK,IAAItE,EAAIsE,EAAeb,OAAS,EAAGzD,GAAK,EAAGA,IAAK,CACjD,IAAMiC,EAASqC,EAAetE,GAC9B,GAAIiC,EAAOrB,WAAY,CACnB,IAAM2D,EAAY5D,KAAKkD,0BAA0B5B,EAAOrB,WAAYe,GACpE,GAAI4C,EACA,OAAOA,GAInB,OAAO,MAGHzD,EAAAW,UAAA8B,qBAAA,SAAqBiB,GACzB,IAAMC,EAAM9D,KAAKM,SAASyD,cAAc,OACxCD,EAAIE,UAAYH,EAChB,IAAMlC,EAAMmC,EAAIT,cAAc,OAE9B,IAAK1B,EACD,MAAMV,MAAM,uBAGhB,OAAOU,GAGHxB,EAAAW,UAAA2C,iBAAA,SAAiB9B,GAMrB,OALAA,EAAIsC,aAAa,MAAO,IACxBtC,EAAIsC,aAAa,SAAU,OAC3BtC,EAAIsC,aAAa,QAAS,OAC1BtC,EAAIsC,aAAa,sBAAuB,iBACxCtC,EAAIsC,aAAa,YAAa,SACvBtC,GAGHxB,EAAAW,UAAAoD,8BAAA,SAA8BC,GAClC,IAAMxC,EAAM3B,KAAK4C,qBAAqBuB,GAEtC,OADAnE,KAAKyD,iBAAiB9B,GACfA,GAGHxB,EAAAW,UAAAsD,sBAAA,SAAsB9C,GAAtB,IAAAS,EAAA/B,KACJ,OAAOA,KAAK6B,SAASP,EAAOpB,KAAKoC,KAAK+B,EAAAA,KAAI,SAAAC,GAAW,OAAAvC,EAAKmC,8BAA8BI,QAGpFnE,EAAAW,UAAAyD,yBAAA,SAAyBjD,GAAzB,IAAAS,EAAA/B,KAEJ,OAAIsB,EAAOrB,WACAuE,EAAAA,GAAGlD,EAAOrB,YAGdD,KAAK6B,SAASP,EAAOpB,KAAKoC,KAC7B+B,EAAAA,KAAI,SAAAC,GAOA,OAJKhD,EAAOrB,aACRqB,EAAOrB,WAAa8B,EAAKa,qBAAqB0B,IAG3ChD,EAAOrB,gBAKlBE,EAAAW,UAAA2D,iBAAA,SAAiBnD,GAAjB,IAAAS,EAAA/B,KACJ,OAAIsB,EAAOrB,WAEAuE,EAAAA,GAAGxE,KAAK0B,SAASJ,EAAOrB,aAGxBD,KAAKoE,sBAAsB9C,GAAQgB,KACtCoC,EAAAA,KAAI,SAAA/C,GAAO,OAACL,EAAOrB,WAAa0B,KAChC0C,EAAAA,KAAI,SAAA1C,GAAO,OAAAI,EAAKL,SAASC,QAK7BxB,EAAAW,UAAA6D,yBAAA,SAAyBC,EAAcjB,GAAvC,IAAA5B,EAAA/B,KAGE6E,EAAY7E,KAAK0D,sCAAsCkB,EAAMjB,GAEnE,GAAIkB,EAIA,OAAOL,EAAAA,GAAGK,GAKd,IAAMC,EAAwDnB,EACzDoB,QAAO,SAAAC,GAAiB,OAACA,EAAc/E,cACvCoE,KAAI,SAAAW,GACD,OAAOjD,EAAKwC,yBAAyBS,GAAe1C,KAChD2C,EAAAA,YACI,SAACC,GACG,IAAMhF,EAAM6B,EAAK3B,UAAU4B,SAASC,EAAAA,gBAAgBC,aAAc8C,EAAc9E,KAKhF,OADAiF,QAAQvF,MAAM,yBAAyBM,EAAG,YAAYgF,EAAIE,SACnDZ,EAAAA,GAAG,aAQ9B,OAAOa,EAAAA,SAASP,GAAsBxC,KAClC+B,EAAAA,KAAI,WACA,IAAMT,EAAY7B,EAAK2B,sCAAsCkB,EAAMjB,GAEnE,IAAKC,EACD,MAAM7B,EAAKhB,yBAAyB6D,GAGxC,OAAOhB,OAKXzD,EAAAW,UAAAwE,yBAAA,SAAyBjE,EAAmBL,EAAkBM,GAElE,OADAtB,KAAKS,eAAegB,IAAIzB,KAAKuF,aAAalE,EAAWL,GAAWM,GACzDtB,MAGXG,EAAAW,UAAAyE,aAAA,SAAalE,EAAmBuD,GAC5B,OAAOvD,EAAY,IAAMuD,GAG7BzE,EAAAW,UAAA0E,cAAA,SAAcxE,GACV,IAAKA,EACD,MAAO,CAAC,GAAI,IAEhB,IAAMyE,EAAQzE,EAAS0E,MAAM,KAC7B,OAAQD,EAAM3C,QACV,KAAK,EACD,MAAO,CAAC,GAAI2C,EAAM,IACtB,KAAK,EACD,OAAyBA,EAC7B,QACI,MAAMxE,MAAM,uBAAuBD,EAAQ,OAIvDb,EAAAW,UAAA6E,yBAAA,SAAyBtE,EAAmBnB,GACxC,OAAOF,KAAKoB,sBAAsBC,EAAW,IAAIxB,EAAcK,KAGnEC,EAAAW,UAAA8E,cAAA,SAAc1F,GACV,OAAOF,KAAK2F,yBAAyB,GAAIzF,IAG7CC,EAAAW,UAAA+E,gCAAA,SAAgCxE,EAAmBF,GAC/C,IAAM2E,EAAmB9F,KAAKI,UAAU4B,SAASC,EAAAA,gBAAgB8D,KAAM5E,GAEvE,IAAK2E,EACD,MAAM9F,KAAKkB,oCAAoCC,GAGnD,IAAMlB,EAAaD,KAAK4C,qBAAqBkD,GAC7C,OAAO9F,KAAKoB,sBAAsBC,EAAW,IAAIxB,EAAcI,KAGnEE,EAAAW,UAAAkF,qBAAA,SAAqB7E,GACjB,OAAOnB,KAAK6F,gCAAgC,GAAI1E,IASpDhB,EAAAW,UAAAmF,sBAAA,SAAsB5E,EAAmBL,EAAkBd,GACvD,OAAOF,KAAKsF,yBAAyBjE,EAAWL,EAAU,IAAInB,EAAcK,KAQhFC,EAAAW,UAAAoF,WAAA,SAAWlF,EAAkBd,GACzB,OAAOF,KAAKiG,sBAAsB,GAAIjF,EAAUd,IAQpDC,EAAAW,UAAAqF,kBAAA,SAAkBnF,EAAkBG,GAChC,OAAOnB,KAAKoG,6BAA6B,GAAIpF,EAAUG,IAS3DhB,EAAAW,UAAAsF,6BAAA,SAA6B/E,EAAmBL,EAAkBG,GAC9D,IAAM2E,EAAmB9F,KAAKI,UAAU4B,SAASC,EAAAA,gBAAgB8D,KAAM5E,GAEvE,IAAK2E,EACD,MAAM9F,KAAKkB,oCAAoCC,GAGnD,IAAMlB,EAAaD,KAAKkE,8BAA8B4B,GACtD,OAAO9F,KAAKsF,yBAAyBjE,EAAWL,EAAU,IAAInB,EAAcI,KAGhFE,EAAAW,UAAAuF,uBAAA,WACI,OAAOrG,KAAKO,qBAGhBJ,EAAAW,UAAAwF,uBAAA,SAAuBC,GACnB,OAAOA,GAGXpG,EAAAW,UAAA0F,WAAA,SAAW5B,EAAcvD,QAAA,IAAAA,IAAAA,EAAA,IAErB,IAAMoF,EAAMzG,KAAKuF,aAAalE,EAAWuD,GACnCtD,EAAStB,KAAKS,eAAee,IAAIiF,GAEvC,GAAInF,EACA,OAAOtB,KAAKyE,iBAAiBnD,GAIjC,IAAMqC,EAAiB3D,KAAKW,kBAAkBa,IAAIH,GAElD,OAAIsC,EACO3D,KAAK2E,yBAAyBC,EAAMjB,GAGxC+C,EAAAA,WAAW1G,KAAKe,yBAAyB0F,KAGpDtG,EAAAW,UAAA6F,YAAA,SAAYC,GACR5G,KAAKQ,iBAAmBoG,mMAnX/BC,EAAAA,WAAUC,KAAA,CAAC,CACRC,WAAY,oDAxBoBC,EAAAA,oBAE3BC,EAAAA,2CAmCyEC,EAAAA,OAAMJ,KAAA,CAACK,EAAAA,eCtCzF,IAAIC,GAAyB,WAMbC,IACZ,OAAOD,ECaX,IAAME,EAAgB,CAClBC,KAAM,OACNC,QAAS,mBA6BT,SAAAC,EACYC,EACAC,EACAC,EACAC,GAHA7H,KAAA0H,uBAAAA,EACA1H,KAAA2H,OAAAA,EACA3H,KAAA4H,WAAAA,EACA5H,KAAA6H,aAAAA,EAtBmB7H,KAAA8H,WAAY,EAEnC9H,KAAA+H,eAAgB,EAEF/H,KAAAgI,SAA2C,UAoB7DN,EAAuBO,kBAAkBL,EAAWM,sBAGxDT,EAAA3G,UAAAqH,SAAA,WACInI,KAAKoI,gBACLpI,KAAK+H,eAAgB,GAGzBN,EAAA3G,UAAAuH,YAAA,SAAYC,GACJtI,KAAK+H,gBACDO,EAAkB,UAAKA,EAAiB,SAAKA,EAA0B,kBAAKA,EAAkB,SAC9FtI,KAAKoI,gBACEE,EAAoB,YAC3BtI,KAAKuI,kBAGTD,EAAqB,cACjBE,EAAAA,sBAAsBxI,KAAKyI,aAC3BzI,KAAK0H,uBAAuBgB,SAAS,oBAErC1I,KAAK0H,uBAAuBiB,YAAY,sBAK5ClB,EAAA3G,UAAAsH,cAAA,WAAA,IAAArG,EAAA/B,KACE4I,EAAA/J,EAAwBmB,KAAK6H,aAAarC,cAAcxF,KAAKgB,UAAS,GAArEK,EAASuH,EAAA,GAAE5H,EAAQ4H,EAAA,GAC1B,GAAI5H,EACA,GAAmC,QAA/BhB,KAAK6H,aAAagB,SAClB7I,KAAK6H,aACArB,WAAWxG,KAAK8I,oBAAoB9H,GAAWK,GAC/CiB,KAAKyG,EAAAA,KAAK,IACVC,WACG,SAAArH,GAAO,OAAAI,EAAKkH,cAActH,MAC1B,SAAC/B,GACOyH,KACAlC,QAAQvF,MAAM,0BAA0BA,EAAMwF,YAI9DpF,KAAK0H,uBAAuBwB,YAAY,CACpC,YAAW7H,EAAY,IAAIA,EAAc,IAAE,IAAIrB,KAAK8I,oBAAoB9H,SAEzE,CACH,IAAMmI,EAAenJ,KAAKmD,QACpBnD,KAAK6H,aAAavB,uBAAuBtG,KAAKmD,SAC9CnD,KAAK6H,aAAaxB,yBACxBrG,KAAK0H,uBAAuBwB,YAAY,CAACC,EAAiBA,EAAY,IAAInJ,KAAKgB,aAKnFyG,EAAA3G,UAAAyH,eAAA,gBACoBa,IAApBpJ,KAAKqJ,YACLrJ,KAAK2H,OAAO2B,SAAStJ,KAAK4H,WAAWM,cAAc7E,cAAc,OAAQ,YAAa,UAAUrD,KAAKqJ,WAAU,SAM/G5B,EAAA3G,UAAAmI,cAAA,SAActH,GAAd,IAAAI,EAAA/B,KACJA,KAAKuJ,kBAOL,IAFA,IAAMC,EAAY7H,EAAI8H,iBAAiB,SAE9BpK,EAAI,EAAGA,EAAImK,EAAU1G,OAAQzD,IAClCmK,EAAUnK,GAAGqK,aAAe,IAGhC,GAAsB,YAAlB1J,KAAKgI,SAAwB,CAC7B,IAAM2B,EAAWhI,EAAI8H,iBAAiB,QAClCE,EAAS7G,OAAS,GAClB6G,EAASC,SAAQ,SAACC,EAAOC,GACjBD,EAAME,aAAa,MAAMC,SAAS,oBAClCH,EAAM5F,aAAa,OAAQlC,EAAKkI,qBAc5CjK,KAAKkK,qBACLlK,KAAKmK,WAAWxI,GAChB3B,KAAKoK,kBAAkBzI,IAG3B3B,KAAK4H,WAAWM,cAAcjF,YAAYtB,GAC1C3B,KAAKuI,kBAGDd,EAAA3G,UAAAyI,gBAAA,WAUJ,IATA,IAAMc,EAA6BrK,KAAK4H,WAAWM,cAC/CoC,EAAaD,EAAcxH,WAAWC,OAQnCwH,KAAc,CACjB,IAAMT,EAAQQ,EAAcxH,WAAWyH,GAIhB,IAAnBT,EAAM9G,UAAmD,QAAjC8G,EAAM9J,SAASyD,eACvC6G,EAAcE,YAAYV,KAO9BpC,EAAA3G,UAAAgI,oBAAA,SAAoB9H,GACxB,GAAIhB,KAAKgI,UAAY,CAAC,OAAQ,WAAWwC,QAAQxK,KAAKgI,WAAa,EAAG,CAClE,IAAMyC,EAASnD,EAActH,KAAKgI,UAClC,OAAOhH,EAASgJ,SAAS,IAAIS,GAAYzJ,EAAcA,EAAQ,IAAIyJ,EAEnE,OAAOzJ,GAUPyG,EAAA3G,UAAAqJ,WAAA,SAAWxI,GACOA,EAAI8H,iBAAiB,WAC7BG,SAAQ,SAAC7K,GACfA,EAAE2L,MAAMC,QAAQX,SAAS,SACzBjL,EAAE2L,MAAMnD,KAAOxI,EAAE2L,MAAMnD,KAAKqD,QAAQ,QAAS,QAAUC,SAASC,WAEhE/L,EAAE2L,MAAMC,QAAQX,SAAS,eACzBjL,EAAE2L,MAAMK,SAAWhM,EAAE2L,MAAMK,SAASH,QAAQ,QAAS,QAAUC,SAASC,eAK5ErD,EAAA3G,UAAAsJ,kBAAA,SAAkBzI,GACtBA,EAAI0B,cAAc,SAAS2H,mCAvLlCC,EAAAA,UAASnE,KAAA,CAAC,CACPoE,SAAU,WACVC,SAAU,4BACVC,gBAAiBC,EAAAA,wBAAwBC,OACzCC,cAAeC,EAAAA,kBAAkBC,KACjCC,UAAW,CAACC,EAAAA,qEAjBPA,EAAAA,8BALLC,EAAAA,iBAHAC,EAAAA,kBASK1L,wCAmBJ2L,EAAAA,YAAWhF,KAAA,CAAC,oCAIZiF,EAAAA,MAAKjF,KAAA,CAAC,yCAENiF,EAAAA,MAAKjF,KAAA,CAAC,qCAENiF,EAAAA,MAAKjF,KAAA,CAAC,mCAENiF,EAAAA,MAAKjF,KAAA,CAAC,kCAENiF,EAAAA,MAAKjF,KAAA,CAAC,mCAENiF,EAAAA,MAAKjF,KAAA,CAAC,8CAENiF,EAAAA,MAAKjF,KAAA,CAAC,kCCtCX,iCALCkF,EAAAA,SAAQlF,KAAA,CAAC,CACNmF,aAAc,CAACxE,GACfyE,QAAS,CAACC,EAAAA,aAAcC,EAAAA,YAAaC,EAAAA,kBACrCC,QAAS,CAAC7E,oJFPgC9H,GAC1CyH,EAAyBzH","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Injectable, SecurityContext, inject, Inject } from '@angular/core';\nimport { SafeResourceUrl, SafeHtml, DomSanitizer } from '@angular/platform-browser';\nimport { Observable, of, forkJoin, throwError } from 'rxjs';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { finalize, share, map, tap, catchError } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\n\nclass SvgIconConfig {\n    url: SafeResourceUrl | null;\n    svgElement: SVGElement | null;\n\n    constructor(data: SafeResourceUrl | SVGElement) {\n        // Note that we can't use `instanceof SVGElement` here,\n        // because it'll break during server-side rendering.\n        if (!!(data as any).nodeName) {\n            this.svgElement = data as SVGElement;\n        } else {\n            this.url = data as SafeResourceUrl;\n        }\n    }\n}\n\nexport type IconMode = 'font' | 'svg';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ThyIconRegistry {\n    private defaultFontSetClass = 'wt-icon';\n    private internalIconMode: IconMode = 'svg';\n    private svgIconConfigs = new Map<string, SvgIconConfig>();\n    private svgIconSetConfigs = new Map<string, SvgIconConfig[]>();\n    private inProgressUrlFetches = new Map<string, Observable<string>>();\n\n    public get iconMode() {\n        return this.internalIconMode;\n    }\n\n    constructor(private sanitizer: DomSanitizer, private httpClient: HttpClient, @Inject(DOCUMENT) private document: any) {}\n\n    private getIconNameNotFoundError(iconName: string): Error {\n        return Error(`Unable to find icon with the name \"${iconName}\"`);\n    }\n\n    private getIconFailedToSanitizeLiteralError(literal: SafeHtml): Error {\n        return Error(\n            `The literal provided to MatIconRegistry was not trusted as safe HTML by ` +\n                `Angular's DomSanitizer. Attempted literal was \"${literal}\".`\n        );\n    }\n\n    private internalAddSvgIconSet(namespace: string, config: SvgIconConfig): this {\n        const configNamespace = this.svgIconSetConfigs.get(namespace);\n\n        if (configNamespace) {\n            configNamespace.push(config);\n        } else {\n            this.svgIconSetConfigs.set(namespace, [config]);\n        }\n\n        return this;\n    }\n\n    private cloneSvg(svg: SVGElement): SVGElement {\n        return svg.cloneNode(true) as SVGElement;\n    }\n\n    private fetchUrl(safeUrl: SafeResourceUrl | null): Observable<string> {\n        if (safeUrl == null) {\n            throw Error(`Cannot fetch icon from URL \"${safeUrl}\".`);\n        }\n\n        const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n\n        if (!url) {\n            throw new Error(\n                `The URL provided to ThyIconRegistry was not trusted as a resource URL ` +\n                    `via Angular's DomSanitizer. Attempted URL was \"${url}\".`\n            );\n        }\n\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n        // already a request in progress for that URL. It's necessary to call share() on the\n        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n        const inProgressFetch = this.inProgressUrlFetches.get(url);\n\n        if (inProgressFetch) {\n            return inProgressFetch;\n        } else {\n            // TODO(jelbourn): for some reason, the `finalize` operator \"loses\" the generic type on the\n            // Observable. Figure out why and fix it.\n            const req = this.httpClient.get(url, { responseType: 'text' }).pipe(\n                finalize(() => this.inProgressUrlFetches.delete(url)),\n                share()\n            );\n\n            this.inProgressUrlFetches.set(url, req);\n            return req;\n        }\n    }\n\n    private toSvgElement(element: Element): SVGElement {\n        const svg = this.svgElementFromString('<svg></svg>');\n\n        for (let i = 0; i < element.childNodes.length; i++) {\n            if (element.childNodes[i].nodeType === this.document.ELEMENT_NODE) {\n                svg.appendChild(element.childNodes[i].cloneNode(true));\n            }\n        }\n\n        return svg;\n    }\n\n    private extractSvgIconFromIconSet(iconSet: SVGElement, iconName: string): SVGElement | null {\n        // Use the `id=\"iconName\"` syntax in order to escape special\n        // characters in the ID (versus using the #iconName syntax).\n        const iconSource = iconSet.querySelector(`[id=\"${iconName}\"]`);\n\n        if (!iconSource) {\n            return null;\n        }\n\n        // Clone the element and remove the ID to prevent multiple elements from being added\n        // to the page with the same ID.\n        const iconElement = iconSource.cloneNode(true) as Element;\n        iconElement.removeAttribute('id');\n\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n        // the content of a new <svg> node.\n        if (iconElement.nodeName.toLowerCase() === 'svg') {\n            return this.setSvgAttributes(iconElement as SVGElement);\n        }\n\n        // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note\n        // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\n        // tag is problematic on Firefox, because it needs to include the current page path.\n        if (iconElement.nodeName.toLowerCase() === 'symbol') {\n            return this.setSvgAttributes(this.toSvgElement(iconElement));\n        }\n\n        // createElement('SVG') doesn't work as expected; the DOM ends up with\n        // the correct nodes, but the SVG content doesn't render. Instead we\n        // have to create an empty SVG node using innerHTML and append its content.\n        // Elements created using DOMParser.parseFromString have the same problem.\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n        const svg = this.svgElementFromString('<svg></svg>');\n        // Clone the node so we don't remove it from the parent icon set element.\n        svg.appendChild(iconElement);\n\n        return this.setSvgAttributes(svg);\n    }\n\n    private extractIconWithNameFromIconSetConfigs(iconName: string, iconSetConfigs: SvgIconConfig[]): SVGElement | null {\n        // Iterate backwards, so icon sets added later have precedence.\n        for (let i = iconSetConfigs.length - 1; i >= 0; i--) {\n            const config = iconSetConfigs[i];\n            if (config.svgElement) {\n                const foundIcon = this.extractSvgIconFromIconSet(config.svgElement, iconName);\n                if (foundIcon) {\n                    return foundIcon;\n                }\n            }\n        }\n        return null;\n    }\n\n    private svgElementFromString(str: string): SVGElement {\n        const div = this.document.createElement('DIV');\n        div.innerHTML = str;\n        const svg = div.querySelector('svg') as SVGElement;\n\n        if (!svg) {\n            throw Error('<svg> tag not found');\n        }\n\n        return svg;\n    }\n\n    private setSvgAttributes(svg: SVGElement): SVGElement {\n        svg.setAttribute('fit', '');\n        svg.setAttribute('height', '1em');\n        svg.setAttribute('width', '1em');\n        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n        return svg;\n    }\n\n    private createSvgElementForSingleIcon(responseText: string): SVGElement {\n        const svg = this.svgElementFromString(responseText);\n        this.setSvgAttributes(svg);\n        return svg;\n    }\n\n    private loadSvgIconFromConfig(config: SvgIconConfig): Observable<SVGElement> {\n        return this.fetchUrl(config.url).pipe(map(svgText => this.createSvgElementForSingleIcon(svgText)));\n    }\n\n    private loadSvgIconSetFromConfig(config: SvgIconConfig): Observable<SVGElement> {\n        // If the SVG for this icon set has already been parsed, do nothing.\n        if (config.svgElement) {\n            return of(config.svgElement);\n        }\n\n        return this.fetchUrl(config.url).pipe(\n            map(svgText => {\n                // It is possible that the icon set was parsed and cached by an earlier request, so parsing\n                // only needs to occur if the cache is yet unset.\n                if (!config.svgElement) {\n                    config.svgElement = this.svgElementFromString(svgText);\n                }\n\n                return config.svgElement;\n            })\n        );\n    }\n\n    private getSvgFromConfig(config: SvgIconConfig): Observable<SVGElement> {\n        if (config.svgElement) {\n            // We already have the SVG element for this icon, return a copy.\n            return of(this.cloneSvg(config.svgElement));\n        } else {\n            // Fetch the icon from the config's URL, cache it, and return a copy.\n            return this.loadSvgIconFromConfig(config).pipe(\n                tap(svg => (config.svgElement = svg)),\n                map(svg => this.cloneSvg(svg))\n            );\n        }\n    }\n\n    private getSvgFromIconSetConfigs(name: string, iconSetConfigs: SvgIconConfig[]): Observable<SVGElement> {\n        // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n        // requested name.\n        const namedIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);\n\n        if (namedIcon) {\n            // We could cache namedIcon in svgIconConfigs, but since we have to make a copy every\n            // time anyway, there's probably not much advantage compared to just always extracting\n            // it from the icon set.\n            return of(namedIcon);\n        }\n\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n        // fetched, fetch them now and look for iconName in the results.\n        const iconSetFetchRequests: Observable<SVGElement | null>[] = iconSetConfigs\n            .filter(iconSetConfig => !iconSetConfig.svgElement)\n            .map(iconSetConfig => {\n                return this.loadSvgIconSetFromConfig(iconSetConfig).pipe(\n                    catchError(\n                        (err: HttpErrorResponse): Observable<SVGElement | null> => {\n                            const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);\n\n                            // Swallow errors fetching individual URLs so the\n                            // combined Observable won't necessarily fail.\n                            console.error(`Loading icon set URL: ${url} failed: ${err.message}`);\n                            return of(null);\n                        }\n                    )\n                );\n            });\n\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n        // cached SVG element (unless the request failed), and we can check again for the icon.\n        return forkJoin(iconSetFetchRequests).pipe(\n            map(() => {\n                const foundIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);\n\n                if (!foundIcon) {\n                    throw this.getIconNameNotFoundError(name);\n                }\n\n                return foundIcon;\n            })\n        );\n    }\n\n    private internalAddSvgIconConfig(namespace: string, iconName: string, config: SvgIconConfig): this {\n        this.svgIconConfigs.set(this.buildIconKey(namespace, iconName), config);\n        return this;\n    }\n\n    buildIconKey(namespace: string, name: string) {\n        return namespace + ':' + name;\n    }\n\n    splitIconName(iconName: string): [string, string] {\n        if (!iconName) {\n            return ['', ''];\n        }\n        const parts = iconName.split(':');\n        switch (parts.length) {\n            case 1:\n                return ['', parts[0]]; // Use default namespace.\n            case 2:\n                return <[string, string]>parts;\n            default:\n                throw Error(`Invalid icon name: \"${iconName}\"`);\n        }\n    }\n\n    addSvgIconSetInNamespace(namespace: string, url: SafeResourceUrl): this {\n        return this.internalAddSvgIconSet(namespace, new SvgIconConfig(url));\n    }\n\n    addSvgIconSet(url: SafeResourceUrl): this {\n        return this.addSvgIconSetInNamespace('', url);\n    }\n\n    addSvgIconSetLiteralInNamespace(namespace: string, literal: SafeHtml): this {\n        const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);\n\n        if (!sanitizedLiteral) {\n            throw this.getIconFailedToSanitizeLiteralError(literal);\n        }\n\n        const svgElement = this.svgElementFromString(sanitizedLiteral);\n        return this.internalAddSvgIconSet(namespace, new SvgIconConfig(svgElement));\n    }\n\n    addSvgIconSetLiteral(literal: SafeHtml): this {\n        return this.addSvgIconSetLiteralInNamespace('', literal);\n    }\n\n    /**\n     * Registers an icon by URL in the specified namespace.\n     * @param namespace Namespace in which the icon should be registered.\n     * @param iconName Name under which the icon should be registered.\n     * @param url\n     */\n    addSvgIconInNamespace(namespace: string, iconName: string, url: SafeResourceUrl): this {\n        return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(url));\n    }\n\n    /**\n     * Registers an icon by URL in the default namespace.\n     * @param iconName Name under which the icon should be registered.\n     * @param url\n     */\n    addSvgIcon(iconName: string, url: SafeResourceUrl): this {\n        return this.addSvgIconInNamespace('', iconName, url);\n    }\n\n    /**\n     * Registers an icon using an HTML string in the default namespace.\n     * @param iconName Name under which the icon should be registered.\n     * @param literal SVG source of the icon.\n     */\n    addSvgIconLiteral(iconName: string, literal: SafeHtml): this {\n        return this.addSvgIconLiteralInNamespace('', iconName, literal);\n    }\n\n    /**\n     * Registers an icon using an HTML string in the specified namespace.\n     * @param namespace Namespace in which the icon should be registered.\n     * @param iconName Name under which the icon should be registered.\n     * @param literal SVG source of the icon.\n     */\n    addSvgIconLiteralInNamespace(namespace: string, iconName: string, literal: SafeHtml): this {\n        const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);\n\n        if (!sanitizedLiteral) {\n            throw this.getIconFailedToSanitizeLiteralError(literal);\n        }\n\n        const svgElement = this.createSvgElementForSingleIcon(sanitizedLiteral);\n        return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));\n    }\n\n    getDefaultFontSetClass() {\n        return this.defaultFontSetClass;\n    }\n\n    getFontSetClassByAlias(fontSet: string) {\n        return fontSet;\n    }\n\n    getSvgIcon(name: string, namespace: string = ''): Observable<SVGElement> {\n        // Return (copy of) cached icon if possible.\n        const key = this.buildIconKey(namespace, name);\n        const config = this.svgIconConfigs.get(key);\n\n        if (config) {\n            return this.getSvgFromConfig(config);\n        }\n\n        // See if we have any icon sets registered for the namespace.\n        const iconSetConfigs = this.svgIconSetConfigs.get(namespace);\n\n        if (iconSetConfigs) {\n            return this.getSvgFromIconSetConfigs(name, iconSetConfigs);\n        }\n\n        return throwError(this.getIconNameNotFoundError(key));\n    }\n\n    setIconMode(mode: IconMode) {\n        this.internalIconMode = mode;\n    }\n}\n","let printErrorWhenNotFound = true;\n\nexport function setPrintErrorWhenIconNotFound(value: boolean) {\n    printErrorWhenNotFound = value;\n}\n\nexport function getWhetherPrintErrorWhenIconNotFound() {\n    return printErrorWhenNotFound;\n}\n","import {\n    Component,\n    OnInit,\n    ChangeDetectionStrategy,\n    ViewEncapsulation,\n    ElementRef,\n    Input,\n    HostBinding,\n    Renderer2,\n    SimpleChanges,\n    OnChanges\n} from '@angular/core';\n\nimport { UpdateHostClassService } from 'ngx-tethys/core';\nimport { ThyIconRegistry } from './icon-registry';\nimport { take, tap } from 'rxjs/operators';\nimport { Subject, noop, BehaviorSubject } from 'rxjs';\nimport { coerceArray, coerceBooleanProperty } from 'ngx-tethys/util';\nimport { getWhetherPrintErrorWhenIconNotFound } from './config';\n\nconst iconSuffixMap = {\n    fill: 'fill',\n    twotone: 'tt'\n};\n\n@Component({\n    selector: 'thy-icon',\n    template: '<ng-content></ng-content>',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None,\n    providers: [UpdateHostClassService]\n})\nexport class ThyIconComponent implements OnInit, OnChanges {\n    @HostBinding('class.thy-icon') className = true;\n\n    private isInitialized = false;\n\n    @Input('thyIconType') iconType: 'outline' | 'fill' | 'twotone' = 'outline';\n\n    @Input('thyTwotoneColor') iconTwotoneColor: string;\n\n    @Input('thyIconName') iconName: string;\n\n    @Input('thyIconRotate') iconRotate: number;\n\n    @Input('thyIconSet') iconSet: string;\n\n    @Input('thyIconLegging') iconLegging: boolean;\n\n    @Input('thyIconLinearGradient') iconLinearGradient: boolean;\n\n    constructor(\n        private updateHostClassService: UpdateHostClassService,\n        private render: Renderer2,\n        private elementRef: ElementRef,\n        private iconRegistry: ThyIconRegistry\n    ) {\n        updateHostClassService.initializeElement(elementRef.nativeElement);\n    }\n\n    ngOnInit() {\n        this.updateClasses();\n        this.isInitialized = true;\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (this.isInitialized) {\n            if (changes['iconName'] || changes['iconSet'] || changes['iconTwotoneColor'] || changes['iconType']) {\n                this.updateClasses();\n            } else if (changes['iconRotate']) {\n                this.setStyleRotate();\n            }\n        }\n        if (changes['iconLegging']) {\n            if (coerceBooleanProperty(this.iconLegging)) {\n                this.updateHostClassService.addClass('thy-icon-legging');\n            } else {\n                this.updateHostClassService.removeClass('thy-icon-legging');\n            }\n        }\n    }\n\n    private updateClasses() {\n        const [namespace, iconName] = this.iconRegistry.splitIconName(this.iconName);\n        if (iconName) {\n            if (this.iconRegistry.iconMode === 'svg') {\n                this.iconRegistry\n                    .getSvgIcon(this.buildIconNameByType(iconName), namespace)\n                    .pipe(take(1))\n                    .subscribe(\n                        svg => this.setSvgElement(svg),\n                        (error: Error) => {\n                            if (getWhetherPrintErrorWhenIconNotFound()) {\n                                console.error(`Error retrieving icon: ${error.message}`);\n                            }\n                        }\n                    );\n                this.updateHostClassService.updateClass([\n                    `thy-icon${namespace ? `-${namespace}` : ``}-${this.buildIconNameByType(iconName)}`\n                ]);\n            } else {\n                const fontSetClass = this.iconSet\n                    ? this.iconRegistry.getFontSetClassByAlias(this.iconSet)\n                    : this.iconRegistry.getDefaultFontSetClass();\n                this.updateHostClassService.updateClass([fontSetClass, `${fontSetClass}-${this.iconName}`]);\n            }\n        }\n    }\n\n    private setStyleRotate() {\n        if (this.iconRotate !== undefined) {\n            this.render.setStyle(this.elementRef.nativeElement.querySelector('svg'), 'transform', `rotate(${this.iconRotate}deg)`);\n        }\n    }\n\n    //#region svg element\n\n    private setSvgElement(svg: SVGElement) {\n        this.clearSvgElement();\n\n        // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.\n        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/\n        // Do this before inserting the element into the DOM, in order to avoid a style recalculation.\n        const styleTags = svg.querySelectorAll('style') as NodeListOf<HTMLStyleElement>;\n\n        for (let i = 0; i < styleTags.length; i++) {\n            styleTags[i].textContent += ' ';\n        }\n\n        if (this.iconType === 'twotone') {\n            const allPaths = svg.querySelectorAll('path');\n            if (allPaths.length > 1) {\n                allPaths.forEach((child, index: number) => {\n                    if (child.getAttribute('id').includes('secondary-color')) {\n                        child.setAttribute('fill', this.iconTwotoneColor);\n                    }\n                });\n            }\n        }\n\n        // Note: we do this fix here, rather than the icon registry, because the\n        // references have to point to the URL at the time that the icon was created.\n        // if (this._location) {\n        //     const path = this._location.getPathname();\n        //     this._previousPath = path;\n        //     this._cacheChildrenWithExternalReferences(svg);\n        //     this._prependPathToReferences(path);\n        // }\n        if (this.iconLinearGradient) {\n            this.setBaseUrl(svg);\n            this.clearTitleElement(svg);\n        }\n\n        this.elementRef.nativeElement.appendChild(svg);\n        this.setStyleRotate();\n    }\n\n    private clearSvgElement() {\n        const layoutElement: HTMLElement = this.elementRef.nativeElement;\n        let childCount = layoutElement.childNodes.length;\n\n        // if (this._elementsWithExternalReferences) {\n        //     this._elementsWithExternalReferences.clear();\n        // }\n\n        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n        // we can't use innerHTML, because IE will throw if the element has a data binding.\n        while (childCount--) {\n            const child = layoutElement.childNodes[childCount];\n\n            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                layoutElement.removeChild(child);\n            }\n        }\n    }\n\n    //#endregion\n\n    private buildIconNameByType(iconName: string) {\n        if (this.iconType && ['fill', 'twotone'].indexOf(this.iconType) >= 0) {\n            const suffix = iconSuffixMap[this.iconType];\n            return iconName.includes(`-${suffix}`) ? iconName : `${iconName}-${suffix}`;\n        } else {\n            return iconName;\n        }\n    }\n\n    /**\n     * Support Safari SVG LinearGradient.\n     *\n     *\n     * @param svg\n     */\n    private setBaseUrl(svg: SVGElement) {\n        const styleElements = svg.querySelectorAll('[style]');\n        styleElements.forEach((n: any) => {\n            if (n.style.cssText.includes('url')) {\n                n.style.fill = n.style.fill.replace('url(\"', 'url(\"' + location.pathname);\n            }\n            if (n.style.cssText.includes('clip-path')) {\n                n.style.clipPath = n.style.clipPath.replace('url(\"', 'url(\"' + location.pathname);\n            }\n        });\n    }\n\n    private clearTitleElement(svg: SVGElement) {\n        svg.querySelector('title').remove();\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { ThyIconComponent } from './icon.component';\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n    declarations: [ThyIconComponent],\n    imports: [CommonModule, FormsModule, HttpClientModule],\n    exports: [ThyIconComponent]\n})\nexport class ThyIconModule {}\n"]}