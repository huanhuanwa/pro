(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('ngx-tethys/util'), require('rxjs'), require('@angular/core'), require('@angular/common'), require('rxjs/operators'), require('@angular/animations'), require('@angular/cdk/overlay'), require('@angular/cdk/portal')) :
    typeof define === 'function' && define.amd ? define('ngx-tethys/core', ['@angular/core','exports', 'ngx-tethys/util', 'rxjs', '@angular/core', '@angular/common', 'rxjs/operators', '@angular/animations', '@angular/cdk/overlay', '@angular/cdk/portal'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,(global['ngx-tethys'] = global['ngx-tethys'] || {}, global['ngx-tethys'].core = {}), global['ngx-tethys'].util, global.rxjs, global.ng.core, global.ng.common, global.rxjs.operators, global.ng.animations, global.ng.cdk.overlay, global.ng.cdk.portal));
}(this, (function (ɵngcc0,exports, util, rxjs, i0, i1, operators, animations, overlay, portal) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    var AnonymousClass = /** @class */ (function () {
        function AnonymousClass() {
        }
        return AnonymousClass;
    }());
    var MixinBase = /** @class */ (function () {
        function MixinBase() {
        }
        return MixinBase;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /** Mixin to augment a directive with a `disable` property. */
    function mixinDisabled(base) {
        return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spread(args)) || this;
                _this._thyDisabled = false;
                return _this;
            }
            Object.defineProperty(class_1.prototype, "thyDisabled", {
                get: function () {
                    return this._thyDisabled;
                },
                set: function (value) {
                    this._thyDisabled = util.coerceBooleanProperty(value);
                },
                enumerable: false,
                configurable: true
            });
            return class_1;
        }(base));
    }

    /** Mixin to augment a directive with a `disableRipple` property. */
    function mixinUnsubscribe(base) {
        return /** @class */ (function (_super) {
            __extends(Mixin, _super);
            function Mixin() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spread(args)) || this;
                _this.ngUnsubscribe$ = new rxjs.Subject();
                return _this;
            }
            Mixin.prototype.ngUnsubscribeReinitialize = function () {
                this.ngUnsubscribe$.next();
                this.ngUnsubscribe$.complete();
                this.ngUnsubscribe$ = new rxjs.Subject();
            };
            Mixin.prototype.ngOnDestroy = function () {
                this.ngUnsubscribe$.next();
                this.ngUnsubscribe$.complete();
            };
            return Mixin;
        }(base));
    }

    function mixinLoadingDone(base) {
        return /** @class */ (function (_super) {
            __extends(Mixin, _super);
            function Mixin() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spread(args)) || this;
                _this.loadingDone = false;
                return _this;
            }
            Mixin.prototype.setLoadingDone = function (value) {
                this.loadingDone = value;
            };
            return Mixin;
        }(base));
    }

    function InputBoolean() {
        return propDecoratorFactory('InputBoolean', util.coerceBooleanProperty);
    }
    function InputCssPixel() {
        return propDecoratorFactory('InputCssPixel', util.coerceCssPixelValue);
    }
    function InputNumber() {
        return propDecoratorFactory('InputNumber', util.coerceNumberValue);
    }
    function propDecoratorFactory(name, fallback) {
        function propDecorator(target, propName, originalDescriptor) {
            var privatePropName = "$$__" + propName;
            if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
                console.warn("The prop \"" + privatePropName + "\" is already exist, it will be overrided by " + name + " decorator.");
            }
            Object.defineProperty(target, privatePropName, {
                configurable: true,
                writable: true
            });
            return {
                get: function () {
                    return originalDescriptor && originalDescriptor.get ? originalDescriptor.get.bind(this)() : this[privatePropName];
                },
                set: function (value) {
                    if (originalDescriptor && originalDescriptor.set) {
                        originalDescriptor.set.bind(this)(fallback(value));
                    }
                    this[privatePropName] = fallback(value);
                }
            };
        }
        return propDecorator;
    }

    var ScrollToService = /** @class */ (function () {
        function ScrollToService() {
        }
        ScrollToService._customScrollToElement = function (targetElement, containerElement) {
            var containerOffset = util.dom.getElementOffset(containerElement);
            var targetOffset = util.dom.getElementOffset(targetElement);
            // 选择项在顶部隐藏的偏移量 > 0 表示被顶部遮住隐藏
            var topOffset = containerOffset.top - targetOffset.top;
            // 选择项在底部隐藏的偏移量 > 0 表示被底部遮住隐藏
            var bottomOffset = targetOffset.top + targetOffset.height - (containerOffset.top + containerOffset.height);
            // 隐藏后滚动展示 targetElement 的偏移量，避免紧挨着头部或者底部
            var viewOffset = targetOffset.height;
            if (topOffset > 0) {
                containerElement.scrollTop = containerElement.scrollTop - topOffset - viewOffset;
            }
            else if (bottomOffset > 0) {
                containerElement.scrollTop = containerElement.scrollTop + bottomOffset + viewOffset;
            }
        };
        ScrollToService.scrollToElement = function (targetElement, containerElement) {
            if (targetElement) {
                this._customScrollToElement(targetElement, containerElement);
                // if (targetElement.scrollIntoView) {
                //     targetElement.scrollIntoView({
                //         behavior: 'smooth',
                //         block: 'center'
                //     });
                // } else {
                //     this._customScrollToElement(targetElement, containerElement);
                // }
            }
        };
        return ScrollToService;
    }());

    var DEFAULT_EVENT_TIME = 100;
    var ThyEventDispatcher = /** @class */ (function () {
        function ThyEventDispatcher(document, ngZone, eventName) {
            this.document = document;
            this.ngZone = ngZone;
            this.eventName = eventName;
            this._globalSubscription = null;
            this._event$ = new rxjs.Subject();
            this._subscriptionCount = 0;
        }
        ThyEventDispatcher.prototype._addGlobalListener = function () {
            var _this = this;
            this._globalSubscription = this.ngZone.runOutsideAngular(function () {
                return rxjs.fromEvent(_this.document, _this.eventName).subscribe(function (event) {
                    _this._event$.next(event);
                });
            });
        };
        ThyEventDispatcher.prototype._removeGlobalListener = function () {
            if (this._globalSubscription) {
                this._globalSubscription.unsubscribe();
                this._globalSubscription = null;
            }
        };
        Object.defineProperty(ThyEventDispatcher.prototype, "globalSubscription", {
            get: function () {
                return this._globalSubscription;
            },
            enumerable: false,
            configurable: true
        });
        ThyEventDispatcher.prototype.subscribe = function (auditTimeInMs) {
            var _this = this;
            if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_EVENT_TIME; }
            return new rxjs.Observable(function (observer) {
                if (!_this._globalSubscription) {
                    _this._addGlobalListener();
                }
                // In the case of a 0ms delay, use an observable without auditTime
                // since it does add a perceptible delay in processing overhead.
                var subscription = auditTimeInMs > 0 ? _this._event$.pipe(operators.auditTime(auditTimeInMs)).subscribe(observer) : _this._event$.subscribe(observer);
                _this._subscriptionCount++;
                return function () {
                    subscription.unsubscribe();
                    _this._subscriptionCount--;
                    if (!_this._subscriptionCount) {
                        _this._removeGlobalListener();
                    }
                };
            });
        };
        ThyEventDispatcher.prototype.ngOnDestroy = function () {
            this._removeGlobalListener();
            this._event$.complete();
        };
ThyEventDispatcher.ɵfac = function ThyEventDispatcher_Factory(t) { return new (t || ThyEventDispatcher)(ɵngcc0.ɵɵinject(undefined), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(String)); };
ThyEventDispatcher.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ThyEventDispatcher, factory: function (t) { return ThyEventDispatcher.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyEventDispatcher, [{
        type: i0.Injectable
    }], function () { return [{ type: undefined }, { type: ɵngcc0.NgZone }, { type: String }]; }, null); })();
        return ThyEventDispatcher;
    }());
    ThyEventDispatcher.ctorParameters = function () { return [
        { type: undefined },
        { type: i0.NgZone },
        { type: String }
    ]; };

    var DEFAULT_CLICKED_TIME = 100;
    var ThyClickDispatcher = /** @class */ (function (_super) {
        __extends(ThyClickDispatcher, _super);
        function ThyClickDispatcher(document, ngZone) {
            return _super.call(this, document, ngZone, 'click') || this;
        }
        ThyClickDispatcher.prototype.clicked = function (auditTimeInMs) {
            if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_CLICKED_TIME; }
            return this.subscribe(auditTimeInMs);
        };
ThyClickDispatcher.ɵfac = function ThyClickDispatcher_Factory(t) { return new (t || ThyClickDispatcher)(ɵngcc0.ɵɵinject(i1.DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyClickDispatcher, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: i0.Inject,
                args: [i1.DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
        return ThyClickDispatcher;
    }(ThyEventDispatcher));
    ThyClickDispatcher.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyClickDispatcher_Factory() { return new ThyClickDispatcher(i0__namespace.ɵɵinject(i1__namespace.DOCUMENT), i0__namespace.ɵɵinject(i0__namespace.NgZone)); }, token: ThyClickDispatcher, providedIn: "root" });
    ThyClickDispatcher.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: i0.NgZone }
    ]; };

    var DEFAULT_KEYDOWN_TIME = 100;
    var ThyKeyboardDispatcher = /** @class */ (function (_super) {
        __extends(ThyKeyboardDispatcher, _super);
        function ThyKeyboardDispatcher(document, ngZone) {
            return _super.call(this, document, ngZone, 'keydown') || this;
        }
        ThyKeyboardDispatcher.prototype.keydown = function (auditTimeInMs) {
            if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_KEYDOWN_TIME; }
            return this.subscribe(auditTimeInMs);
        };
ThyKeyboardDispatcher.ɵfac = function ThyKeyboardDispatcher_Factory(t) { return new (t || ThyKeyboardDispatcher)(ɵngcc0.ɵɵinject(i1.DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyKeyboardDispatcher, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: i0.Inject,
                args: [i1.DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
        return ThyKeyboardDispatcher;
    }(ThyEventDispatcher));
    ThyKeyboardDispatcher.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyKeyboardDispatcher_Factory() { return new ThyKeyboardDispatcher(i0__namespace.ɵɵinject(i1__namespace.DOCUMENT), i0__namespace.ɵɵinject(i0__namespace.NgZone)); }, token: ThyKeyboardDispatcher, providedIn: "root" });
    ThyKeyboardDispatcher.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },
        { type: i0.NgZone }
    ]; };

    var ThyClickPositioner = /** @class */ (function () {
        function ThyClickPositioner(clickDispatcher) {
            this.clickDispatcher = clickDispatcher;
            this.lastPosition = null;
            this.initialized = false;
        }
        Object.defineProperty(ThyClickPositioner.prototype, "lastClickPosition", {
            get: function () {
                return this.lastPosition;
            },
            enumerable: false,
            configurable: true
        });
        ThyClickPositioner.prototype.runTaskUseLastPosition = function (task) {
            var _this = this;
            setTimeout(function () {
                task(_this.lastClickPosition);
            });
        };
        ThyClickPositioner.prototype.initialize = function () {
            var _this = this;
            if (this.initialized) {
                return;
            }
            this.initialized = true;
            this.clickDispatcher.clicked(0).subscribe(function (event) {
                _this.lastPosition = { x: event.clientX, y: event.clientY };
            });
        };
ThyClickPositioner.ɵfac = function ThyClickPositioner_Factory(t) { return new (t || ThyClickPositioner)(ɵngcc0.ɵɵinject(ThyClickDispatcher)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyClickPositioner, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ThyClickDispatcher }]; }, null); })();
        return ThyClickPositioner;
    }());
    ThyClickPositioner.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyClickPositioner_Factory() { return new ThyClickPositioner(i0__namespace.ɵɵinject(ThyClickDispatcher)); }, token: ThyClickPositioner, providedIn: "root" });
    ThyClickPositioner.ctorParameters = function () { return [
        { type: ThyClickDispatcher }
    ]; };

    var availablePrefixes = ['moz', 'ms', 'webkit'];
    function requestAnimationFramePolyfill() {
        var lastTime = 0;
        return function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function () {
                callback(currTime + timeToCall);
            }, timeToCall); // setTimeout type warn
            lastTime = currTime + timeToCall;
            return id;
        };
    }
    function getRequestAnimationFrame() {
        if (typeof window === 'undefined') {
            return function () { return 0; };
        }
        if (window.requestAnimationFrame) {
            // https://github.com/vuejs/vue/issues/4465
            return window.requestAnimationFrame.bind(window);
        }
        var prefix = availablePrefixes.filter(function (key) { return key + "RequestAnimationFrame" in window; })[0];
        return prefix ? window[prefix + "RequestAnimationFrame"] : requestAnimationFramePolyfill();
    }
    function cancelRequestAnimationFrame(id) {
        if (typeof window === 'undefined') {
            return null;
        }
        if (window.cancelAnimationFrame) {
            return window.cancelAnimationFrame(id);
        }
        var prefix = availablePrefixes.filter(function (key) { return key + "CancelAnimationFrame" in window || key + "CancelRequestAnimationFrame" in window; })[0];
        return prefix
            ? (window[prefix + "CancelAnimationFrame"] || window[prefix + "CancelRequestAnimationFrame"])
                // @ts-ignore
                .call(this, id)
            : clearTimeout(id);
    }
    var reqAnimFrame = getRequestAnimationFrame();

    function easeInOutCubic(t, b, c, d) {
        var cc = c - b;
        var tt = t / (d / 2);
        if (tt < 1) {
            return (cc / 2) * tt * tt * tt + b;
        }
        else {
            return (cc / 2) * ((tt -= 2) * tt * tt + 2) + b;
        }
    }
    var ThyScrollService = /** @class */ (function () {
        function ThyScrollService(document) {
            this.document = document;
        }
        /** Set the position of the scroll bar of `element`. */
        ThyScrollService.prototype.setScrollTop = function (element, topValue) {
            if (topValue === void 0) { topValue = 0; }
            if (element === window) {
                this.document.body.scrollTop = topValue;
                this.document.documentElement.scrollTop = topValue;
            }
            else {
                element.scrollTop = topValue;
            }
        };
        /** Get the position of the scoll bar of `element`. */
        ThyScrollService.prototype.getScroll = function (element, top) {
            if (top === void 0) { top = true; }
            var target = element ? element : window;
            var prop = top ? 'pageYOffset' : 'pageXOffset';
            var method = top ? 'scrollTop' : 'scrollLeft';
            var isWindow = target === window;
            var ret = isWindow ? target[prop] : target[method];
            if (isWindow && typeof ret !== 'number') {
                ret = this.document.documentElement[method];
            }
            return ret;
        };
        /**
         * Scroll `element` to some position with animation.
         *
         * @param container container, `window` by default
         * @param topValue Scroll to `top`, 0 by default
         * @param easing Transition curve, `easeInOutCubic` by default
         * @param callback callback invoked when transition is done
         */
        ThyScrollService.prototype.scrollTo = function (container, topValue, easing, callback) {
            var _this = this;
            if (topValue === void 0) { topValue = 0; }
            var target = container ? container : window;
            var scrollTop = this.getScroll(target);
            var startTime = Date.now();
            var frameFunc = function () {
                var timestamp = Date.now();
                var time = timestamp - startTime;
                _this.setScrollTop(target, (easing || easeInOutCubic)(time, scrollTop, topValue, 450));
                if (time < 450) {
                    reqAnimFrame(frameFunc);
                }
                else {
                    if (callback) {
                        callback();
                    }
                }
            };
            reqAnimFrame(frameFunc);
        };
ThyScrollService.ɵfac = function ThyScrollService_Factory(t) { return new (t || ThyScrollService)(ɵngcc0.ɵɵinject(i1.DOCUMENT)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyScrollService, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: i0.Inject,
                args: [i1.DOCUMENT]
            }] }]; }, null); })();
        return ThyScrollService;
    }());
    ThyScrollService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyScrollService_Factory() { return new ThyScrollService(i0__namespace.ɵɵinject(i1__namespace.DOCUMENT)); }, token: ThyScrollService, providedIn: "root" });
    ThyScrollService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }
    ]; };

    var AnimationDuration = /** @class */ (function () {
        function AnimationDuration() {
        }
        return AnimationDuration;
    }());
    AnimationDuration.SLOW = '0.3s'; // Modal
    AnimationDuration.BASE = '0.2s';
    AnimationDuration.FAST = '0.1s'; // Tooltip
    var AnimationCurves = /** @class */ (function () {
        function AnimationCurves() {
        }
        return AnimationCurves;
    }());
    AnimationCurves.EASE_BASE_OUT = 'cubic-bezier(0.7, 0.3, 0.1, 1)';
    AnimationCurves.EASE_BASE_IN = 'cubic-bezier(0.9, 0, 0.3, 0.7)';
    AnimationCurves.EASE_OUT = 'cubic-bezier(0.215, 0.61, 0.355, 1)';
    AnimationCurves.EASE_IN = 'cubic-bezier(0.55, 0.055, 0.675, 0.19)';
    AnimationCurves.EASE_IN_OUT = 'cubic-bezier(0.645, 0.045, 0.355, 1)';
    AnimationCurves.EASE_OUT_BACK = 'cubic-bezier(0.12, 0.4, 0.29, 1.46)';
    AnimationCurves.EASE_IN_BACK = 'cubic-bezier(0.71, -0.46, 0.88, 0.6)';
    AnimationCurves.EASE_IN_OUT_BACK = 'cubic-bezier(0.71, -0.46, 0.29, 1.46)';
    AnimationCurves.EASE_OUT_CIRC = 'cubic-bezier(0.08, 0.82, 0.17, 1)';
    AnimationCurves.EASE_IN_CIRC = 'cubic-bezier(0.6, 0.04, 0.98, 0.34)';
    AnimationCurves.EASE_IN_OUT_CIRC = 'cubic-bezier(0.78, 0.14, 0.15, 0.86)';
    AnimationCurves.EASE_OUT_QUINT = 'cubic-bezier(0.23, 1, 0.32, 1)';
    AnimationCurves.EASE_IN_QUINT = 'cubic-bezier(0.755, 0.05, 0.855, 0.06)';
    AnimationCurves.EASE_IN_OUT_QUINT = 'cubic-bezier(0.86, 0, 0.07, 1)';

    var fadeMotion = animations.trigger('fadeMotion', [
        animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate("" + AnimationDuration.BASE, animations.style({ opacity: 1 }))]),
        animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate("" + AnimationDuration.BASE, animations.style({ opacity: 0 }))])
    ]);

    var POSITION_MAP = {
        top: {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom'
        },
        topCenter: {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom'
        },
        topLeft: {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom'
        },
        topRight: {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom'
        },
        right: {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center'
        },
        rightTop: {
            originX: 'end',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top'
        },
        rightBottom: {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom'
        },
        bottom: {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top'
        },
        bottomCenter: {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top'
        },
        bottomLeft: {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
        },
        bottomRight: {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top'
        },
        left: {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center'
        },
        leftTop: {
            originX: 'start',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'top'
        },
        leftBottom: {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'bottom'
        }
    };
    var EXPANDED_DROPDOWN_POSITIONS = [
        POSITION_MAP.bottomLeft,
        POSITION_MAP.bottomRight,
        POSITION_MAP.topLeft,
        POSITION_MAP.topRight
    ];

    var connectionFallbackPositionsMap = {
        top: ['topLeft', 'topRight', 'bottom', 'bottomLeft', 'bottomRight'],
        topLeft: ['top', 'topRight', 'bottomLeft', 'bottom', 'bottomRight'],
        topRight: ['top', 'topLeft', 'bottomRight', 'bottom', 'bottomLeft'],
        bottom: ['bottomLeft', 'bottomRight', 'top', 'topLeft', 'topRight'],
        bottomLeft: ['bottom', 'bottomRight', 'topLeft', 'top', 'topRight'],
        bottomRight: ['bottom', 'bottomLeft', 'topRight', 'top', 'topLeft'],
        left: ['leftTop', 'leftBottom', 'right', 'rightTop', 'rightBottom'],
        leftTop: ['left', 'leftBottom', 'rightTop', 'right', 'rightBottom'],
        leftBottom: ['left', 'leftTop', 'rightBottom', 'right', 'rightTop'],
        right: ['rightTop', 'rightBottom', 'left', 'leftTop', 'leftBottom'],
        rightTop: ['right', 'rightBottom', 'leftTop', 'left', 'leftBottom'],
        rightBottom: ['right', 'rightTop', 'leftBottom', 'left', 'leftTop']
    };
    function buildConnectedPositionOffset(placement, offset) {
        var connectedPositionOffset = {};
        if (placement.startsWith('top')) {
            connectedPositionOffset.offsetY = -offset;
        }
        else if (placement.startsWith('bottom')) {
            connectedPositionOffset.offsetY = offset;
        }
        else if (placement.startsWith('left')) {
            connectedPositionOffset.offsetX = -offset;
        }
        else if (placement.startsWith('right')) {
            connectedPositionOffset.offsetX = offset;
        }
        else {
            // do nothings
        }
        return connectedPositionOffset;
    }
    function buildConnectedPositionPair(placement, offset, panelClassPrefix) {
        var position = Object.assign(Object.assign({}, POSITION_MAP[placement]), (offset ? buildConnectedPositionOffset(placement, offset) : null));
        if (panelClassPrefix) {
            position.panelClass = panelClassPrefix + "-" + placement;
        }
        return position;
    }
    function getFallbackPlacements(placement) {
        return connectionFallbackPositionsMap[placement] || [];
    }
    /**
     * get flexible positions by placement, return placement position and it's fallback connection position
     * @example
     * getFlexiblePositions('top', 10, 'thy-overlay')
     * [{topPosition}, {topLeftPosition}, {topRightPosition}, {bottomPosition}, {bottomLeftPosition}, {bottomRightPosition},]
     * @returns [ConnectionPositionPair]
     */
    function getFlexiblePositions(placement, offset, panelClassPrefix) {
        var fallbackPlacements = getFallbackPlacements(placement);
        return __spread([placement], fallbackPlacements).map(function (placementName) {
            return buildConnectedPositionPair(placementName, offset, panelClassPrefix);
        });
    }
    function getPlacementByPosition(position) {
        var keyList = ['originX', 'originY', 'overlayX', 'overlayY'];
        var _loop_1 = function (placement) {
            if (keyList.every(function (key) { return position[key] === POSITION_MAP[placement][key]; })) {
                return { value: placement };
            }
        };
        for (var placement in POSITION_MAP) {
            var state_1 = _loop_1(placement);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }

    var ThyOverlayDirectiveBase = /** @class */ (function () {
        function ThyOverlayDirectiveBase(elementRef, platform, focusMonitor, ngZone) {
            this.initialized = false;
            /** Trigger Overlay */
            this._trigger = 'click';
            this.manualListeners = new Map();
            this.ngUnsubscribe$ = new rxjs.Subject();
            this.showDelay = 0;
            this.hideDelay = 0;
            this.touchendHideDelay = 0;
            this.disabled = false;
            this.elementRef = elementRef;
            this.platform = platform;
            this.focusMonitor = focusMonitor;
            this.ngZone = ngZone;
        }
        Object.defineProperty(ThyOverlayDirectiveBase.prototype, "trigger", {
            get: function () {
                return this._trigger;
            },
            set: function (value) {
                this._trigger = value;
                // Trigger reinitialize when trigger changed which can't contain first
                if (this.initialized) {
                    this.clearEventListeners();
                    this.initialize();
                }
            },
            enumerable: false,
            configurable: true
        });
        ThyOverlayDirectiveBase.prototype.clearEventListeners = function () {
            var _this = this;
            this.manualListeners.forEach(function (listener, event) {
                _this.elementRef.nativeElement.removeEventListener(event, listener);
            });
            this.manualListeners.clear();
            this.focusMonitor.stopMonitoring(this.elementRef);
        };
        ThyOverlayDirectiveBase.prototype.clearTimer = function () {
            if (this.showTimeoutId) {
                clearTimeout(this.showTimeoutId);
            }
            if (this.hideTimeoutId) {
                clearTimeout(this.hideTimeoutId);
            }
        };
        ThyOverlayDirectiveBase.prototype.initialize = function () {
            var _this = this;
            this.initialized = true;
            var element = this.elementRef.nativeElement;
            if (!this.platform.IOS && !this.platform.ANDROID) {
                if (this.trigger === 'hover') {
                    this.manualListeners
                        .set('mouseenter', function () {
                        _this.show();
                    })
                        .set('mouseleave', function (event) {
                        // element which mouse moved to
                        var overlayElement = _this.overlayRef && _this.overlayRef.overlayElement;
                        var toElement = event['toElement'] || event.relatedTarget;
                        // if element which moved to is in overlayElement, don't hide tooltip
                        if (overlayElement && overlayElement.contains && overlayElement.contains(toElement) && _this.tooltipPin) {
                            rxjs.fromEvent(overlayElement, 'mouseleave')
                                .pipe(operators.take(1))
                                .subscribe(function () {
                                _this.hide();
                            });
                        }
                        else {
                            _this.hide();
                        }
                        // if showDelay is too long and mouseleave immediately, overlayRef is not exist, we should clearTimeout
                        if (!_this.overlayRef) {
                            _this.clearTimer();
                        }
                    });
                }
                else if (this.trigger === 'focus') {
                    this.focusMonitor
                        .monitor(this.elementRef)
                        .pipe(operators.takeUntil(this.ngUnsubscribe$))
                        .subscribe(function (origin) {
                        // Note that the focus monitor runs outside the Angular zone.
                        if (!origin) {
                            _this.ngZone.run(function () { return _this.hide(0); });
                        }
                        else {
                            _this.ngZone.run(function () { return _this.show(); });
                        }
                    });
                    // this.manualListeners.set('focus', () => this.show());
                    // this.manualListeners.set('blur', () => this.hide());
                }
                else if (this.trigger === 'click') {
                    this.manualListeners.set('click', function () { return _this.show(); });
                }
                else {
                    throw new Error(this.trigger + " is not support, only support hover | focus | click");
                }
            }
            else {
                var touchendListener = function () {
                    // this.hide(this.touchendHideDelay);
                    setTimeout(function () {
                        _this.hide();
                    }, _this.touchendHideDelay);
                };
                // Reserve extensions for mobile in the future
                this.manualListeners
                    .set('touchend', touchendListener)
                    .set('touchcancel', touchendListener)
                    .set('touchstart', function () {
                    _this.show();
                });
            }
            this.manualListeners.forEach(function (listener, event) { return element.addEventListener(event, listener); });
        };
        ThyOverlayDirectiveBase.prototype.dispose = function () {
            this.ngUnsubscribe$.next();
            this.ngUnsubscribe$.complete();
            if (this.overlayRef) {
                this.overlayRef.dispose();
            }
            this.clearEventListeners();
            this.clearTimer();
        };
        return ThyOverlayDirectiveBase;
    }());

    var ThyAbstractOverlayRef = /** @class */ (function () {
        function ThyAbstractOverlayRef() {
        }
        return ThyAbstractOverlayRef;
    }());
    // Counter for unique overlay ids.
    var uniqueIdMap = {};
    function getUniqueId(name) {
        if (uniqueIdMap[name] !== undefined) {
            uniqueIdMap[name] = uniqueIdMap[name] + 1;
        }
        else {
            uniqueIdMap[name] = 0;
        }
        return uniqueIdMap[name];
    }
    var ThyAbstractInternalOverlayRef = /** @class */ (function (_super) {
        __extends(ThyAbstractInternalOverlayRef, _super);
        function ThyAbstractInternalOverlayRef(options, overlayRef, containerInstance, config) {
            var _this = _super.call(this) || this;
            _this.options = options;
            _this.overlayRef = overlayRef;
            _this.config = config;
            /** Whether the user is allowed to close the dialog. */
            _this.backdropClosable = _this.config.backdropClosable;
            /** Subject for notifying the user that the dialog has finished opening. */
            _this._afterOpened = new rxjs.Subject();
            /** Subject for notifying the user that the dialog has finished closing. */
            _this._afterClosed = new rxjs.Subject();
            /** Subject for notifying the user that the dialog has started closing. */
            _this._beforeClosed = new rxjs.Subject();
            _this.containerInstance = containerInstance;
            // Pass the id along to the container.
            _this.id = containerInstance.id = config.id ? config.id : "thy-" + _this.options.name + "-" + getUniqueId(_this.options.name);
            // Emit when opening animation completes
            containerInstance.animationOpeningDone.pipe(operators.take(1)).subscribe(function () {
                _this._afterOpened.next();
                if (_this.options.disposeWhenClose) {
                    _this._afterOpened.complete();
                }
            });
            // Dispose overlay when closing animation is complete
            containerInstance.animationClosingDone.pipe(operators.take(1)).subscribe(function () {
                if (_this.options.disposeWhenClose) {
                    _this.overlayRef.dispose();
                }
            });
            // Dispose overlay when container after destroy
            containerInstance.containerDestroy.pipe(operators.take(1)).subscribe(function () {
                if (_this.options.disposeWhenClose) {
                    // component element has not been deleted when the component destroy, so use promise wait for component element destroyed
                    Promise.resolve().then(function () {
                        _this.overlayRef.dispose();
                    });
                }
            });
            overlayRef.detachments().subscribe(function () {
                _this._beforeClosed.next(_this._result);
                _this._beforeClosed.complete();
                _this._afterClosed.next(_this._result);
                _this._afterClosed.complete();
                _this.componentInstance = null;
                _this.overlayRef.dispose();
            });
            // ESC close
            overlayRef
                .keydownEvents()
                .pipe(operators.filter(function (event) { return event.keyCode === util.ESCAPE && _this.backdropClosable; }))
                .subscribe(function () { return _this.close(); });
            return _this;
        }
        /** Fetches the position strategy object from the overlay ref. */
        ThyAbstractInternalOverlayRef.prototype.getPositionStrategy = function () {
            return this.overlayRef.getConfig().positionStrategy;
        };
        /**
         * Close the overlay.
         * @param overlayResult Optional result to return to the dialog opener.
         */
        ThyAbstractInternalOverlayRef.prototype.close = function (overlayResult) {
            this._result = overlayResult;
            // Transition the backdrop in parallel to the overlay.
            this._beforeClosed.next(overlayResult);
            if (this.options.disposeWhenClose) {
                this._beforeClosed.complete();
            }
            this.overlayRef.detachBackdrop();
            this.containerInstance.startExitAnimation();
        };
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        ThyAbstractInternalOverlayRef.prototype.afterOpened = function () {
            return this._afterOpened.asObservable();
        };
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         */
        ThyAbstractInternalOverlayRef.prototype.afterClosed = function () {
            return this._afterClosed.asObservable();
        };
        /**
         * Gets an observable that is notified when the dialog has started closing.
         */
        ThyAbstractInternalOverlayRef.prototype.beforeClosed = function () {
            return this._beforeClosed.asObservable();
        };
        /**
         * Gets an observable that emits when the overlay's backdrop has been clicked.
         */
        ThyAbstractInternalOverlayRef.prototype.backdropClick = function () {
            return this.overlayRef.backdropClick();
        };
        /**
         * Gets an observable that emits when keydown events are targeted on the overlay.
         */
        ThyAbstractInternalOverlayRef.prototype.keydownEvents = function () {
            return this.overlayRef.keydownEvents();
        };
        /** Get overlay ref */
        ThyAbstractInternalOverlayRef.prototype.getOverlayRef = function () {
            return this.overlayRef;
        };
        /**
         * Updates the overlay's position when is GlobalPositionStrategy
         * @param position New overlay position.
         */
        ThyAbstractInternalOverlayRef.prototype.updateGlobalPosition = function (position) {
            var strategy = this.getPositionStrategy();
            if (!(strategy instanceof overlay.GlobalPositionStrategy)) {
                throw new Error("current strategy is not GlobalPositionStrategy");
            }
            if (position && (position.left || position.right)) {
                position.left ? strategy.left(position.left) : strategy.right(position.right);
            }
            else {
                strategy.centerHorizontally();
            }
            if (position && (position.top || position.bottom)) {
                position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
            }
            else {
                strategy.centerVertically();
            }
            this.overlayRef.updatePosition();
            return this;
        };
        return ThyAbstractInternalOverlayRef;
    }(ThyAbstractOverlayRef));

    var ThyAbstractOverlayConfig = /** @class */ (function () {
        function ThyAbstractOverlayConfig() {
            /** Custom class for the overlay pane. */
            this.panelClass = '';
            /** Whether the dialog has a backdrop. */
            this.hasBackdrop = true;
            /** Custom class for the backdrop, */
            this.backdropClass = '';
            /** Whether the user can use escape or clicking on the backdrop to close the overlay. */
            this.backdropClosable = true;
            /** Width of the dialog. */
            this.width = '';
            /** Height of the dialog. */
            this.height = '';
            /** Data being injected into the child component. */
            this.initialState = null;
            /** ID of the element that describes the dialog. */
            this.ariaDescribedBy = null;
            /** Aria label to assign to the dialog element */
            this.ariaLabel = null;
            /** Whether the dialog should focus the first focusable element on open. */
            this.autoFocus = true;
            /**
             * Whether the dialog should restore focus to the
             * previously-focused element, after it's closed.
             */
            this.restoreFocus = true;
            /**
             * Whether the dialog should close when the user goes backwards/forwards in history.
             * Note that this usually doesn't include clicking on links (unless the user is using
             * the `HashLocationStrategy`).
             */
            this.closeOnNavigation = true;
        }
        return ThyAbstractOverlayConfig;
    }());

    function throwPopoverContentAlreadyAttachedError(name) {
        throw Error("Attempting to attach " + name + " content after content is already attached");
    }
    var ThyAbstractOverlayContainer = /** @class */ (function () {
        function ThyAbstractOverlayContainer(options, changeDetectorRef) {
            this.options = options;
            this.changeDetectorRef = changeDetectorRef;
            this.animationStateChanged = new i0.EventEmitter();
            this.containerDestroy = new rxjs.Subject();
        }
        /** Before detach content*/
        ThyAbstractOverlayContainer.prototype.beforeDetachPortal = function () { };
        /**
         * Attach a TemplatePortal as content to this overlay container.
         * @param portal Portal to be attached as the overlay content.
         */
        ThyAbstractOverlayContainer.prototype.attachTemplatePortal = function (portal) {
            if (this.portalOutlet.hasAttached()) {
                throwPopoverContentAlreadyAttachedError(this.options.name);
            }
            this.beforeAttachPortal();
            return this.portalOutlet.attachTemplatePortal(portal);
        };
        /**
         * Attach a ComponentPortal as content to this overlay container.
         * @param portal Portal to be attached as the overlay content.
         */
        ThyAbstractOverlayContainer.prototype.attachComponentPortal = function (portal) {
            if (this.portalOutlet.hasAttached()) {
                throwPopoverContentAlreadyAttachedError(this.options.name);
            }
            this.beforeAttachPortal();
            return this.portalOutlet.attachComponentPortal(portal);
        };
        ThyAbstractOverlayContainer.prototype.startExitAnimation = function () {
            if (this.options.animationEnabled) {
                this.animationState = 'exit';
            }
            else {
                // this.animationClosingDone.
            }
            this.beforeDetachPortal();
            // Mark the container for check so it can react if the
            // view container is using OnPush change detection.
            this.changeDetectorRef.markForCheck();
        };
        ThyAbstractOverlayContainer.prototype.destroy = function () {
            this.containerDestroy.next();
        };
        return ThyAbstractOverlayContainer;
    }());

    var ThyAbstractOverlayService = /** @class */ (function () {
        function ThyAbstractOverlayService(options, // component name, e.g: dialog | popover | slide
        overlay, injector, defaultConfig, scrollStrategy) {
            this.options = options;
            this.overlay = overlay;
            this.injector = injector;
            this.defaultConfig = defaultConfig;
            this.scrollStrategy = scrollStrategy;
            this.openedOverlays = [];
            this._afterAllClosed = new rxjs.Subject();
            this._afterOpened = new rxjs.Subject();
        }
        /** Attach component or template ref to overlay container */
        ThyAbstractOverlayService.prototype.attachUpperOverlayContent = function (componentOrTemplateRef, containerInstance, overlayRef, config) {
            var _a;
            // Create a reference to the dialog we're creating in order to give the user a handle
            // to modify and close it.
            var upperOverlayRef = this.createUpperOverlayRef(overlayRef, containerInstance, config);
            // When the backdrop is clicked, we want to close it.
            if (config.hasBackdrop) {
                overlayRef.backdropClick().subscribe(function () {
                    if (upperOverlayRef.backdropClosable) {
                        upperOverlayRef.close();
                    }
                });
            }
            if (componentOrTemplateRef instanceof i0.TemplateRef) {
                containerInstance.attachTemplatePortal(new portal.TemplatePortal(componentOrTemplateRef, null, (_a = {
                        $implicit: config.initialState
                    },
                    _a[this.options.name + "Ref"] = upperOverlayRef,
                    _a)));
            }
            else {
                var injector = this.createInjector(config, upperOverlayRef, containerInstance);
                var contentRef = containerInstance.attachComponentPortal(new portal.ComponentPortal(componentOrTemplateRef, undefined, injector));
                if (config.initialState) {
                    Object.assign(contentRef.instance, config.initialState);
                }
                upperOverlayRef.componentInstance = contentRef.instance;
            }
            return upperOverlayRef;
        };
        ThyAbstractOverlayService.prototype.removeOpenedOverlay = function (upperOverlayRef) {
            var index = this.openedOverlays.indexOf(upperOverlayRef);
            if (index > -1) {
                this.openedOverlays.splice(index, 1);
                if (!this.openedOverlays.length) {
                    this._afterAllClosed.next();
                }
            }
        };
        ThyAbstractOverlayService.prototype.getUpperOverlayById = function (id) {
            return this.openedOverlays.find(function (overlay) { return overlay.id === id; });
        };
        ThyAbstractOverlayService.prototype.buildBaseOverlayConfig = function (config, defaultPanelClass) {
            var overlayConfig = new overlay.OverlayConfig({
                positionStrategy: this.overlay.position().global(),
                hasBackdrop: config.hasBackdrop,
                direction: config.direction,
                width: config.width,
                height: config.height,
                minWidth: config.minWidth,
                minHeight: config.minHeight,
                maxWidth: config.maxWidth,
                maxHeight: config.maxHeight,
                disposeOnNavigation: config.closeOnNavigation
            });
            if (config.backdropClass) {
                overlayConfig.backdropClass = config.backdropClass;
            }
            overlayConfig.panelClass = util.concatArray(config.panelClass, defaultPanelClass);
            return overlayConfig;
        };
        ThyAbstractOverlayService.prototype.openUpperOverlay = function (componentOrTemplateRef, config) {
            var _this = this;
            config = Object.assign(Object.assign({}, this.defaultConfig), config);
            if (config.id && this.getUpperOverlayById(config.id)) {
                throw Error(this.options.name + " with id " + config.id + " exists already. The " + this.options.name + " id must be unique.");
            }
            var overlayConfig = this.buildOverlayConfig(config);
            var overlayRef = this.overlay.create(overlayConfig);
            var overlayContainer = this.attachUpperOverlayContainer(overlayRef, config);
            var upperOverlayRef = this.attachUpperOverlayContent(componentOrTemplateRef, overlayContainer, overlayRef, config);
            this.openedOverlays.push(upperOverlayRef);
            upperOverlayRef.afterClosed().subscribe(function () {
                _this.removeOpenedOverlay(upperOverlayRef);
            });
            this._afterOpened.next(upperOverlayRef);
            return upperOverlayRef;
        };
        ThyAbstractOverlayService.prototype.afterAllClosed = function () {
            return this._afterAllClosed;
        };
        ThyAbstractOverlayService.prototype.afterOpened = function () {
            return this._afterOpened;
        };
        ThyAbstractOverlayService.prototype.close = function (result) {
            if (this.openedOverlays.length > 0) {
                var lastOverlayRef = this.openedOverlays[this.openedOverlays.length - 1];
                if (lastOverlayRef) {
                    lastOverlayRef.close(result);
                }
            }
        };
        ThyAbstractOverlayService.prototype.closeAll = function () {
            var i = this.openedOverlays.length;
            while (i--) {
                // 不需要操作 openedOverlays, 因为 close 会触发 afterClosed 的订阅
                // 触发订阅后会自动从 openedOverlays 中移除
                this.openedOverlays[i].close();
            }
        };
        ThyAbstractOverlayService.prototype.dispose = function () {
            this.closeAll();
            this._afterAllClosed.complete();
            this._afterOpened.complete();
        };
        return ThyAbstractOverlayService;
    }());

    var UpdateHostClassService = /** @class */ (function () {
        function UpdateHostClassService(renderer) {
            this.renderer = renderer;
            this._classNames = [];
        }
        UpdateHostClassService.prototype.initializeElement = function (element) {
            if (element instanceof i0.ElementRef) {
                this._hostElement = element.nativeElement;
            }
            else {
                this._hostElement = element;
            }
            return this;
        };
        UpdateHostClassService.prototype.updateClass = function (classNames) {
            var _this = this;
            if (this._classNames) {
                this._classNames.forEach(function (className) {
                    if (classNames.indexOf(className) < 0) {
                        _this.removeClass(className);
                    }
                });
            }
            var newClasses = [];
            classNames.forEach(function (className) {
                if (className) {
                    newClasses.push(className);
                    if (_this._classNames.indexOf(className) < 0) {
                        _this.addClass(className);
                    }
                }
            });
            this._classNames = newClasses;
            return this;
        };
        UpdateHostClassService.prototype.updateClassByMap = function (classMap) {
            var newClasses = [];
            for (var key in classMap) {
                if (classMap.hasOwnProperty(key) && classMap[key]) {
                    newClasses.push(key);
                }
            }
            this.updateClass(newClasses);
        };
        UpdateHostClassService.prototype.addClass = function (className) {
            this.renderer.addClass(this._hostElement, className);
            return this;
        };
        UpdateHostClassService.prototype.removeClass = function (className) {
            this.renderer.removeClass(this._hostElement, className);
            return this;
        };
UpdateHostClassService.ɵfac = function UpdateHostClassService_Factory(t) { return new (t || UpdateHostClassService)(ɵngcc0.ɵɵinject(ɵngcc0.Renderer2)); };
UpdateHostClassService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UpdateHostClassService, factory: function (t) { return UpdateHostClassService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UpdateHostClassService, [{
        type: i0.Injectable
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();
        return UpdateHostClassService;
    }());
    UpdateHostClassService.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };

    var ThyTranslate = /** @class */ (function () {
        function ThyTranslate() {
        }
        ThyTranslate.prototype.instant = function (key, interpolateParams) {
            return key;
        };
        ThyTranslate.prototype.get = function (key, interpolateParams) {
            return new rxjs.Observable(function (observer) {
                observer.next(key);
            });
        };
ThyTranslate.ɵfac = function ThyTranslate_Factory(t) { return new (t || ThyTranslate)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTranslate, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
        return ThyTranslate;
    }());
    ThyTranslate.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyTranslate_Factory() { return new ThyTranslate(); }, token: ThyTranslate, providedIn: "root" });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AnimationCurves = AnimationCurves;
    exports.AnimationDuration = AnimationDuration;
    exports.AnonymousClass = AnonymousClass;
    exports.EXPANDED_DROPDOWN_POSITIONS = EXPANDED_DROPDOWN_POSITIONS;
    exports.InputBoolean = InputBoolean;
    exports.InputCssPixel = InputCssPixel;
    exports.InputNumber = InputNumber;
    exports.MixinBase = MixinBase;
    exports.POSITION_MAP = POSITION_MAP;
    exports.ScrollToService = ScrollToService;
    exports.ThyAbstractInternalOverlayRef = ThyAbstractInternalOverlayRef;
    exports.ThyAbstractOverlayConfig = ThyAbstractOverlayConfig;
    exports.ThyAbstractOverlayContainer = ThyAbstractOverlayContainer;
    exports.ThyAbstractOverlayRef = ThyAbstractOverlayRef;
    exports.ThyAbstractOverlayService = ThyAbstractOverlayService;
    exports.ThyClickDispatcher = ThyClickDispatcher;
    exports.ThyClickPositioner = ThyClickPositioner;
    exports.ThyEventDispatcher = ThyEventDispatcher;
    exports.ThyKeyboardDispatcher = ThyKeyboardDispatcher;
    exports.ThyOverlayDirectiveBase = ThyOverlayDirectiveBase;
    exports.ThyScrollService = ThyScrollService;
    exports.ThyTranslate = ThyTranslate;
    exports.UpdateHostClassService = UpdateHostClassService;
    exports.buildConnectedPositionOffset = buildConnectedPositionOffset;
    exports.buildConnectedPositionPair = buildConnectedPositionPair;
    exports.cancelRequestAnimationFrame = cancelRequestAnimationFrame;
    exports.fadeMotion = fadeMotion;
    exports.getFallbackPlacements = getFallbackPlacements;
    exports.getFlexiblePositions = getFlexiblePositions;
    exports.getPlacementByPosition = getPlacementByPosition;
    exports.mixinDisabled = mixinDisabled;
    exports.mixinLoadingDone = mixinLoadingDone;
    exports.mixinUnsubscribe = mixinUnsubscribe;
    exports.reqAnimFrame = reqAnimFrame;
    exports.throwPopoverContentAlreadyAttachedError = throwPopoverContentAlreadyAttachedError;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-tethys-core.umd.js.map