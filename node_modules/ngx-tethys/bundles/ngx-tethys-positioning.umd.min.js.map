{"version":3,"sources":["../../src/positioning/positioning.service.ts"],"names":["PlacementTypes","ThyPositioningService","ngZone","this","getHTMLElement","element","document","querySelector","ElementRef","nativeElement","prototype","autoPosition","targetElPosition","hostElPosition","targetElement","preferredPosition","left","offsetWidth","bottom","offsetHeight","window","innerHeight","top","right","innerWidth","getAllStyles","getComputedStyle","getStyle","prop","isStaticPositioned","offsetParent","offsetParentEl","documentElement","calculateTopBottomPosition","placementSecondary","attachElPosition","offset","documentClientHeight","clientHeight","height","calculateLeftRightPosition","documentClientWidth","clientWidth","width","autoAdaptTopBottom","placementPrimary","autoAdapt","originBottom","originTop","newTop","position","round","elPosition","parentOffset","bcRect","getBoundingClientRect","originLeft","originRight","clientTop","clientLeft","Math","elBcr","viewportOffset","pageYOffset","pageXOffset","elOffset","calculatePosition","hostElement","options","placement","appendToBody","split","targetElBCR","newPlacementPrimary","classList","add","setPosition","_this","attach","target","attachElement","setTimeout","runOutsideAngular","pos","isNumber","style","Injectable","args","providedIn","NgZone"],"mappings":"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","sourcesContent":["import { Injectable, ElementRef, NgZone } from '@angular/core';\nimport { isNumber } from 'ngx-tethys/util';\nimport { NewClientRect } from './client-rect';\n\nexport enum PlacementTypes {\n    left = 'left',\n    right = 'right',\n    center = 'center',\n    top = 'top',\n    bottom = 'bottom'\n}\n\nexport interface PositioningOptions {\n    /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n    attach?: HTMLElement | ElementRef | string;\n\n    /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n    target?: HTMLElement | ElementRef | string;\n\n    /**\n     * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n     * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n     * not yet supported:\n     * - vert-attachment can be any of 'top', 'middle', 'bottom'\n     * - horiz-attachment can be any of 'left', 'center', 'right'\n     */\n    placement?: string;\n\n    // 直接传入位置，不用根据 attachment target 计算，右击菜单使用\n    position?: {\n        top: number;\n        left: number;\n    };\n\n    /** A string of the form 'vert-offset horiz-offset'\n     * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n     */\n    offset?: number;\n\n    /** If true component will be attached to body */\n    appendToBody?: boolean;\n\n    /** If true component auto adapt top or bottom */\n    autoAdapt?: boolean;\n}\n\nexport const defaultPositioningOptions: PositioningOptions = {\n    offset: 10,\n    appendToBody: true,\n    placement: 'bottom center'\n};\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ThyPositioningService {\n    constructor(private ngZone: NgZone) {}\n\n    static getHTMLElement(element: HTMLElement | ElementRef | string): HTMLElement {\n        // it means that we got a selector\n        if (typeof element === 'string') {\n            return document.querySelector(element) as HTMLElement;\n        }\n\n        if (element instanceof ElementRef) {\n            return element.nativeElement;\n        }\n\n        return element as HTMLElement;\n    }\n\n    private autoPosition(targetElPosition: ClientRect, hostElPosition: ClientRect, targetElement: HTMLElement, preferredPosition?: string) {\n        if (\n            (!preferredPosition || preferredPosition === 'right') &&\n            targetElPosition.left + hostElPosition.left - targetElement.offsetWidth < 0\n        ) {\n            return 'right';\n        } else if (\n            (!preferredPosition || preferredPosition === 'top') &&\n            targetElPosition.bottom + hostElPosition.bottom + targetElement.offsetHeight > window.innerHeight\n        ) {\n            return 'top';\n        } else if (\n            (!preferredPosition || preferredPosition === 'bottom') &&\n            targetElPosition.top + hostElPosition.top - targetElement.offsetHeight < 0\n        ) {\n            return 'bottom';\n        } else if (\n            (!preferredPosition || preferredPosition === 'left') &&\n            targetElPosition.right + hostElPosition.right + targetElement.offsetWidth > window.innerWidth\n        ) {\n            return 'left';\n        }\n        return null;\n    }\n\n    private getAllStyles(element: HTMLElement) {\n        return window.getComputedStyle(element);\n    }\n\n    private getStyle(element: HTMLElement, prop: string): string {\n        return (this.getAllStyles(element) as any)[prop];\n    }\n\n    private isStaticPositioned(element: HTMLElement): boolean {\n        return (this.getStyle(element, 'position') || 'static') === 'static';\n    }\n\n    private offsetParent(element: HTMLElement): HTMLElement {\n        let offsetParentEl = <HTMLElement>element.offsetParent || document.documentElement;\n\n        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n            offsetParentEl = <HTMLElement>offsetParentEl.offsetParent;\n        }\n\n        return offsetParentEl || document.documentElement;\n    }\n\n    private calculateTopBottomPosition(\n        placementSecondary: string,\n        attachElPosition: ClientRect,\n        targetElPosition: ClientRect,\n        offset: number\n    ): ClientRect {\n        const documentClientHeight = document.documentElement.clientHeight;\n        if (placementSecondary === PlacementTypes.top) {\n            targetElPosition.top = attachElPosition.top;\n            targetElPosition.bottom = null;\n            // Top 对齐时，下面的内容超过了整个屏幕的高度, 为了可以看见全部内容，牺牲 Top 对齐\n            if (targetElPosition.top + targetElPosition.height > documentClientHeight) {\n                targetElPosition.top = documentClientHeight - targetElPosition.height;\n            }\n        } else if (placementSecondary === PlacementTypes.bottom) {\n            targetElPosition.bottom = documentClientHeight - attachElPosition.top - attachElPosition.height;\n            targetElPosition.top = null;\n            // Bottom 对齐时，上面的内容超过了整个屏幕的高度，为了可以看见全部内容，牺牲 Bottom 对齐\n            if (targetElPosition.bottom + targetElPosition.height > documentClientHeight) {\n                targetElPosition.bottom = documentClientHeight - targetElPosition.height;\n            }\n        } else {\n            targetElPosition.top = attachElPosition.top + attachElPosition.height / 2 - targetElPosition.height / 2;\n            // 顶部的内容被遮挡，牺牲居中，让顶部侧内容可见\n            if (targetElPosition.top < 0) {\n                targetElPosition.top = offset;\n            } else if (targetElPosition.top + targetElPosition.height > documentClientHeight) {\n                // 下面的内容被遮挡，牺牲居中，让下方的内容可见\n                targetElPosition.top = documentClientHeight - targetElPosition.height + offset;\n            }\n            targetElPosition.bottom = null;\n        }\n        return targetElPosition;\n    }\n\n    private calculateLeftRightPosition(\n        placementSecondary: string,\n        attachElPosition: ClientRect,\n        targetElPosition: ClientRect,\n        offset: number\n    ): ClientRect {\n        const documentClientWidth = document.documentElement.clientWidth;\n        if (placementSecondary === PlacementTypes.right) {\n            targetElPosition.right = document.documentElement.clientWidth - attachElPosition.left - attachElPosition.width;\n            targetElPosition.left = null;\n            // 右对齐时，左侧的内容超过了整个屏幕的宽度, 为了可以看见全部内容，牺牲右对齐\n            if (targetElPosition.right + targetElPosition.width > documentClientWidth) {\n                targetElPosition.right = documentClientWidth - targetElPosition.width - offset;\n            }\n        } else if (placementSecondary === PlacementTypes.left) {\n            targetElPosition.left = attachElPosition.left;\n            // 左对齐时，右侧的内容超过了整个屏幕的宽度, 为了可以看见全部内容，牺牲左对齐\n            if (targetElPosition.left + targetElPosition.width > documentClientWidth) {\n                targetElPosition.left = documentClientWidth - targetElPosition.width - offset;\n            }\n        } else {\n            targetElPosition.left = attachElPosition.left + attachElPosition.width / 2 - targetElPosition.width / 2;\n            // 左侧的内容被遮挡，牺牲居中，让左侧内容可见\n            if (targetElPosition.left < 0) {\n                targetElPosition.left = offset;\n            } else if (targetElPosition.left + targetElPosition.width > documentClientWidth) {\n                // 右侧的内容被遮挡，牺牲居中，让右侧内容可见\n                targetElPosition.left = documentClientWidth - targetElPosition.width - offset;\n            }\n        }\n        return targetElPosition;\n    }\n\n    private autoAdaptTopBottom(\n        placementPrimary: string,\n        hostElPosition: NewClientRect,\n        targetElPosition: NewClientRect,\n        offset: number,\n        autoAdapt = true\n    ) {\n        if (!autoAdapt) {\n            return;\n        }\n        const documentClientHeight = document.documentElement.clientHeight;\n        if (placementPrimary === 'top') {\n            // 如果 Top 空间不够，则自动适应 Bottom Top 和 Bottom 空间都不够，默认为可视区域Top\n            if (hostElPosition.originBottom - hostElPosition.height - targetElPosition.height < 0) {\n                if (documentClientHeight - hostElPosition.originBottom >= targetElPosition.height) {\n                    targetElPosition.bottom = targetElPosition.bottom - targetElPosition.height - hostElPosition.height - offset;\n                } else {\n                    targetElPosition.bottom = null;\n                    targetElPosition.top = hostElPosition.top - hostElPosition.originTop;\n                }\n            }\n        }\n        if (placementPrimary === 'bottom') {\n            // 如果 Bottom 空间不够，则自动适应 Top，如果 Bottom 和 Top 空间都不够，默认为可视区域Top\n            if (hostElPosition.originBottom + targetElPosition.height > documentClientHeight) {\n                const newTop = hostElPosition.top - targetElPosition.height - offset;\n                if (newTop > hostElPosition.top - hostElPosition.originTop) {\n                    targetElPosition.top = newTop;\n                } else {\n                    targetElPosition.top = hostElPosition.top - hostElPosition.originTop;\n                }\n            }\n        }\n    }\n\n    public position(element: HTMLElement, round = true): NewClientRect {\n        let elPosition: NewClientRect;\n        let parentOffset: NewClientRect = {\n            width: 0,\n            height: 0,\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n\n        if (this.getStyle(element, 'position') === 'fixed') {\n            const bcRect = element.getBoundingClientRect();\n            elPosition = {\n                width: bcRect.width,\n                height: bcRect.height,\n                top: bcRect.top,\n                bottom: bcRect.bottom,\n                left: bcRect.left,\n                right: bcRect.right,\n                originTop: bcRect.top,\n                originBottom: bcRect.bottom,\n                originLeft: bcRect.left,\n                originRight: bcRect.right\n            };\n        } else {\n            const offsetParentEl = this.offsetParent(element);\n\n            elPosition = this.offset(element, false);\n\n            if (offsetParentEl !== document.documentElement) {\n                parentOffset = this.offset(offsetParentEl, false);\n            }\n\n            parentOffset.top += offsetParentEl.clientTop;\n            parentOffset.left += offsetParentEl.clientLeft;\n        }\n\n        elPosition.top -= parentOffset.top;\n        elPosition.bottom -= parentOffset.top;\n        elPosition.left -= parentOffset.left;\n        elPosition.right -= parentOffset.left;\n\n        if (round) {\n            elPosition.top = Math.round(elPosition.top);\n            elPosition.bottom = Math.round(elPosition.bottom);\n            elPosition.left = Math.round(elPosition.left);\n            elPosition.right = Math.round(elPosition.right);\n        }\n\n        return elPosition;\n    }\n\n    public offset(element: HTMLElement, round = true): NewClientRect {\n        const elBcr = element.getBoundingClientRect();\n        const viewportOffset = {\n            top: window.pageYOffset - document.documentElement.clientTop,\n            left: window.pageXOffset - document.documentElement.clientLeft\n        };\n\n        const elOffset = {\n            height: elBcr.height || element.offsetHeight,\n            width: elBcr.width || element.offsetWidth,\n            top: elBcr.top + viewportOffset.top,\n            bottom: elBcr.bottom + viewportOffset.top,\n            left: elBcr.left + viewportOffset.left,\n            right: elBcr.right + viewportOffset.left,\n            originTop: elBcr.top,\n            originBottom: elBcr.bottom,\n            originLeft: elBcr.left,\n            originRight: elBcr.right\n        };\n\n        if (round) {\n            elOffset.height = Math.round(elOffset.height);\n            elOffset.width = Math.round(elOffset.width);\n            elOffset.top = Math.round(elOffset.top);\n            elOffset.bottom = Math.round(elOffset.bottom);\n            elOffset.left = Math.round(elOffset.left);\n            elOffset.right = Math.round(elOffset.right);\n        }\n\n        return elOffset;\n    }\n\n    /**\n     * 计算弹出层的位置\n     * @param hostElement 被追加的元素\n     * @param targetElement 弹出层内元素\n     * @param options 参数\n     */\n    public calculatePosition(hostElement: HTMLElement, targetElement: HTMLElement, options: PositioningOptions): ClientRect {\n        const { placement, appendToBody, offset, position, autoAdapt } = options;\n        let hostElPosition: NewClientRect = null;\n        // 外部传入已经算好的位置, 需要设置 hostElPosition 宽度和高度为 0，不计算位置，主要使用于右击弹出位置计算\n        if (position) {\n            hostElPosition = {\n                top: position.top || 0,\n                left: position.left || 0,\n                bottom: 0,\n                right: 0,\n                width: 0,\n                height: 0\n            };\n        } else {\n            hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n        }\n\n        const targetElStyles = this.getAllStyles(targetElement);\n\n        const documentClientWidth = document.documentElement.clientWidth;\n        const documentClientHeight = document.documentElement.clientHeight;\n\n        let placementPrimary = placement.split(' ')[0] || 'top';\n        const placementSecondary = placement.split(' ')[1] || 'center';\n\n        const targetElBCR = targetElement.getBoundingClientRect();\n        const targetElPosition: NewClientRect = {\n            height: targetElBCR.height || targetElement.offsetHeight,\n            width: targetElBCR.width || targetElement.offsetWidth,\n            top: null,\n            bottom: null,\n            left: null,\n            right: null,\n            originTop: targetElBCR.top,\n            originBottom: targetElBCR.bottom,\n            originLeft: targetElBCR.left,\n            originRight: targetElBCR.right\n        };\n\n        if (placementPrimary === 'auto') {\n            let newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement, placementSecondary);\n            if (!newPlacementPrimary) {\n                newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement);\n            }\n            if (newPlacementPrimary) {\n                placementPrimary = newPlacementPrimary;\n            }\n            targetElement.classList.add(placementPrimary);\n        }\n\n        switch (placementPrimary) {\n            case 'top':\n                targetElPosition.bottom = documentClientHeight - hostElPosition.top + offset;\n                targetElPosition.top = null;\n                this.autoAdaptTopBottom(placementPrimary, hostElPosition, targetElPosition, offset, autoAdapt);\n                this.calculateLeftRightPosition(placementSecondary, hostElPosition, targetElPosition, offset);\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height + offset;\n                this.autoAdaptTopBottom(placementPrimary, hostElPosition, targetElPosition, offset, autoAdapt);\n                this.calculateLeftRightPosition(placementSecondary, hostElPosition, targetElPosition, offset);\n                break;\n            case 'left':\n                targetElPosition.right = documentClientWidth - hostElPosition.left + offset;\n                targetElPosition.left = null;\n                this.calculateTopBottomPosition(placementSecondary, hostElPosition, targetElPosition, offset);\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width + offset;\n                targetElPosition.right = null;\n                this.calculateTopBottomPosition(placementSecondary, hostElPosition, targetElPosition, offset);\n                break;\n        }\n\n        // targetElPosition.top = Math.round(targetElPosition.top);\n        // targetElPosition.bottom = Math.round(targetElPosition.bottom);\n        // targetElPosition.left = Math.round(targetElPosition.left);\n        // targetElPosition.right = Math.round(targetElPosition.right);\n\n        return targetElPosition;\n    }\n\n    setPosition(options: PositioningOptions): void {\n        const { attach, target } = options;\n        const attachElement = ThyPositioningService.getHTMLElement(attach);\n        const targetElement = ThyPositioningService.getHTMLElement(target);\n        setTimeout(() => {\n            this.ngZone.runOutsideAngular(() => {\n                const pos = this.calculatePosition(attachElement, targetElement, options);\n                if (isNumber(pos.top)) {\n                    targetElement.style.top = `${pos.top}px`;\n                } else if (isNumber(pos.bottom)) {\n                    targetElement.style.bottom = `${pos.bottom}px`;\n                }\n                if (isNumber(pos.left)) {\n                    targetElement.style.left = `${pos.left}px`;\n                } else if (isNumber(pos.right)) {\n                    targetElement.style.right = `${pos.right}px`;\n                }\n            });\n        });\n    }\n}\n"]}