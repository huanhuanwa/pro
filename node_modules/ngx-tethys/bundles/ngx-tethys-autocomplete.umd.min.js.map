{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","../../src/autocomplete/overlay/autocomplete.config.ts","../../src/autocomplete/overlay/autocomplete-animations.ts","../../src/autocomplete/overlay/autocomplete.options.ts","../../src/autocomplete/overlay/autocomplete-container.component.ts","../../src/autocomplete/overlay/autocomplete-ref.ts","../../src/autocomplete/overlay/autocomplete.service.ts","../../src/autocomplete/autocomplete.trigger.directive.ts","../../src/autocomplete/autocomplete.component.ts","../../src/autocomplete/module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__read","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","__spread","arguments","length","concat","ThyAutocompleteConfig","_super","ThyAbstractOverlayConfig","THY_AUTOCOMPLETE_DEFAULT_CONFIG","InjectionToken","hasBackdrop","panelClass","closeOnNavigation","insideClosable","manualClosure","outsideClosable","originActiveClass","THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER","provide","useValue","Éµ0","animationBody","state","style","opacity","transform","thyAutocompleteAnimations","autocompleteContainer","trigger","autocompleteUpperOverlayOptions","name","animationEnabled","disposeWhenClose","ThyAutocompleteContainerComponent","elementRef","document","config","changeDetectorRef","thyClickDispatcher","ngZone","_this","animationState","animationStateChanged","EventEmitter","animationOpeningDone","pipe","filter","event","phaseName","toState","animationClosingDone","beforeAttachPortal","ngAfterViewInit","onAnimationDone","emit","onAnimationStart","startExitAnimation","markForCheck","ThyAbstractOverlayContainer","Component","args","selector","template","animations","host","class","tabindex","[attr.role]","[@autocompleteContainer]","(@autocompleteContainer.start)","(@autocompleteContainer.done)","ElementRef","Inject","DOCUMENT","ChangeDetectorRef","ThyClickDispatcher","NgZone","ViewChild","CdkPortalOutlet","static","ThyAutocompleteRef","ThyAbstractOverlayRef","ThyInternalAutocompleteRef","overlayRef","containerInstance","updatePosition","ThyAbstractInternalOverlayRef","ThyAutocompleteService","overlay","injector","defaultConfig","scrollDispatcher","_viewportRuler","_document","_platform","_overlayContainer","ngUnsubscribe$","Subject","originInstancesMap","Map","buildPositionStrategy","positionStrategy","FlexibleConnectedPositionStrategy","origin","positions","getFlexiblePositions","placement","offset","withPositions","withGrowAfterOpen","positionChanges","takeUntil","subscribe","change","scrollableViewProperties","isOverlayClipped","run","close","buildOverlayConfig","strategy","overlayConfig","buildBaseOverlayConfig","scrollStrategy","scrollStrategies","block","width","attachUpperOverlayContainer","userInjector","viewContainerRef","Injector","parent","providers","containerPortal","ComponentPortal","attach","instance","createUpperOverlayRef","createInjector","autocompleteRef","injectionTokens","direction","get","Directionality","of","originElementAddActiveClass","_a","coerceElement","classList","add","apply","coerceArray","originElementRemoveActiveClass","remove","open","componentOrTemplateRef","originElement","openUpperOverlay","afterClosed","delete","set","ngOnDestroy","dispose","ThyAbstractOverlayService","Injectable","providedIn","Overlay","decorators","type","ScrollDispatcher","ViewportRuler","Platform","OverlayContainer","ThyAutocompleteTriggerDirective","autocompleteService","cdr","closeKeyEventStream","panelOpened","thyOffset","thyPlacement","defineProperty","_autocompleteComponent","data","warnDeprecation","autocompleteComponent","keyManager","activeItem","merge","thyOptionSelected","tabOut","getOutsideClickStream","detachments","map","ThyOptionSelectionChangeEvent","ngOnInit","onFocus","canOpen","openPanel","onKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","selectViaInteraction","resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","ScrollToService","scrollToElement","element","nativeElement","optionsContainer","handleInput","activeElement","target","hasAttached","createOverlay","keydownEvents","altKey","stopPropagation","closePanel","detectChanges","closingActionsSubscription","unsubscribe","assign","reposition","thyAutocompleteWidth","clientWidth","contentTemplateRef","afterOpened","delay","subscribeToClosingActions","getOverlayRef","firstStable","onStable","asObservable","take","optionChanges","options","changes","switchMap","panelClosingActions","setValueAndClose","option","setValue","thyLabelText","fromEvent","clickTarget","overlayElement","contains","focus","readOnly","disabled","setActiveItem","thyAutoActiveFirstOption","destroyPanel","complete","Directive","exportAs","(input)","(focusin)","(keydown)","ViewContainerRef","Optional","HostBinding","Input","ThyAutocompleteComponent","isMultiple","mode","isEmptyOptions","isOpened","optionSelectionChanges","defer","selectionChange","thyEmptyText","thyOpened","thyClosed","thyOptionActivated","_autoActiveFirstOption","coerceBooleanProperty","setDropDownClass","instanceSelectionModel","ngAfterContentInit","startWith","resetOptions","timer","initKeyManager","changedOrDestroyed$","ActiveDescendantKeyManager","withWrap","index","source","toArray","onSelect","isUserInput","selectionModel","clear","SelectionModel","changed","added","forEach","select","removed","deselect","wasSelected","isSelected","thyValue","selected","modeClass","dropDownClass","mixinUnsubscribe","MixinBase","changeDetection","ChangeDetectionStrategy","OnPush","THY_OPTION_PARENT_COMPONENT","useExisting","ContentChildren","ThyOptionComponent","descendants","Output","NgModule","imports","CommonModule","FormsModule","ThyInputModule","ThyLabelModule","OverlayModule","PortalModule","ThyLoadingModule","ThySharedModule","ThyIconModule","ThyEmptyModule","ThyOptionModule","declarations","entryComponents","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { ElementRef, ViewContainerRef, InjectionToken } from '@angular/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ThyPlacement, ThyAbstractOverlayConfig } from 'ngx-tethys/core';\nimport { ScrollStrategy, PositionStrategy, ScrollStrategyOptions } from '@angular/cdk/overlay';\n\nexport class ThyAutocompleteConfig<TData = any> extends ThyAbstractOverlayConfig<TData> {\n    /** Origin Element, for overlay flexible connected to */\n    origin: ElementRef<any> | HTMLElement;\n\n    /** Placement be relative to origin, topCenter, topLeft, topRight, bottomCenter, bottomLeft, bottomRight ...*/\n    placement?: ThyPlacement;\n\n    /** Click inside can been close */\n    insideClosable?: boolean;\n\n    /** Offset be relative to origin, default is 4*/\n    offset?: number;\n\n    /** Manually close it, default rules is which auto close last autocomplete when open a new unless set manualClosure as true */\n    manualClosure?: boolean;\n\n    /** Origin active class when autocomplete is opened */\n    originActiveClass?: string | string[];\n\n    /**\n     * æ»å¨ç­ç¥\n     */\n    scrollStrategy?: ScrollStrategy;\n\n    /** Click outside can been close */\n    outsideClosable?: boolean;\n}\n\nexport const THY_AUTOCOMPLETE_DEFAULT_CONFIG = new InjectionToken<ThyAutocompleteConfig>('thy-autocomplete-default-config');\n\nexport const THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER = {\n    provide: THY_AUTOCOMPLETE_DEFAULT_CONFIG,\n    useValue: {\n        hasBackdrop: false,\n        panelClass: '',\n        closeOnNavigation: true,\n        insideClosable: true,\n        manualClosure: false,\n        outsideClosable: true,\n        originActiveClass: 'thy-autocomplete-origin-active'\n    }\n};\n","import { animate, state, style, transition, trigger, AnimationTriggerMetadata } from '@angular/animations';\n\nconst animationBody = [\n    state('void, exit', style({ opacity: 0, transform: 'scale(0.1)' })),\n    state('enter', style({ transform: 'none' }))\n];\n\n/**\n * Animations used by ThyAutocomplete.\n * @docs-private\n */\nexport const thyAutocompleteAnimations: {\n    readonly autocompleteContainer: AnimationTriggerMetadata;\n} = {\n    autocompleteContainer: trigger('autocompleteContainer', animationBody)\n};\n","import { ThyUpperOverlayOptions } from 'ngx-tethys/core';\n\nexport const autocompleteUpperOverlayOptions: ThyUpperOverlayOptions = {\n    name: 'autocomplete',\n    animationEnabled: true,\n    disposeWhenClose: true\n};\n","import {\n    Component,\n    ComponentRef,\n    ViewChild,\n    EmbeddedViewRef,\n    Inject,\n    ElementRef,\n    EventEmitter,\n    HostListener,\n    ChangeDetectorRef,\n    OnInit,\n    AfterViewInit,\n    NgZone,\n    TemplateRef\n} from '@angular/core';\nimport { ComponentPortal, TemplatePortal, CdkPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT } from '@angular/common';\nimport { AnimationEvent } from '@angular/animations';\n\nimport { ThyAutocompleteConfig } from './autocomplete.config';\nimport { thyAutocompleteAnimations } from './autocomplete-animations';\nimport { ThyAbstractOverlayContainer } from 'ngx-tethys/core';\nimport { autocompleteUpperOverlayOptions } from './autocomplete.options';\nimport { Observable, fromEvent, timer } from 'rxjs';\nimport { filter, takeUntil } from 'rxjs/operators';\nimport { ThyClickDispatcher } from 'ngx-tethys/core';\n\n@Component({\n    selector: 'thy-autocomplete-container',\n    templateUrl: './autocomplete-container.component.html',\n    animations: [thyAutocompleteAnimations.autocompleteContainer],\n    host: {\n        class: 'thy-autocomplete-container',\n        tabindex: '-1',\n        '[attr.role]': `'autocomplete'`,\n        '[@autocompleteContainer]': 'animationState',\n        '(@autocompleteContainer.start)': 'onAnimationStart($event)',\n        '(@autocompleteContainer.done)': 'onAnimationDone($event)'\n    }\n})\nexport class ThyAutocompleteContainerComponent extends ThyAbstractOverlayContainer implements AfterViewInit {\n    @ViewChild(CdkPortalOutlet, { static: true })\n    portalOutlet: CdkPortalOutlet;\n\n    /** State of the autocomplete animation. */\n    animationState: 'void' | 'enter' | 'exit' = 'enter';\n\n    /** Emits when an animation state changes. */\n    animationStateChanged = new EventEmitter<AnimationEvent>();\n\n    animationOpeningDone: Observable<AnimationEvent>;\n    animationClosingDone: Observable<AnimationEvent>;\n\n    beforeAttachPortal(): void {}\n\n    constructor(\n        private elementRef: ElementRef,\n        @Inject(DOCUMENT) private document: any,\n        public config: ThyAutocompleteConfig,\n        changeDetectorRef: ChangeDetectorRef,\n        private thyClickDispatcher: ThyClickDispatcher,\n        private ngZone: NgZone\n    ) {\n        super(autocompleteUpperOverlayOptions, changeDetectorRef);\n\n        this.animationOpeningDone = this.animationStateChanged.pipe(\n            filter((event: AnimationEvent) => {\n                return event.phaseName === 'done' && event.toState === 'enter';\n            })\n        );\n        this.animationClosingDone = this.animationStateChanged.pipe(\n            filter((event: AnimationEvent) => {\n                return event.phaseName === 'done' && event.toState === 'exit';\n            })\n        );\n    }\n\n    ngAfterViewInit() {}\n\n    /** Callback, invoked whenever an animation on the host completes. */\n    onAnimationDone(event: AnimationEvent) {\n        this.animationStateChanged.emit(event);\n    }\n\n    /** Callback, invoked when an animation on the host starts. */\n    onAnimationStart(event: AnimationEvent) {\n        this.animationStateChanged.emit(event);\n    }\n\n    startExitAnimation(): void {\n        this.animationState = 'exit';\n        this.changeDetectorRef.markForCheck();\n    }\n}\n","import { OverlayRef } from '@angular/cdk/overlay';\nimport { ThyAutocompleteContainerComponent } from './autocomplete-container.component';\nimport { ThyAbstractOverlayRef, ThyAbstractInternalOverlayRef, ThyUpperOverlayPosition } from 'ngx-tethys/core';\nimport { autocompleteUpperOverlayOptions } from './autocomplete.options';\nimport { ThyAutocompleteConfig } from './autocomplete.config';\n\nexport abstract class ThyAutocompleteRef<T, TResult = any> extends ThyAbstractOverlayRef<T, ThyAutocompleteContainerComponent, TResult> {}\n\nexport class ThyInternalAutocompleteRef<T, TResult = any>\n    extends ThyAbstractInternalOverlayRef<T, ThyAutocompleteContainerComponent, TResult>\n    implements ThyAutocompleteRef<T, TResult> {\n    constructor(overlayRef: OverlayRef, containerInstance: ThyAutocompleteContainerComponent, config: ThyAutocompleteConfig) {\n        super(autocompleteUpperOverlayOptions, overlayRef, containerInstance, config);\n    }\n\n    /**\n     * Updates the autocomplete's position.\n     * @param position New autocomplete position.\n     */\n    updatePosition(): this {\n        this.overlayRef.updatePosition();\n        return this;\n    }\n}\n","import {\n    ComponentType,\n    Overlay,\n    OverlayConfig,\n    OverlayRef,\n    PositionStrategy,\n    ScrollDispatcher,\n    OverlayContainer,\n    FlexibleConnectedPositionStrategy\n} from '@angular/cdk/overlay';\nimport { TemplateRef, ViewContainerRef, Injectable, ElementRef, Injector, OnDestroy, Inject, NgZone } from '@angular/core';\nimport { coerceElement, coerceArray } from '@angular/cdk/coercion';\nimport { ComponentPortal, TemplatePortal } from '@angular/cdk/portal';\nimport { ThyAutocompleteContainerComponent } from './autocomplete-container.component';\nimport { ThyAutocompleteConfig, THY_AUTOCOMPLETE_DEFAULT_CONFIG } from './autocomplete.config';\nimport { ThyAutocompleteRef, ThyInternalAutocompleteRef } from './autocomplete-ref';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { of, Subject } from 'rxjs';\nimport { getFlexiblePositions, ThyAbstractOverlayService, ThyAbstractOverlayRef } from 'ngx-tethys/core';\nimport { takeUntil } from 'rxjs/operators';\nimport { isArray } from 'ngx-tethys/util';\nimport { autocompleteUpperOverlayOptions } from './autocomplete.options';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport { Platform } from '@angular/cdk/platform';\nimport { StaticProvider } from '@angular/core';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ThyAutocompleteService extends ThyAbstractOverlayService<ThyAutocompleteConfig, ThyAutocompleteContainerComponent>\n    implements OnDestroy {\n    private readonly ngUnsubscribe$ = new Subject();\n\n    private originInstancesMap = new Map<\n        ElementRef | HTMLElement,\n        {\n            config: ThyAutocompleteConfig;\n            autocompleteRef: ThyAutocompleteRef<any, any>;\n        }\n    >();\n\n    private buildPositionStrategy<TData>(config: ThyAutocompleteConfig<TData>): PositionStrategy {\n        const positionStrategy = new FlexibleConnectedPositionStrategy(\n            config.origin,\n            this._viewportRuler,\n            this._document,\n            this._platform,\n            this._overlayContainer\n        );\n        const positions = getFlexiblePositions(config.placement, config.offset, 'thy-autocomplete');\n        positionStrategy.withPositions(positions);\n        positionStrategy.withGrowAfterOpen(true);\n        positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {\n            if (change.scrollableViewProperties.isOverlayClipped) {\n                // After position changes occur and the overlay is clipped by\n                // a parent scrollable then close the tooltip.\n                this.ngZone.run(() => this.close());\n            }\n        });\n        return positionStrategy;\n    }\n\n    protected buildOverlayConfig<TData>(config: ThyAutocompleteConfig<TData>): OverlayConfig {\n        const strategy = this.buildPositionStrategy(config);\n        const overlayConfig = this.buildBaseOverlayConfig(config);\n        overlayConfig.positionStrategy = strategy;\n        overlayConfig.scrollStrategy = config.scrollStrategy || this.overlay.scrollStrategies.block();\n        overlayConfig.width = config.width;\n        return overlayConfig;\n    }\n\n    protected attachUpperOverlayContainer(overlay: OverlayRef, config: ThyAutocompleteConfig<any>): ThyAutocompleteContainerComponent {\n        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n        const injector = Injector.create({\n            parent: userInjector || this.injector,\n            providers: [{ provide: ThyAutocompleteConfig, useValue: config }]\n        });\n        const containerPortal = new ComponentPortal(ThyAutocompleteContainerComponent, config.viewContainerRef, injector);\n        const containerRef = overlay.attach<ThyAutocompleteContainerComponent>(containerPortal);\n        return containerRef.instance;\n    }\n\n    protected createUpperOverlayRef<T>(\n        overlayRef: OverlayRef,\n        containerInstance: ThyAutocompleteContainerComponent,\n        config: ThyAutocompleteConfig<any>\n    ): ThyInternalAutocompleteRef<T> {\n        return new ThyInternalAutocompleteRef<T>(overlayRef, containerInstance, config);\n    }\n\n    protected createInjector<T>(\n        config: ThyAutocompleteConfig,\n        autocompleteRef: ThyAutocompleteRef<T>,\n        autocompleteContainer: ThyAutocompleteContainerComponent\n    ): Injector {\n        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n        const injectionTokens: StaticProvider[] = [\n            {\n                provide: ThyAutocompleteContainerComponent,\n                useValue: autocompleteContainer\n            },\n            {\n                provide: ThyAutocompleteRef,\n                useValue: autocompleteRef\n            }\n        ];\n\n        if (config.direction && (!userInjector || !userInjector.get<Directionality | null>(Directionality, null))) {\n            injectionTokens.push({\n                provide: Directionality,\n                useValue: {\n                    value: config.direction,\n                    change: of()\n                }\n            });\n        }\n\n        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });\n    }\n\n    private originElementAddActiveClass(config: ThyAutocompleteConfig) {\n        if (config.originActiveClass) {\n            coerceElement<HTMLElement>(config.origin).classList.add(...coerceArray(config.originActiveClass));\n        }\n    }\n\n    private originElementRemoveActiveClass(config: ThyAutocompleteConfig) {\n        if (config.originActiveClass) {\n            coerceElement<HTMLElement>(config.origin).classList.remove(...coerceArray(config.originActiveClass));\n        }\n    }\n\n    constructor(\n        overlay: Overlay,\n        injector: Injector,\n        @Inject(THY_AUTOCOMPLETE_DEFAULT_CONFIG) defaultConfig: ThyAutocompleteConfig,\n        private scrollDispatcher: ScrollDispatcher,\n        private ngZone: NgZone,\n        private _viewportRuler: ViewportRuler,\n        @Inject(DOCUMENT) private _document: any,\n        private _platform: Platform,\n        private _overlayContainer: OverlayContainer\n    ) {\n        super(autocompleteUpperOverlayOptions, overlay, injector, defaultConfig);\n    }\n\n    open<T, TData = any, TResult = any>(\n        componentOrTemplateRef: ComponentType<T> | TemplateRef<T>,\n        config?: ThyAutocompleteConfig<TData>\n    ): ThyAutocompleteRef<T, TResult> {\n        const originElement = coerceElement(config.origin);\n        const autocompleteRef = this.openUpperOverlay(componentOrTemplateRef, config) as ThyAutocompleteRef<T>;\n        config = autocompleteRef.containerInstance.config;\n        autocompleteRef.afterClosed().subscribe(() => {\n            this.originElementRemoveActiveClass(config);\n            this.originInstancesMap.delete(originElement);\n        });\n\n        this.originElementAddActiveClass(config);\n        this.originInstancesMap.set(originElement, {\n            config,\n            autocompleteRef\n        });\n\n        return autocompleteRef;\n    }\n\n    ngOnDestroy() {\n        this.dispose();\n    }\n}\n","import {\n    Directive,\n    ElementRef,\n    Injectable,\n    NgZone,\n    OnDestroy,\n    Input,\n    OnInit,\n    ViewContainerRef,\n    HostBinding,\n    Optional,\n    Inject,\n    ChangeDetectorRef\n} from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { OverlayRef, Overlay } from '@angular/cdk/overlay';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { ThyOverlayDirectiveBase, ThyPlacement } from 'ngx-tethys/core';\nimport { ThyAutocompleteService } from './overlay/autocomplete.service';\nimport { ThyAutocompleteRef } from './overlay/autocomplete-ref';\nimport { ThyAutocompleteComponent } from './autocomplete.component';\nimport { ThyOptionComponent, ThyOptionSelectionChangeEvent } from 'ngx-tethys/shared';\nimport { DOCUMENT } from '@angular/common';\nimport { Subject, Observable, merge, fromEvent, of, Subscription } from 'rxjs';\nimport { ESCAPE, UP_ARROW, ENTER, DOWN_ARROW, TAB } from 'ngx-tethys/util';\nimport { filter, map, take, tap, delay, switchMap } from 'rxjs/operators';\nimport { ScrollToService } from 'ngx-tethys/core';\nimport { warnDeprecation } from 'ngx-tethys/util';\n\n@Directive({\n    selector: 'input[thyAutocompleteTrigger], textarea[thyAutocompleteTrigger]',\n    exportAs: 'thyAutocompleteTrigger',\n    host: {\n        '(input)': 'handleInput($event)',\n        '(focusin)': 'onFocus()',\n        '(keydown)': 'onKeydown($event)'\n    }\n})\nexport class ThyAutocompleteTriggerDirective implements OnInit, OnDestroy {\n    protected overlayRef: OverlayRef;\n\n    private autocompleteRef: ThyAutocompleteRef<ThyAutocompleteComponent>;\n\n    private readonly closeKeyEventStream = new Subject<void>();\n\n    private closingActionsSubscription: Subscription;\n\n    private _autocompleteComponent: ThyAutocompleteComponent;\n\n    @HostBinding(`class.thy-autocomplete-opened`) panelOpened = false;\n\n    @Input('thyAutocompleteComponent')\n    set autocompleteComponent(data: ThyAutocompleteComponent) {\n        this._autocompleteComponent = data;\n    }\n\n    @Input('thyAutocomplete')\n    set autocomplete(data: ThyAutocompleteComponent) {\n        warnDeprecation(`The property thyAutocomplete will be deprecated, please use thyAutocompleteComponent instead.`);\n        this._autocompleteComponent = data;\n    }\n\n    get autocompleteComponent() {\n        return this._autocompleteComponent;\n    }\n\n    @Input() thyOffset = 4;\n\n    @Input() thyAutocompleteWidth: number;\n\n    @Input() thyPlacement: ThyPlacement = 'bottomLeft';\n\n    get activeOption(): ThyOptionComponent | null {\n        if (this.autocompleteComponent && this.autocompleteComponent.keyManager) {\n            return this.autocompleteComponent.keyManager.activeItem;\n        }\n\n        return null;\n    }\n\n    get panelClosingActions(): Observable<ThyOptionSelectionChangeEvent | null> {\n        return merge(\n            this.autocompleteComponent.thyOptionSelected,\n            this.autocompleteComponent.keyManager.tabOut.pipe(filter(() => this.panelOpened)),\n            this.closeKeyEventStream,\n            this.getOutsideClickStream(),\n            this.overlayRef ? this.overlayRef.detachments().pipe(filter(() => this.panelOpened)) : of()\n        ).pipe(\n            // Normalize the output so we return a consistent type.\n            map(event => (event instanceof ThyOptionSelectionChangeEvent ? event : null))\n        );\n    }\n\n    constructor(\n        private elementRef: ElementRef,\n        private ngZone: NgZone,\n        private overlay: Overlay,\n        private autocompleteService: ThyAutocompleteService,\n        private viewContainerRef: ViewContainerRef,\n        @Optional() @Inject(DOCUMENT) private document: any,\n        private cdr: ChangeDetectorRef\n    ) {}\n\n    ngOnInit(): void {}\n\n    onFocus() {\n        if (this.canOpen()) {\n            this.openPanel();\n        }\n    }\n\n    onKeydown(event: KeyboardEvent) {\n        const keyCode = event.keyCode;\n\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n        if (this.activeOption && keyCode === ENTER && this.panelOpened) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        } else if (this.autocompleteComponent) {\n            const prevActiveItem = this.autocompleteComponent.keyManager.activeItem;\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n            if (this.panelOpened || keyCode === TAB) {\n                this.autocompleteComponent.keyManager.onKeydown(event);\n            } else if (isArrowKey && this.canOpen()) {\n                this.openPanel();\n            }\n            if (\n                (isArrowKey || this.autocompleteComponent.keyManager.activeItem !== prevActiveItem) &&\n                this.autocompleteComponent.keyManager.activeItem\n            ) {\n                ScrollToService.scrollToElement(\n                    this.autocompleteComponent.keyManager.activeItem.element.nativeElement,\n                    this.autocompleteComponent.optionsContainer.nativeElement\n                );\n            }\n        }\n    }\n\n    handleInput(event: KeyboardEvent) {\n        if (this.canOpen() && document.activeElement === event.target) {\n            this.openPanel();\n        }\n    }\n\n    openPanel() {\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            return;\n        }\n        const overlayRef = this.createOverlay();\n        this.overlayRef = overlayRef;\n        overlayRef.keydownEvents().subscribe(event => {\n            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n            if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                this.resetActiveItem();\n                this.closeKeyEventStream.next();\n                // We need to stop propagation, otherwise the event will eventually\n                // reach the input itself and cause the overlay to be reopened.\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        });\n        this.panelOpened = true;\n        this.autocompleteComponent.open();\n    }\n\n    closePanel() {\n        if (this.autocompleteRef) {\n            this.autocompleteRef.close();\n            this.cdr.detectChanges();\n            this.closingActionsSubscription.unsubscribe();\n        }\n    }\n\n    createOverlay(): OverlayRef {\n        const config = Object.assign({\n            origin: this.elementRef.nativeElement,\n            viewContainerRef: this.viewContainerRef,\n            placement: this.thyPlacement,\n            offset: this.thyOffset,\n            scrollStrategy: this.overlay.scrollStrategies.reposition(),\n            width: this.thyAutocompleteWidth || this.elementRef.nativeElement.clientWidth\n        });\n        this.autocompleteRef = this.autocompleteService.open(this.autocompleteComponent.contentTemplateRef, config);\n        this.autocompleteRef.afterClosed().subscribe(() => {\n            this.panelOpened = false;\n            this.autocompleteComponent.close();\n        });\n        // delay 200ms to prevent emit document click rightnow\n        this.autocompleteRef\n            .afterOpened()\n            .pipe(delay(200))\n            .subscribe(() => {\n                this.closingActionsSubscription = this.subscribeToClosingActions();\n            });\n        return this.autocompleteRef.getOverlayRef();\n    }\n\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private subscribeToClosingActions(): Subscription {\n        const firstStable = this.ngZone.onStable.asObservable().pipe(take(1));\n        const optionChanges = this.autocompleteComponent.options.changes.pipe(\n            // Defer emitting to the stream until the next tick, because changing\n            // bindings in here will cause \"changed after checked\" errors.\n            delay(0)\n        );\n        // When the zone is stable initially, and when the option list changes...\n        return (\n            merge(firstStable, optionChanges)\n                .pipe(\n                    // create a new stream of panelClosingActions, replacing any previous streams\n                    // that were created, and flatten it so our stream only emits closing events...\n                    switchMap(() => {\n                        this.resetActiveItem();\n\n                        if (this.panelOpened) {\n                            this.overlayRef.updatePosition();\n                        }\n                        return this.panelClosingActions;\n                    }),\n                    // when the first closing event occurs...\n                    take(1)\n                )\n                // set the value, close the panel, and complete.\n                .subscribe(event => this.setValueAndClose(event))\n        );\n    }\n\n    private setValueAndClose(event: ThyOptionSelectionChangeEvent | null): void {\n        if (event && event.option) {\n            this.setValue(event.option.thyLabelText);\n        }\n        this.closePanel();\n    }\n\n    /** Stream of clicks outside of the autocomplete panel. */\n    private getOutsideClickStream(): Observable<any> {\n        return merge(\n            fromEvent(this.document, 'click') as Observable<MouseEvent>,\n            fromEvent(this.document, 'touchend') as Observable<TouchEvent>\n        ).pipe(\n            filter(event => {\n                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n                // fall back to check the first element in the path of the click event.\n                const clickTarget = event.target as HTMLElement;\n                const formField: any = null;\n\n                return (\n                    this.panelOpened &&\n                    clickTarget !== this.elementRef.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    !!this.overlayRef &&\n                    !this.overlayRef.overlayElement.contains(clickTarget)\n                );\n            })\n        );\n    }\n\n    private setValue(value: string) {\n        this.elementRef.nativeElement.value = value;\n        this.elementRef.nativeElement.focus();\n    }\n\n    private canOpen(): boolean {\n        const element: HTMLInputElement = this.elementRef.nativeElement;\n        return !element.readOnly && !element.disabled;\n    }\n\n    private resetActiveItem(): void {\n        this.autocompleteComponent.keyManager.setActiveItem(this.autocompleteComponent.thyAutoActiveFirstOption ? 0 : -1);\n    }\n\n    private destroyPanel(): void {\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n\n    ngOnDestroy() {\n        this.closeKeyEventStream.complete();\n        this.destroyPanel();\n    }\n}\n","import {\n    Component,\n    TemplateRef,\n    ViewChild,\n    ChangeDetectionStrategy,\n    ContentChildren,\n    QueryList,\n    OnInit,\n    Output,\n    EventEmitter,\n    NgZone,\n    OnDestroy,\n    AfterContentInit,\n    ChangeDetectorRef,\n    Input,\n    ElementRef\n} from '@angular/core';\nimport { Constructor, ThyUnsubscribe } from 'ngx-tethys/core';\nimport { defer, merge, Observable, timer } from 'rxjs';\nimport { take, switchMap, takeUntil, startWith } from 'rxjs/operators';\nimport { MixinBase, mixinUnsubscribe } from 'ngx-tethys/core';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport {\n    THY_OPTION_PARENT_COMPONENT,\n    IThyOptionParentComponent,\n    ThyOptionComponent,\n    ThyOptionSelectionChangeEvent\n} from 'ngx-tethys/shared';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\n\n/** Event object that is emitted when an autocomplete option is activated. */\nexport interface ThyAutocompleteActivatedEvent {\n    /** Reference to the autocomplete panel that emitted the event. */\n    source: ThyAutocompleteComponent;\n\n    /** Option that was selected. */\n    option: ThyOptionComponent | null;\n}\n\nconst _MixinBase: Constructor<ThyUnsubscribe> & typeof MixinBase = mixinUnsubscribe(MixinBase);\n@Component({\n    selector: 'thy-autocomplete',\n    templateUrl: 'autocomplete.component.html',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [\n        {\n            provide: THY_OPTION_PARENT_COMPONENT,\n            useExisting: ThyAutocompleteComponent\n        }\n    ]\n})\nexport class ThyAutocompleteComponent extends _MixinBase implements IThyOptionParentComponent, OnInit, AfterContentInit, OnDestroy {\n    dropDownClass: { [key: string]: boolean };\n\n    isMultiple = false;\n\n    mode = '';\n\n    isEmptyOptions = false;\n\n    selectionModel: SelectionModel<ThyOptionComponent>;\n\n    isOpened = false;\n\n    /** Manages active item in option list based on key events. */\n    keyManager: ActiveDescendantKeyManager<ThyOptionComponent>;\n\n    @ViewChild('contentTemplate', { static: true })\n    contentTemplateRef: TemplateRef<any>;\n\n    // scroll element container\n    @ViewChild('panel')\n    optionsContainer: ElementRef<any>;\n\n    @ContentChildren(ThyOptionComponent, { descendants: true }) options: QueryList<ThyOptionComponent>;\n\n    readonly optionSelectionChanges: Observable<ThyOptionSelectionChangeEvent> = defer(() => {\n        if (this.options) {\n            return merge(...this.options.map(option => option.selectionChange));\n        }\n        return this.ngZone.onStable.asObservable().pipe(\n            take(1),\n            switchMap(() => this.optionSelectionChanges)\n        );\n    }) as Observable<ThyOptionSelectionChangeEvent>;\n\n    @Input()\n    thyEmptyText = 'æ²¡æä»»ä½æ°æ®';\n\n    @Input()\n    get thyAutoActiveFirstOption(): boolean {\n        return this._autoActiveFirstOption;\n    }\n    set thyAutoActiveFirstOption(value: boolean) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n    private _autoActiveFirstOption: boolean;\n\n    @Output() thyOptionSelected: EventEmitter<ThyOptionSelectionChangeEvent> = new EventEmitter<ThyOptionSelectionChangeEvent>();\n\n    @Output() readonly thyOpened: EventEmitter<void> = new EventEmitter<void>();\n\n    @Output() readonly thyClosed: EventEmitter<void> = new EventEmitter<void>();\n\n    /** Emits whenever an option is activated using the keyboard. */\n    @Output() readonly thyOptionActivated: EventEmitter<ThyAutocompleteActivatedEvent> = new EventEmitter<ThyAutocompleteActivatedEvent>();\n\n    constructor(private ngZone: NgZone, private changeDetectorRef: ChangeDetectorRef) {\n        super();\n    }\n\n    ngOnInit() {\n        this.setDropDownClass();\n        this.instanceSelectionModel();\n    }\n\n    ngAfterContentInit() {\n        this.options.changes.pipe(startWith(null), takeUntil(this.ngUnsubscribe$)).subscribe(() => {\n            this.resetOptions();\n            timer().subscribe(() => {\n                this.isEmptyOptions = this.options.length <= 0;\n                this.changeDetectorRef.detectChanges();\n            });\n            this.initKeyManager();\n        });\n    }\n\n    initKeyManager() {\n        const changedOrDestroyed$ = merge(this.options.changes, this.ngUnsubscribe$);\n        this.keyManager = new ActiveDescendantKeyManager<ThyOptionComponent>(this.options).withWrap();\n        this.keyManager.change.pipe(takeUntil(changedOrDestroyed$)).subscribe(index => {\n            this.thyOptionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\n        });\n    }\n\n    open() {\n        this.isOpened = true;\n        this.changeDetectorRef.markForCheck();\n        this.thyOpened.emit();\n    }\n\n    close() {\n        this.isOpened = false;\n        this.thyClosed.emit();\n    }\n\n    private resetOptions() {\n        const changedOrDestroyed$ = merge(this.options.changes, this.ngUnsubscribe$);\n\n        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed$)).subscribe((event: ThyOptionSelectionChangeEvent) => {\n            this.onSelect(event.option, event.isUserInput);\n        });\n    }\n\n    private instanceSelectionModel() {\n        if (this.selectionModel) {\n            this.selectionModel.clear();\n        }\n        this.selectionModel = new SelectionModel<ThyOptionComponent>(this.isMultiple);\n        this.selectionModel.changed.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {\n            event.added.forEach(option => option.select());\n            event.removed.forEach(option => option.deselect());\n        });\n    }\n\n    private onSelect(option: ThyOptionComponent, isUserInput: boolean) {\n        const wasSelected = this.selectionModel.isSelected(option);\n\n        if (option.thyValue == null && !this.isMultiple) {\n            option.deselect();\n            this.selectionModel.clear();\n        } else {\n            if (wasSelected !== option.selected) {\n                option.selected ? this.selectionModel.select(option) : this.selectionModel.deselect(option);\n            }\n\n            if (isUserInput) {\n                this.keyManager.setActiveItem(option);\n            }\n\n            // if (this.isMultiple) {\n            //     this.sortValues();\n            //     if (isUserInput) {\n            //         this.focus();\n            //     }\n            // }\n        }\n\n        if (wasSelected !== this.selectionModel.isSelected(option)) {\n            this.thyOptionSelected.emit(new ThyOptionSelectionChangeEvent(option, false));\n        }\n        this.changeDetectorRef.markForCheck();\n    }\n\n    private setDropDownClass() {\n        let modeClass = '';\n        if (this.isMultiple) {\n            modeClass = `thy-select-dropdown-${this.mode}`;\n        } else {\n            modeClass = `thy-select-dropdown-single`;\n        }\n        this.dropDownClass = {\n            [`thy-select-dropdown`]: true,\n            [modeClass]: true\n        };\n    }\n\n    ngOnDestroy() {\n        super.ngOnDestroy();\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { ThyAutocompleteTriggerDirective } from './autocomplete.trigger.directive';\nimport { ThyInputModule } from 'ngx-tethys/input';\nimport { ThyAutocompleteComponent } from './autocomplete.component';\nimport { ThyLabelModule } from 'ngx-tethys/label';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { ThyLoadingModule } from 'ngx-tethys/loading';\nimport { ThySharedModule } from 'ngx-tethys/shared';\nimport { ThyIconModule } from 'ngx-tethys/icon';\nimport { ThyEmptyModule } from 'ngx-tethys/empty';\nimport { ThyAutocompleteContainerComponent } from './overlay/autocomplete-container.component';\nimport { THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER } from './overlay/autocomplete.config';\nimport { ThyOptionModule } from 'ngx-tethys/shared';\nimport { PortalModule } from '@angular/cdk/portal';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        ThyInputModule,\n        ThyLabelModule,\n        OverlayModule,\n        PortalModule,\n        ThyLoadingModule,\n        ThySharedModule,\n        ThyIconModule,\n        ThyEmptyModule,\n        ThyOptionModule\n    ],\n    declarations: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent],\n    entryComponents: [ThyAutocompleteContainerComponent],\n    exports: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent, ThyOptionModule],\n    providers: [THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER]\n})\nexport class ThyAutocompleteModule {}\n"]}