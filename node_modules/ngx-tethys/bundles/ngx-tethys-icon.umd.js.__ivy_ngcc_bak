(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/common'), require('ngx-tethys/core'), require('@angular/platform-browser'), require('rxjs'), require('@angular/common/http'), require('rxjs/operators'), require('ngx-tethys/util')) :
    typeof define === 'function' && define.amd ? define('ngx-tethys/icon', ['exports', '@angular/core', '@angular/forms', '@angular/common', 'ngx-tethys/core', '@angular/platform-browser', 'rxjs', '@angular/common/http', 'rxjs/operators', 'ngx-tethys/util'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-tethys'] = global['ngx-tethys'] || {}, global['ngx-tethys'].icon = {}), global.ng.core, global.ng.forms, global.ng.common, global['ngx-tethys'].core, global.ng.platformBrowser, global.rxjs, global.ng.common.http, global.rxjs.operators, global['ngx-tethys'].util));
}(this, (function (exports, i0, forms, i3, core, i1, rxjs, i2, operators, util) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var SvgIconConfig = /** @class */ (function () {
        function SvgIconConfig(data) {
            // Note that we can't use `instanceof SVGElement` here,
            // because it'll break during server-side rendering.
            if (!!data.nodeName) {
                this.svgElement = data;
            }
            else {
                this.url = data;
            }
        }
        return SvgIconConfig;
    }());
    var ThyIconRegistry = /** @class */ (function () {
        function ThyIconRegistry(sanitizer, httpClient, document) {
            this.sanitizer = sanitizer;
            this.httpClient = httpClient;
            this.document = document;
            this.defaultFontSetClass = 'wt-icon';
            this.internalIconMode = 'svg';
            this.svgIconConfigs = new Map();
            this.svgIconSetConfigs = new Map();
            this.inProgressUrlFetches = new Map();
        }
        Object.defineProperty(ThyIconRegistry.prototype, "iconMode", {
            get: function () {
                return this.internalIconMode;
            },
            enumerable: false,
            configurable: true
        });
        ThyIconRegistry.prototype.getIconNameNotFoundError = function (iconName) {
            return Error("Unable to find icon with the name \"" + iconName + "\"");
        };
        ThyIconRegistry.prototype.getIconFailedToSanitizeLiteralError = function (literal) {
            return Error("The literal provided to MatIconRegistry was not trusted as safe HTML by " +
                ("Angular's DomSanitizer. Attempted literal was \"" + literal + "\"."));
        };
        ThyIconRegistry.prototype.internalAddSvgIconSet = function (namespace, config) {
            var configNamespace = this.svgIconSetConfigs.get(namespace);
            if (configNamespace) {
                configNamespace.push(config);
            }
            else {
                this.svgIconSetConfigs.set(namespace, [config]);
            }
            return this;
        };
        ThyIconRegistry.prototype.cloneSvg = function (svg) {
            return svg.cloneNode(true);
        };
        ThyIconRegistry.prototype.fetchUrl = function (safeUrl) {
            var _this = this;
            if (safeUrl == null) {
                throw Error("Cannot fetch icon from URL \"" + safeUrl + "\".");
            }
            var url = this.sanitizer.sanitize(i0.SecurityContext.RESOURCE_URL, safeUrl);
            if (!url) {
                throw new Error("The URL provided to ThyIconRegistry was not trusted as a resource URL " +
                    ("via Angular's DomSanitizer. Attempted URL was \"" + url + "\"."));
            }
            // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
            // already a request in progress for that URL. It's necessary to call share() on the
            // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
            var inProgressFetch = this.inProgressUrlFetches.get(url);
            if (inProgressFetch) {
                return inProgressFetch;
            }
            else {
                // TODO(jelbourn): for some reason, the `finalize` operator "loses" the generic type on the
                // Observable. Figure out why and fix it.
                var req = this.httpClient.get(url, { responseType: 'text' }).pipe(operators.finalize(function () { return _this.inProgressUrlFetches.delete(url); }), operators.share());
                this.inProgressUrlFetches.set(url, req);
                return req;
            }
        };
        ThyIconRegistry.prototype.toSvgElement = function (element) {
            var svg = this.svgElementFromString('<svg></svg>');
            for (var i = 0; i < element.childNodes.length; i++) {
                if (element.childNodes[i].nodeType === this.document.ELEMENT_NODE) {
                    svg.appendChild(element.childNodes[i].cloneNode(true));
                }
            }
            return svg;
        };
        ThyIconRegistry.prototype.extractSvgIconFromIconSet = function (iconSet, iconName) {
            // Use the `id="iconName"` syntax in order to escape special
            // characters in the ID (versus using the #iconName syntax).
            var iconSource = iconSet.querySelector("[id=\"" + iconName + "\"]");
            if (!iconSource) {
                return null;
            }
            // Clone the element and remove the ID to prevent multiple elements from being added
            // to the page with the same ID.
            var iconElement = iconSource.cloneNode(true);
            iconElement.removeAttribute('id');
            // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
            // the content of a new <svg> node.
            if (iconElement.nodeName.toLowerCase() === 'svg') {
                return this.setSvgAttributes(iconElement);
            }
            // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note
            // that the same could be achieved by referring to it via <use href="#id">, however the <use>
            // tag is problematic on Firefox, because it needs to include the current page path.
            if (iconElement.nodeName.toLowerCase() === 'symbol') {
                return this.setSvgAttributes(this.toSvgElement(iconElement));
            }
            // createElement('SVG') doesn't work as expected; the DOM ends up with
            // the correct nodes, but the SVG content doesn't render. Instead we
            // have to create an empty SVG node using innerHTML and append its content.
            // Elements created using DOMParser.parseFromString have the same problem.
            // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
            var svg = this.svgElementFromString('<svg></svg>');
            // Clone the node so we don't remove it from the parent icon set element.
            svg.appendChild(iconElement);
            return this.setSvgAttributes(svg);
        };
        ThyIconRegistry.prototype.extractIconWithNameFromIconSetConfigs = function (iconName, iconSetConfigs) {
            // Iterate backwards, so icon sets added later have precedence.
            for (var i = iconSetConfigs.length - 1; i >= 0; i--) {
                var config = iconSetConfigs[i];
                if (config.svgElement) {
                    var foundIcon = this.extractSvgIconFromIconSet(config.svgElement, iconName);
                    if (foundIcon) {
                        return foundIcon;
                    }
                }
            }
            return null;
        };
        ThyIconRegistry.prototype.svgElementFromString = function (str) {
            var div = this.document.createElement('DIV');
            div.innerHTML = str;
            var svg = div.querySelector('svg');
            if (!svg) {
                throw Error('<svg> tag not found');
            }
            return svg;
        };
        ThyIconRegistry.prototype.setSvgAttributes = function (svg) {
            svg.setAttribute('fit', '');
            svg.setAttribute('height', '1em');
            svg.setAttribute('width', '1em');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
            return svg;
        };
        ThyIconRegistry.prototype.createSvgElementForSingleIcon = function (responseText) {
            var svg = this.svgElementFromString(responseText);
            this.setSvgAttributes(svg);
            return svg;
        };
        ThyIconRegistry.prototype.loadSvgIconFromConfig = function (config) {
            var _this = this;
            return this.fetchUrl(config.url).pipe(operators.map(function (svgText) { return _this.createSvgElementForSingleIcon(svgText); }));
        };
        ThyIconRegistry.prototype.loadSvgIconSetFromConfig = function (config) {
            var _this = this;
            // If the SVG for this icon set has already been parsed, do nothing.
            if (config.svgElement) {
                return rxjs.of(config.svgElement);
            }
            return this.fetchUrl(config.url).pipe(operators.map(function (svgText) {
                // It is possible that the icon set was parsed and cached by an earlier request, so parsing
                // only needs to occur if the cache is yet unset.
                if (!config.svgElement) {
                    config.svgElement = _this.svgElementFromString(svgText);
                }
                return config.svgElement;
            }));
        };
        ThyIconRegistry.prototype.getSvgFromConfig = function (config) {
            var _this = this;
            if (config.svgElement) {
                // We already have the SVG element for this icon, return a copy.
                return rxjs.of(this.cloneSvg(config.svgElement));
            }
            else {
                // Fetch the icon from the config's URL, cache it, and return a copy.
                return this.loadSvgIconFromConfig(config).pipe(operators.tap(function (svg) { return (config.svgElement = svg); }), operators.map(function (svg) { return _this.cloneSvg(svg); }));
            }
        };
        ThyIconRegistry.prototype.getSvgFromIconSetConfigs = function (name, iconSetConfigs) {
            var _this = this;
            // For all the icon set SVG elements we've fetched, see if any contain an icon with the
            // requested name.
            var namedIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
            if (namedIcon) {
                // We could cache namedIcon in svgIconConfigs, but since we have to make a copy every
                // time anyway, there's probably not much advantage compared to just always extracting
                // it from the icon set.
                return rxjs.of(namedIcon);
            }
            // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
            // fetched, fetch them now and look for iconName in the results.
            var iconSetFetchRequests = iconSetConfigs
                .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })
                .map(function (iconSetConfig) {
                return _this.loadSvgIconSetFromConfig(iconSetConfig).pipe(operators.catchError(function (err) {
                    var url = _this.sanitizer.sanitize(i0.SecurityContext.RESOURCE_URL, iconSetConfig.url);
                    // Swallow errors fetching individual URLs so the
                    // combined Observable won't necessarily fail.
                    console.error("Loading icon set URL: " + url + " failed: " + err.message);
                    return rxjs.of(null);
                }));
            });
            // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
            // cached SVG element (unless the request failed), and we can check again for the icon.
            return rxjs.forkJoin(iconSetFetchRequests).pipe(operators.map(function () {
                var foundIcon = _this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
                if (!foundIcon) {
                    throw _this.getIconNameNotFoundError(name);
                }
                return foundIcon;
            }));
        };
        ThyIconRegistry.prototype.internalAddSvgIconConfig = function (namespace, iconName, config) {
            this.svgIconConfigs.set(this.buildIconKey(namespace, iconName), config);
            return this;
        };
        ThyIconRegistry.prototype.buildIconKey = function (namespace, name) {
            return namespace + ':' + name;
        };
        ThyIconRegistry.prototype.splitIconName = function (iconName) {
            if (!iconName) {
                return ['', ''];
            }
            var parts = iconName.split(':');
            switch (parts.length) {
                case 1:
                    return ['', parts[0]]; // Use default namespace.
                case 2:
                    return parts;
                default:
                    throw Error("Invalid icon name: \"" + iconName + "\"");
            }
        };
        ThyIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url) {
            return this.internalAddSvgIconSet(namespace, new SvgIconConfig(url));
        };
        ThyIconRegistry.prototype.addSvgIconSet = function (url) {
            return this.addSvgIconSetInNamespace('', url);
        };
        ThyIconRegistry.prototype.addSvgIconSetLiteralInNamespace = function (namespace, literal) {
            var sanitizedLiteral = this.sanitizer.sanitize(i0.SecurityContext.HTML, literal);
            if (!sanitizedLiteral) {
                throw this.getIconFailedToSanitizeLiteralError(literal);
            }
            var svgElement = this.svgElementFromString(sanitizedLiteral);
            return this.internalAddSvgIconSet(namespace, new SvgIconConfig(svgElement));
        };
        ThyIconRegistry.prototype.addSvgIconSetLiteral = function (literal) {
            return this.addSvgIconSetLiteralInNamespace('', literal);
        };
        /**
         * Registers an icon by URL in the specified namespace.
         * @param namespace Namespace in which the icon should be registered.
         * @param iconName Name under which the icon should be registered.
         * @param url
         */
        ThyIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url) {
            return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
        };
        /**
         * Registers an icon by URL in the default namespace.
         * @param iconName Name under which the icon should be registered.
         * @param url
         */
        ThyIconRegistry.prototype.addSvgIcon = function (iconName, url) {
            return this.addSvgIconInNamespace('', iconName, url);
        };
        /**
         * Registers an icon using an HTML string in the default namespace.
         * @param iconName Name under which the icon should be registered.
         * @param literal SVG source of the icon.
         */
        ThyIconRegistry.prototype.addSvgIconLiteral = function (iconName, literal) {
            return this.addSvgIconLiteralInNamespace('', iconName, literal);
        };
        /**
         * Registers an icon using an HTML string in the specified namespace.
         * @param namespace Namespace in which the icon should be registered.
         * @param iconName Name under which the icon should be registered.
         * @param literal SVG source of the icon.
         */
        ThyIconRegistry.prototype.addSvgIconLiteralInNamespace = function (namespace, iconName, literal) {
            var sanitizedLiteral = this.sanitizer.sanitize(i0.SecurityContext.HTML, literal);
            if (!sanitizedLiteral) {
                throw this.getIconFailedToSanitizeLiteralError(literal);
            }
            var svgElement = this.createSvgElementForSingleIcon(sanitizedLiteral);
            return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
        };
        ThyIconRegistry.prototype.getDefaultFontSetClass = function () {
            return this.defaultFontSetClass;
        };
        ThyIconRegistry.prototype.getFontSetClassByAlias = function (fontSet) {
            return fontSet;
        };
        ThyIconRegistry.prototype.getSvgIcon = function (name, namespace) {
            if (namespace === void 0) { namespace = ''; }
            // Return (copy of) cached icon if possible.
            var key = this.buildIconKey(namespace, name);
            var config = this.svgIconConfigs.get(key);
            if (config) {
                return this.getSvgFromConfig(config);
            }
            // See if we have any icon sets registered for the namespace.
            var iconSetConfigs = this.svgIconSetConfigs.get(namespace);
            if (iconSetConfigs) {
                return this.getSvgFromIconSetConfigs(name, iconSetConfigs);
            }
            return rxjs.throwError(this.getIconNameNotFoundError(key));
        };
        ThyIconRegistry.prototype.setIconMode = function (mode) {
            this.internalIconMode = mode;
        };
        return ThyIconRegistry;
    }());
    ThyIconRegistry.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyIconRegistry_Factory() { return new ThyIconRegistry(i0__namespace.ɵɵinject(i1__namespace.DomSanitizer), i0__namespace.ɵɵinject(i2__namespace.HttpClient), i0__namespace.ɵɵinject(i3__namespace.DOCUMENT)); }, token: ThyIconRegistry, providedIn: "root" });
    ThyIconRegistry.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    ThyIconRegistry.ctorParameters = function () { return [
        { type: i1.DomSanitizer },
        { type: i2.HttpClient },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i3.DOCUMENT,] }] }
    ]; };

    var printErrorWhenNotFound = true;
    function setPrintErrorWhenIconNotFound(value) {
        printErrorWhenNotFound = value;
    }
    function getWhetherPrintErrorWhenIconNotFound() {
        return printErrorWhenNotFound;
    }

    var iconSuffixMap = {
        fill: 'fill',
        twotone: 'tt'
    };
    var ThyIconComponent = /** @class */ (function () {
        function ThyIconComponent(updateHostClassService, render, elementRef, iconRegistry) {
            this.updateHostClassService = updateHostClassService;
            this.render = render;
            this.elementRef = elementRef;
            this.iconRegistry = iconRegistry;
            this.className = true;
            this.isInitialized = false;
            this.iconType = 'outline';
            updateHostClassService.initializeElement(elementRef.nativeElement);
        }
        ThyIconComponent.prototype.ngOnInit = function () {
            this.updateClasses();
            this.isInitialized = true;
        };
        ThyIconComponent.prototype.ngOnChanges = function (changes) {
            if (this.isInitialized) {
                if (changes['iconName'] || changes['iconSet'] || changes['iconTwotoneColor'] || changes['iconType']) {
                    this.updateClasses();
                }
                else if (changes['iconRotate']) {
                    this.setStyleRotate();
                }
            }
            if (changes['iconLegging']) {
                if (util.coerceBooleanProperty(this.iconLegging)) {
                    this.updateHostClassService.addClass('thy-icon-legging');
                }
                else {
                    this.updateHostClassService.removeClass('thy-icon-legging');
                }
            }
        };
        ThyIconComponent.prototype.updateClasses = function () {
            var _this = this;
            var _a = __read(this.iconRegistry.splitIconName(this.iconName), 2), namespace = _a[0], iconName = _a[1];
            if (iconName) {
                if (this.iconRegistry.iconMode === 'svg') {
                    this.iconRegistry
                        .getSvgIcon(this.buildIconNameByType(iconName), namespace)
                        .pipe(operators.take(1))
                        .subscribe(function (svg) { return _this.setSvgElement(svg); }, function (error) {
                        if (getWhetherPrintErrorWhenIconNotFound()) {
                            console.error("Error retrieving icon: " + error.message);
                        }
                    });
                    this.updateHostClassService.updateClass([
                        "thy-icon" + (namespace ? "-" + namespace : "") + "-" + this.buildIconNameByType(iconName)
                    ]);
                }
                else {
                    var fontSetClass = this.iconSet
                        ? this.iconRegistry.getFontSetClassByAlias(this.iconSet)
                        : this.iconRegistry.getDefaultFontSetClass();
                    this.updateHostClassService.updateClass([fontSetClass, fontSetClass + "-" + this.iconName]);
                }
            }
        };
        ThyIconComponent.prototype.setStyleRotate = function () {
            if (this.iconRotate !== undefined) {
                this.render.setStyle(this.elementRef.nativeElement.querySelector('svg'), 'transform', "rotate(" + this.iconRotate + "deg)");
            }
        };
        //#region svg element
        ThyIconComponent.prototype.setSvgElement = function (svg) {
            var _this = this;
            this.clearSvgElement();
            // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.
            // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
            // Do this before inserting the element into the DOM, in order to avoid a style recalculation.
            var styleTags = svg.querySelectorAll('style');
            for (var i = 0; i < styleTags.length; i++) {
                styleTags[i].textContent += ' ';
            }
            if (this.iconType === 'twotone') {
                var allPaths = svg.querySelectorAll('path');
                if (allPaths.length > 1) {
                    allPaths.forEach(function (child, index) {
                        if (child.getAttribute('id').includes('secondary-color')) {
                            child.setAttribute('fill', _this.iconTwotoneColor);
                        }
                    });
                }
            }
            // Note: we do this fix here, rather than the icon registry, because the
            // references have to point to the URL at the time that the icon was created.
            // if (this._location) {
            //     const path = this._location.getPathname();
            //     this._previousPath = path;
            //     this._cacheChildrenWithExternalReferences(svg);
            //     this._prependPathToReferences(path);
            // }
            if (this.iconLinearGradient) {
                this.setBaseUrl(svg);
                this.clearTitleElement(svg);
            }
            this.elementRef.nativeElement.appendChild(svg);
            this.setStyleRotate();
        };
        ThyIconComponent.prototype.clearSvgElement = function () {
            var layoutElement = this.elementRef.nativeElement;
            var childCount = layoutElement.childNodes.length;
            // if (this._elementsWithExternalReferences) {
            //     this._elementsWithExternalReferences.clear();
            // }
            // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that
            // we can't use innerHTML, because IE will throw if the element has a data binding.
            while (childCount--) {
                var child = layoutElement.childNodes[childCount];
                // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid
                // of any loose text nodes, as well as any SVG elements in order to remove any old icons.
                if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {
                    layoutElement.removeChild(child);
                }
            }
        };
        //#endregion
        ThyIconComponent.prototype.buildIconNameByType = function (iconName) {
            if (this.iconType && ['fill', 'twotone'].indexOf(this.iconType) >= 0) {
                var suffix = iconSuffixMap[this.iconType];
                return iconName.includes("-" + suffix) ? iconName : iconName + "-" + suffix;
            }
            else {
                return iconName;
            }
        };
        /**
         * Support Safari SVG LinearGradient.
         *
         *
         * @param svg
         */
        ThyIconComponent.prototype.setBaseUrl = function (svg) {
            var styleElements = svg.querySelectorAll('[style]');
            styleElements.forEach(function (n) {
                if (n.style.cssText.includes('url')) {
                    n.style.fill = n.style.fill.replace('url("', 'url("' + location.pathname);
                }
                if (n.style.cssText.includes('clip-path')) {
                    n.style.clipPath = n.style.clipPath.replace('url("', 'url("' + location.pathname);
                }
            });
        };
        ThyIconComponent.prototype.clearTitleElement = function (svg) {
            svg.querySelector('title').remove();
        };
        return ThyIconComponent;
    }());
    ThyIconComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'thy-icon',
                    template: '<ng-content></ng-content>',
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    encapsulation: i0.ViewEncapsulation.None,
                    providers: [core.UpdateHostClassService]
                },] }
    ];
    ThyIconComponent.ctorParameters = function () { return [
        { type: core.UpdateHostClassService },
        { type: i0.Renderer2 },
        { type: i0.ElementRef },
        { type: ThyIconRegistry }
    ]; };
    ThyIconComponent.propDecorators = {
        className: [{ type: i0.HostBinding, args: ['class.thy-icon',] }],
        iconType: [{ type: i0.Input, args: ['thyIconType',] }],
        iconTwotoneColor: [{ type: i0.Input, args: ['thyTwotoneColor',] }],
        iconName: [{ type: i0.Input, args: ['thyIconName',] }],
        iconRotate: [{ type: i0.Input, args: ['thyIconRotate',] }],
        iconSet: [{ type: i0.Input, args: ['thyIconSet',] }],
        iconLegging: [{ type: i0.Input, args: ['thyIconLegging',] }],
        iconLinearGradient: [{ type: i0.Input, args: ['thyIconLinearGradient',] }]
    };

    var ThyIconModule = /** @class */ (function () {
        function ThyIconModule() {
        }
        return ThyIconModule;
    }());
    ThyIconModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [ThyIconComponent],
                    imports: [i3.CommonModule, forms.FormsModule, i2.HttpClientModule],
                    exports: [ThyIconComponent]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ThyIconComponent = ThyIconComponent;
    exports.ThyIconModule = ThyIconModule;
    exports.ThyIconRegistry = ThyIconRegistry;
    exports.getWhetherPrintErrorWhenIconNotFound = getWhetherPrintErrorWhenIconNotFound;
    exports.setPrintErrorWhenIconNotFound = setPrintErrorWhenIconNotFound;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-tethys-icon.umd.js.map
