(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('ngx-tethys/core'),require('@angular/cdk/portal'),require('@angular/cdk/overlay'),require('@angular/cdk/scrolling'),require('@angular/cdk/platform'),require('ngx-tethys/shared'),require('@angular/common'),require('ngx-tethys/empty'),require('@angular/forms'),require('ngx-tethys/input'),require('ngx-tethys/label'),require('ngx-tethys/loading'),require('ngx-tethys/icon'),exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@angular/cdk/overlay'), require('@angular/cdk/coercion'), require('@angular/cdk/portal'), require('ngx-tethys/core'), require('@angular/animations'), require('rxjs/operators'), require('@angular/cdk/bidi'), require('rxjs'), require('@angular/cdk/scrolling'), require('@angular/cdk/platform'), require('ngx-tethys/shared'), require('ngx-tethys/util'), require('ngx-tethys/input'), require('@angular/cdk/collections'), require('@angular/cdk/a11y'), require('ngx-tethys/label'), require('ngx-tethys/loading'), require('ngx-tethys/icon'), require('ngx-tethys/empty')) :
    typeof define === 'function' && define.amd ? define('ngx-tethys/autocomplete', ['@angular/core','ngx-tethys/core','@angular/cdk/portal','@angular/cdk/overlay','@angular/cdk/scrolling','@angular/cdk/platform','ngx-tethys/shared','@angular/common','ngx-tethys/empty','@angular/forms','ngx-tethys/input','ngx-tethys/label','ngx-tethys/loading','ngx-tethys/icon','exports', '@angular/core', '@angular/common', '@angular/forms', '@angular/cdk/overlay', '@angular/cdk/coercion', '@angular/cdk/portal', 'ngx-tethys/core', '@angular/animations', 'rxjs/operators', '@angular/cdk/bidi', 'rxjs', '@angular/cdk/scrolling', '@angular/cdk/platform', 'ngx-tethys/shared', 'ngx-tethys/util', 'ngx-tethys/input', '@angular/cdk/collections', '@angular/cdk/a11y', 'ngx-tethys/label', 'ngx-tethys/loading', 'ngx-tethys/icon', 'ngx-tethys/empty'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ngxTethys.core,global.ng.cdk.portal,global.ng.cdk.overlay,global.ng.cdk.scrolling,global.ng.cdk.platform,global.ngxTethys.shared,global.ng.common,global.ngxTethys.empty,global.ng.forms,global.ngxTethys.input,global.ngxTethys.label,global.ngxTethys.loading,global.ngxTethys.icon,(global['ngx-tethys'] = global['ngx-tethys'] || {}, global['ngx-tethys'].autocomplete = {}), global.ng.core, global.ng.common, global.ng.forms, global.ng.cdk.overlay, global.ng.cdk.coercion, global.ng.cdk.portal, global['ngx-tethys'].core, global.ng.animations, global.rxjs.operators, global.ng.cdk.bidi, global.rxjs, global.ng.cdk.scrolling, global.ng.cdk.platform, global['ngx-tethys'].shared, global['ngx-tethys'].util, global['ngx-tethys'].input, global.ng.cdk.collections, global.ng.cdk.a11y, global['ngx-tethys'].label, global['ngx-tethys'].loading, global['ngx-tethys'].icon, global['ngx-tethys'].empty));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,ɵngcc3,ɵngcc4,ɵngcc5,ɵngcc6,ɵngcc7,ɵngcc8,ɵngcc9,ɵngcc10,ɵngcc11,ɵngcc12,ɵngcc13,exports, i0, i4, forms, i1, coercion, portal, core, animations, operators, bidi, rxjs, i3, i5, shared, util, input, collections, a11y, label, loading, icon, empty) { 
function ThyAutocompleteContainerComponent_ng_template_0_Template(rf, ctx) { }
var _c0 = ["contentTemplate"];
var _c1 = ["panel"];
function ThyAutocompleteComponent_ng_template_0_thy_empty_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "thy-empty", 5);
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("thyMessage", ctx_r3.thyEmptyText);
} }
function ThyAutocompleteComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2, 3);
    ɵngcc0.ɵɵprojection(3);
    ɵngcc0.ɵɵtemplate(4, ThyAutocompleteComponent_ng_template_0_thy_empty_4_Template, 1, 1, "thy-empty", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.dropDownClass);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.isEmptyOptions);
} }
var _c2 = ["*"];
'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i4__namespace = /*#__PURE__*/_interopNamespace(i4);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var ThyAutocompleteConfig = /** @class */ (function (_super) {
        __extends(ThyAutocompleteConfig, _super);
        function ThyAutocompleteConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ThyAutocompleteConfig;
    }(core.ThyAbstractOverlayConfig));
    var THY_AUTOCOMPLETE_DEFAULT_CONFIG = new i0.InjectionToken('thy-autocomplete-default-config');
    var ɵ0 = {
        hasBackdrop: false,
        panelClass: '',
        closeOnNavigation: true,
        insideClosable: true,
        manualClosure: false,
        outsideClosable: true,
        originActiveClass: 'thy-autocomplete-origin-active'
    };
    var THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER = {
        provide: THY_AUTOCOMPLETE_DEFAULT_CONFIG,
        useValue: ɵ0
    };

    var animationBody = [
        animations.state('void, exit', animations.style({ opacity: 0, transform: 'scale(0.1)' })),
        animations.state('enter', animations.style({ transform: 'none' }))
    ];
    /**
     * Animations used by ThyAutocomplete.
     * @docs-private
     */
    var thyAutocompleteAnimations = {
        autocompleteContainer: animations.trigger('autocompleteContainer', animationBody)
    };

    var autocompleteUpperOverlayOptions = {
        name: 'autocomplete',
        animationEnabled: true,
        disposeWhenClose: true
    };

    var ThyAutocompleteContainerComponent = /** @class */ (function (_super) {
        __extends(ThyAutocompleteContainerComponent, _super);
        function ThyAutocompleteContainerComponent(elementRef, document, config, changeDetectorRef, thyClickDispatcher, ngZone) {
            var _this = _super.call(this, autocompleteUpperOverlayOptions, changeDetectorRef) || this;
            _this.elementRef = elementRef;
            _this.document = document;
            _this.config = config;
            _this.thyClickDispatcher = thyClickDispatcher;
            _this.ngZone = ngZone;
            /** State of the autocomplete animation. */
            _this.animationState = 'enter';
            /** Emits when an animation state changes. */
            _this.animationStateChanged = new i0.EventEmitter();
            _this.animationOpeningDone = _this.animationStateChanged.pipe(operators.filter(function (event) {
                return event.phaseName === 'done' && event.toState === 'enter';
            }));
            _this.animationClosingDone = _this.animationStateChanged.pipe(operators.filter(function (event) {
                return event.phaseName === 'done' && event.toState === 'exit';
            }));
            return _this;
        }
        ThyAutocompleteContainerComponent.prototype.beforeAttachPortal = function () { };
        ThyAutocompleteContainerComponent.prototype.ngAfterViewInit = function () { };
        /** Callback, invoked whenever an animation on the host completes. */
        ThyAutocompleteContainerComponent.prototype.onAnimationDone = function (event) {
            this.animationStateChanged.emit(event);
        };
        /** Callback, invoked when an animation on the host starts. */
        ThyAutocompleteContainerComponent.prototype.onAnimationStart = function (event) {
            this.animationStateChanged.emit(event);
        };
        ThyAutocompleteContainerComponent.prototype.startExitAnimation = function () {
            this.animationState = 'exit';
            this.changeDetectorRef.markForCheck();
        };
ThyAutocompleteContainerComponent.ɵfac = function ThyAutocompleteContainerComponent_Factory(t) { return new (t || ThyAutocompleteContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(i4.DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ThyAutocompleteConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ThyClickDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ThyAutocompleteContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyAutocompleteContainerComponent, selectors: [["thy-autocomplete-container"]], viewQuery: function ThyAutocompleteContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(portal.CdkPortalOutlet, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, hostAttrs: ["tabindex", "-1", 1, "thy-autocomplete-container"], hostVars: 2, hostBindings: function ThyAutocompleteContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@autocompleteContainer.start", function ThyAutocompleteContainerComponent_animation_autocompleteContainer_start_HostBindingHandler($event) { return ctx.onAnimationStart($event); })("@autocompleteContainer.done", function ThyAutocompleteContainerComponent_animation_autocompleteContainer_done_HostBindingHandler($event) { return ctx.onAnimationDone($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "autocomplete");
        ɵngcc0.ɵɵsyntheticHostProperty("@autocompleteContainer", ctx.animationState);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function ThyAutocompleteContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ThyAutocompleteContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [ɵngcc2.CdkPortalOutlet], encapsulation: 2, data: { animation: [thyAutocompleteAnimations.autocompleteContainer] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteContainerComponent, [{
        type: i0.Component,
        args: [{
                selector: 'thy-autocomplete-container',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                animations: [thyAutocompleteAnimations.autocompleteContainer],
                host: {
                    class: 'thy-autocomplete-container',
                    tabindex: '-1',
                    '[attr.role]': "'autocomplete'",
                    '[@autocompleteContainer]': 'animationState',
                    '(@autocompleteContainer.start)': 'onAnimationStart($event)',
                    '(@autocompleteContainer.done)': 'onAnimationDone($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: i0.Inject,
                args: [i4.DOCUMENT]
            }] }, { type: ThyAutocompleteConfig }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.ThyClickDispatcher }, { type: ɵngcc0.NgZone }]; }, { portalOutlet: [{
            type: i0.ViewChild,
            args: [portal.CdkPortalOutlet, { static: true }]
        }] }); })();
        return ThyAutocompleteContainerComponent;
    }(core.ThyAbstractOverlayContainer));
    ThyAutocompleteContainerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i4.DOCUMENT,] }] },
        { type: ThyAutocompleteConfig },
        { type: i0.ChangeDetectorRef },
        { type: core.ThyClickDispatcher },
        { type: i0.NgZone }
    ]; };
    ThyAutocompleteContainerComponent.propDecorators = {
        portalOutlet: [{ type: i0.ViewChild, args: [portal.CdkPortalOutlet, { static: true },] }]
    };

    var ThyAutocompleteRef = /** @class */ (function (_super) {
        __extends(ThyAutocompleteRef, _super);
        function ThyAutocompleteRef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ThyAutocompleteRef;
    }(core.ThyAbstractOverlayRef));
    var ThyInternalAutocompleteRef = /** @class */ (function (_super) {
        __extends(ThyInternalAutocompleteRef, _super);
        function ThyInternalAutocompleteRef(overlayRef, containerInstance, config) {
            return _super.call(this, autocompleteUpperOverlayOptions, overlayRef, containerInstance, config) || this;
        }
        /**
         * Updates the autocomplete's position.
         * @param position New autocomplete position.
         */
        ThyInternalAutocompleteRef.prototype.updatePosition = function () {
            this.overlayRef.updatePosition();
            return this;
        };
        return ThyInternalAutocompleteRef;
    }(core.ThyAbstractInternalOverlayRef));

    var ThyAutocompleteService = /** @class */ (function (_super) {
        __extends(ThyAutocompleteService, _super);
        function ThyAutocompleteService(overlay, injector, defaultConfig, scrollDispatcher, ngZone, _viewportRuler, _document, _platform, _overlayContainer) {
            var _this = _super.call(this, autocompleteUpperOverlayOptions, overlay, injector, defaultConfig) || this;
            _this.scrollDispatcher = scrollDispatcher;
            _this.ngZone = ngZone;
            _this._viewportRuler = _viewportRuler;
            _this._document = _document;
            _this._platform = _platform;
            _this._overlayContainer = _overlayContainer;
            _this.ngUnsubscribe$ = new rxjs.Subject();
            _this.originInstancesMap = new Map();
            return _this;
        }
        ThyAutocompleteService.prototype.buildPositionStrategy = function (config) {
            var _this = this;
            var positionStrategy = new i1.FlexibleConnectedPositionStrategy(config.origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
            var positions = core.getFlexiblePositions(config.placement, config.offset, 'thy-autocomplete');
            positionStrategy.withPositions(positions);
            positionStrategy.withGrowAfterOpen(true);
            positionStrategy.positionChanges.pipe(operators.takeUntil(this.ngUnsubscribe$)).subscribe(function (change) {
                if (change.scrollableViewProperties.isOverlayClipped) {
                    // After position changes occur and the overlay is clipped by
                    // a parent scrollable then close the tooltip.
                    _this.ngZone.run(function () { return _this.close(); });
                }
            });
            return positionStrategy;
        };
        ThyAutocompleteService.prototype.buildOverlayConfig = function (config) {
            var strategy = this.buildPositionStrategy(config);
            var overlayConfig = this.buildBaseOverlayConfig(config);
            overlayConfig.positionStrategy = strategy;
            overlayConfig.scrollStrategy = config.scrollStrategy || this.overlay.scrollStrategies.block();
            overlayConfig.width = config.width;
            return overlayConfig;
        };
        ThyAutocompleteService.prototype.attachUpperOverlayContainer = function (overlay, config) {
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            var injector = i0.Injector.create({
                parent: userInjector || this.injector,
                providers: [{ provide: ThyAutocompleteConfig, useValue: config }]
            });
            var containerPortal = new portal.ComponentPortal(ThyAutocompleteContainerComponent, config.viewContainerRef, injector);
            var containerRef = overlay.attach(containerPortal);
            return containerRef.instance;
        };
        ThyAutocompleteService.prototype.createUpperOverlayRef = function (overlayRef, containerInstance, config) {
            return new ThyInternalAutocompleteRef(overlayRef, containerInstance, config);
        };
        ThyAutocompleteService.prototype.createInjector = function (config, autocompleteRef, autocompleteContainer) {
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            var injectionTokens = [
                {
                    provide: ThyAutocompleteContainerComponent,
                    useValue: autocompleteContainer
                },
                {
                    provide: ThyAutocompleteRef,
                    useValue: autocompleteRef
                }
            ];
            if (config.direction && (!userInjector || !userInjector.get(bidi.Directionality, null))) {
                injectionTokens.push({
                    provide: bidi.Directionality,
                    useValue: {
                        value: config.direction,
                        change: rxjs.of()
                    }
                });
            }
            return i0.Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
        };
        ThyAutocompleteService.prototype.originElementAddActiveClass = function (config) {
            var _a;
            if (config.originActiveClass) {
                (_a = coercion.coerceElement(config.origin).classList).add.apply(_a, __spread(coercion.coerceArray(config.originActiveClass)));
            }
        };
        ThyAutocompleteService.prototype.originElementRemoveActiveClass = function (config) {
            var _a;
            if (config.originActiveClass) {
                (_a = coercion.coerceElement(config.origin).classList).remove.apply(_a, __spread(coercion.coerceArray(config.originActiveClass)));
            }
        };
        ThyAutocompleteService.prototype.open = function (componentOrTemplateRef, config) {
            var _this = this;
            var originElement = coercion.coerceElement(config.origin);
            var autocompleteRef = this.openUpperOverlay(componentOrTemplateRef, config);
            config = autocompleteRef.containerInstance.config;
            autocompleteRef.afterClosed().subscribe(function () {
                _this.originElementRemoveActiveClass(config);
                _this.originInstancesMap.delete(originElement);
            });
            this.originElementAddActiveClass(config);
            this.originInstancesMap.set(originElement, {
                config: config,
                autocompleteRef: autocompleteRef
            });
            return autocompleteRef;
        };
        ThyAutocompleteService.prototype.ngOnDestroy = function () {
            this.dispose();
        };
ThyAutocompleteService.ɵfac = function ThyAutocompleteService_Factory(t) { return new (t || ThyAutocompleteService)(ɵngcc0.ɵɵinject(ɵngcc3.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(THY_AUTOCOMPLETE_DEFAULT_CONFIG), ɵngcc0.ɵɵinject(ɵngcc3.ScrollDispatcher), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc4.ViewportRuler), ɵngcc0.ɵɵinject(i4.DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc5.Platform), ɵngcc0.ɵɵinject(ɵngcc3.OverlayContainer)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteService, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc3.Overlay }, { type: ɵngcc0.Injector }, { type: ThyAutocompleteConfig, decorators: [{
                type: i0.Inject,
                args: [THY_AUTOCOMPLETE_DEFAULT_CONFIG]
            }] }, { type: ɵngcc3.ScrollDispatcher }, { type: ɵngcc0.NgZone }, { type: ɵngcc4.ViewportRuler }, { type: undefined, decorators: [{
                type: i0.Inject,
                args: [i4.DOCUMENT]
            }] }, { type: ɵngcc5.Platform }, { type: ɵngcc3.OverlayContainer }]; }, null); })();
        return ThyAutocompleteService;
    }(core.ThyAbstractOverlayService));
    ThyAutocompleteService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ThyAutocompleteService_Factory() { return new ThyAutocompleteService(i0__namespace.ɵɵinject(i1__namespace.Overlay), i0__namespace.ɵɵinject(i0__namespace.INJECTOR), i0__namespace.ɵɵinject(THY_AUTOCOMPLETE_DEFAULT_CONFIG), i0__namespace.ɵɵinject(i3__namespace.ScrollDispatcher), i0__namespace.ɵɵinject(i0__namespace.NgZone), i0__namespace.ɵɵinject(i3__namespace.ViewportRuler), i0__namespace.ɵɵinject(i4__namespace.DOCUMENT), i0__namespace.ɵɵinject(i5__namespace.Platform), i0__namespace.ɵɵinject(i1__namespace.OverlayContainer)); }, token: ThyAutocompleteService, providedIn: "root" });
    ThyAutocompleteService.ctorParameters = function () { return [
        { type: i1.Overlay },
        { type: i0.Injector },
        { type: ThyAutocompleteConfig, decorators: [{ type: i0.Inject, args: [THY_AUTOCOMPLETE_DEFAULT_CONFIG,] }] },
        { type: i1.ScrollDispatcher },
        { type: i0.NgZone },
        { type: i3.ViewportRuler },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i4.DOCUMENT,] }] },
        { type: i5.Platform },
        { type: i1.OverlayContainer }
    ]; };

    var ThyAutocompleteTriggerDirective = /** @class */ (function () {
        function ThyAutocompleteTriggerDirective(elementRef, ngZone, overlay, autocompleteService, viewContainerRef, document, cdr) {
            this.elementRef = elementRef;
            this.ngZone = ngZone;
            this.overlay = overlay;
            this.autocompleteService = autocompleteService;
            this.viewContainerRef = viewContainerRef;
            this.document = document;
            this.cdr = cdr;
            this.closeKeyEventStream = new rxjs.Subject();
            this.panelOpened = false;
            this.thyOffset = 4;
            this.thyPlacement = 'bottomLeft';
        }
        Object.defineProperty(ThyAutocompleteTriggerDirective.prototype, "autocompleteComponent", {
            get: function () {
                return this._autocompleteComponent;
            },
            set: function (data) {
                this._autocompleteComponent = data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThyAutocompleteTriggerDirective.prototype, "autocomplete", {
            set: function (data) {
                util.warnDeprecation("The property thyAutocomplete will be deprecated, please use thyAutocompleteComponent instead.");
                this._autocompleteComponent = data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThyAutocompleteTriggerDirective.prototype, "activeOption", {
            get: function () {
                if (this.autocompleteComponent && this.autocompleteComponent.keyManager) {
                    return this.autocompleteComponent.keyManager.activeItem;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThyAutocompleteTriggerDirective.prototype, "panelClosingActions", {
            get: function () {
                var _this = this;
                return rxjs.merge(this.autocompleteComponent.thyOptionSelected, this.autocompleteComponent.keyManager.tabOut.pipe(operators.filter(function () { return _this.panelOpened; })), this.closeKeyEventStream, this.getOutsideClickStream(), this.overlayRef ? this.overlayRef.detachments().pipe(operators.filter(function () { return _this.panelOpened; })) : rxjs.of()).pipe(
                // Normalize the output so we return a consistent type.
                operators.map(function (event) { return (event instanceof shared.ThyOptionSelectionChangeEvent ? event : null); }));
            },
            enumerable: false,
            configurable: true
        });
        ThyAutocompleteTriggerDirective.prototype.ngOnInit = function () { };
        ThyAutocompleteTriggerDirective.prototype.onFocus = function () {
            if (this.canOpen()) {
                this.openPanel();
            }
        };
        ThyAutocompleteTriggerDirective.prototype.onKeydown = function (event) {
            var keyCode = event.keyCode;
            // Prevent the default action on all escape key presses. This is here primarily to bring IE
            // in line with other browsers. By default, pressing escape on IE will cause it to revert
            // the input value to the one that it had on focus, however it won't dispatch any events
            // which means that the model value will be out of sync with the view.
            if (keyCode === util.ESCAPE) {
                event.preventDefault();
            }
            if (this.activeOption && keyCode === util.ENTER && this.panelOpened) {
                this.activeOption.selectViaInteraction();
                this.resetActiveItem();
                event.preventDefault();
            }
            else if (this.autocompleteComponent) {
                var prevActiveItem = this.autocompleteComponent.keyManager.activeItem;
                var isArrowKey = keyCode === util.UP_ARROW || keyCode === util.DOWN_ARROW;
                if (this.panelOpened || keyCode === util.TAB) {
                    this.autocompleteComponent.keyManager.onKeydown(event);
                }
                else if (isArrowKey && this.canOpen()) {
                    this.openPanel();
                }
                if ((isArrowKey || this.autocompleteComponent.keyManager.activeItem !== prevActiveItem) &&
                    this.autocompleteComponent.keyManager.activeItem) {
                    core.ScrollToService.scrollToElement(this.autocompleteComponent.keyManager.activeItem.element.nativeElement, this.autocompleteComponent.optionsContainer.nativeElement);
                }
            }
        };
        ThyAutocompleteTriggerDirective.prototype.handleInput = function (event) {
            if (this.canOpen() && document.activeElement === event.target) {
                this.openPanel();
            }
        };
        ThyAutocompleteTriggerDirective.prototype.openPanel = function () {
            var _this = this;
            if (this.overlayRef && this.overlayRef.hasAttached()) {
                return;
            }
            var overlayRef = this.createOverlay();
            this.overlayRef = overlayRef;
            overlayRef.keydownEvents().subscribe(function (event) {
                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                if (event.keyCode === util.ESCAPE || (event.keyCode === util.UP_ARROW && event.altKey)) {
                    _this.resetActiveItem();
                    _this.closeKeyEventStream.next();
                    // We need to stop propagation, otherwise the event will eventually
                    // reach the input itself and cause the overlay to be reopened.
                    event.stopPropagation();
                    event.preventDefault();
                }
            });
            this.panelOpened = true;
            this.autocompleteComponent.open();
        };
        ThyAutocompleteTriggerDirective.prototype.closePanel = function () {
            if (this.autocompleteRef) {
                this.autocompleteRef.close();
                this.cdr.detectChanges();
                this.closingActionsSubscription.unsubscribe();
            }
        };
        ThyAutocompleteTriggerDirective.prototype.createOverlay = function () {
            var _this = this;
            var config = Object.assign({
                origin: this.elementRef.nativeElement,
                viewContainerRef: this.viewContainerRef,
                placement: this.thyPlacement,
                offset: this.thyOffset,
                scrollStrategy: this.overlay.scrollStrategies.reposition(),
                width: this.thyAutocompleteWidth || this.elementRef.nativeElement.clientWidth
            });
            this.autocompleteRef = this.autocompleteService.open(this.autocompleteComponent.contentTemplateRef, config);
            this.autocompleteRef.afterClosed().subscribe(function () {
                _this.panelOpened = false;
                _this.autocompleteComponent.close();
            });
            // delay 200ms to prevent emit document click rightnow
            this.autocompleteRef
                .afterOpened()
                .pipe(operators.delay(200))
                .subscribe(function () {
                _this.closingActionsSubscription = _this.subscribeToClosingActions();
            });
            return this.autocompleteRef.getOverlayRef();
        };
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         */
        ThyAutocompleteTriggerDirective.prototype.subscribeToClosingActions = function () {
            var _this = this;
            var firstStable = this.ngZone.onStable.asObservable().pipe(operators.take(1));
            var optionChanges = this.autocompleteComponent.options.changes.pipe(
            // Defer emitting to the stream until the next tick, because changing
            // bindings in here will cause "changed after checked" errors.
            operators.delay(0));
            // When the zone is stable initially, and when the option list changes...
            return (rxjs.merge(firstStable, optionChanges)
                .pipe(
            // create a new stream of panelClosingActions, replacing any previous streams
            // that were created, and flatten it so our stream only emits closing events...
            operators.switchMap(function () {
                _this.resetActiveItem();
                if (_this.panelOpened) {
                    _this.overlayRef.updatePosition();
                }
                return _this.panelClosingActions;
            }), 
            // when the first closing event occurs...
            operators.take(1))
                // set the value, close the panel, and complete.
                .subscribe(function (event) { return _this.setValueAndClose(event); }));
        };
        ThyAutocompleteTriggerDirective.prototype.setValueAndClose = function (event) {
            if (event && event.option) {
                this.setValue(event.option.thyLabelText);
            }
            this.closePanel();
        };
        /** Stream of clicks outside of the autocomplete panel. */
        ThyAutocompleteTriggerDirective.prototype.getOutsideClickStream = function () {
            var _this = this;
            return rxjs.merge(rxjs.fromEvent(this.document, 'click'), rxjs.fromEvent(this.document, 'touchend')).pipe(operators.filter(function (event) {
                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
                // fall back to check the first element in the path of the click event.
                var clickTarget = event.target;
                var formField = null;
                return (_this.panelOpened &&
                    clickTarget !== _this.elementRef.nativeElement &&
                    (!formField || !formField.contains(clickTarget)) &&
                    !!_this.overlayRef &&
                    !_this.overlayRef.overlayElement.contains(clickTarget));
            }));
        };
        ThyAutocompleteTriggerDirective.prototype.setValue = function (value) {
            this.elementRef.nativeElement.value = value;
            this.elementRef.nativeElement.focus();
        };
        ThyAutocompleteTriggerDirective.prototype.canOpen = function () {
            var element = this.elementRef.nativeElement;
            return !element.readOnly && !element.disabled;
        };
        ThyAutocompleteTriggerDirective.prototype.resetActiveItem = function () {
            this.autocompleteComponent.keyManager.setActiveItem(this.autocompleteComponent.thyAutoActiveFirstOption ? 0 : -1);
        };
        ThyAutocompleteTriggerDirective.prototype.destroyPanel = function () {
            if (this.overlayRef) {
                this.closePanel();
                this.overlayRef.dispose();
                this.overlayRef = null;
            }
        };
        ThyAutocompleteTriggerDirective.prototype.ngOnDestroy = function () {
            this.closeKeyEventStream.complete();
            this.destroyPanel();
        };
ThyAutocompleteTriggerDirective.ɵfac = function ThyAutocompleteTriggerDirective_Factory(t) { return new (t || ThyAutocompleteTriggerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay), ɵngcc0.ɵɵdirectiveInject(ThyAutocompleteService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(i4.DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ThyAutocompleteTriggerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyAutocompleteTriggerDirective, selectors: [["input", "thyAutocompleteTrigger", ""], ["textarea", "thyAutocompleteTrigger", ""]], hostVars: 2, hostBindings: function ThyAutocompleteTriggerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function ThyAutocompleteTriggerDirective_input_HostBindingHandler($event) { return ctx.handleInput($event); })("focusin", function ThyAutocompleteTriggerDirective_focusin_HostBindingHandler() { return ctx.onFocus(); })("keydown", function ThyAutocompleteTriggerDirective_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-autocomplete-opened", ctx.panelOpened);
    } }, inputs: { thyOffset: "thyOffset", thyPlacement: "thyPlacement", autocompleteComponent: ["thyAutocompleteComponent", "autocompleteComponent"], autocomplete: ["thyAutocomplete", "autocomplete"], thyAutocompleteWidth: "thyAutocompleteWidth" }, exportAs: ["thyAutocompleteTrigger"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteTriggerDirective, [{
        type: i0.Directive,
        args: [{
                selector: 'input[thyAutocompleteTrigger], textarea[thyAutocompleteTrigger]',
                exportAs: 'thyAutocompleteTrigger',
                host: {
                    '(input)': 'handleInput($event)',
                    '(focusin)': 'onFocus()',
                    '(keydown)': 'onKeydown($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.Overlay }, { type: ThyAutocompleteService }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{
                type: i0.Optional
            }, {
                type: i0.Inject,
                args: [i4.DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { panelOpened: [{
            type: i0.HostBinding,
            args: ["class.thy-autocomplete-opened"]
        }], thyOffset: [{
            type: i0.Input
        }], thyPlacement: [{
            type: i0.Input
        }], autocompleteComponent: [{
            type: i0.Input,
            args: ['thyAutocompleteComponent']
        }], autocomplete: [{
            type: i0.Input,
            args: ['thyAutocomplete']
        }], thyAutocompleteWidth: [{
            type: i0.Input
        }] }); })();
        return ThyAutocompleteTriggerDirective;
    }());
    ThyAutocompleteTriggerDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.NgZone },
        { type: i1.Overlay },
        { type: ThyAutocompleteService },
        { type: i0.ViewContainerRef },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i4.DOCUMENT,] }] },
        { type: i0.ChangeDetectorRef }
    ]; };
    ThyAutocompleteTriggerDirective.propDecorators = {
        panelOpened: [{ type: i0.HostBinding, args: ["class.thy-autocomplete-opened",] }],
        autocompleteComponent: [{ type: i0.Input, args: ['thyAutocompleteComponent',] }],
        autocomplete: [{ type: i0.Input, args: ['thyAutocomplete',] }],
        thyOffset: [{ type: i0.Input }],
        thyAutocompleteWidth: [{ type: i0.Input }],
        thyPlacement: [{ type: i0.Input }]
    };

    var _MixinBase = core.mixinUnsubscribe(core.MixinBase);
    var ThyAutocompleteComponent = /** @class */ (function (_super) {
        __extends(ThyAutocompleteComponent, _super);
        function ThyAutocompleteComponent(ngZone, changeDetectorRef) {
            var _this = _super.call(this) || this;
            _this.ngZone = ngZone;
            _this.changeDetectorRef = changeDetectorRef;
            _this.isMultiple = false;
            _this.mode = '';
            _this.isEmptyOptions = false;
            _this.isOpened = false;
            _this.optionSelectionChanges = rxjs.defer(function () {
                if (_this.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.options.map(function (option) { return option.selectionChange; })));
                }
                return _this.ngZone.onStable.asObservable().pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
            });
            _this.thyEmptyText = '没有任何数据';
            _this.thyOptionSelected = new i0.EventEmitter();
            _this.thyOpened = new i0.EventEmitter();
            _this.thyClosed = new i0.EventEmitter();
            /** Emits whenever an option is activated using the keyboard. */
            _this.thyOptionActivated = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(ThyAutocompleteComponent.prototype, "thyAutoActiveFirstOption", {
            get: function () {
                return this._autoActiveFirstOption;
            },
            set: function (value) {
                this._autoActiveFirstOption = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        ThyAutocompleteComponent.prototype.ngOnInit = function () {
            this.setDropDownClass();
            this.instanceSelectionModel();
        };
        ThyAutocompleteComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this.ngUnsubscribe$)).subscribe(function () {
                _this.resetOptions();
                rxjs.timer().subscribe(function () {
                    _this.isEmptyOptions = _this.options.length <= 0;
                    _this.changeDetectorRef.detectChanges();
                });
                _this.initKeyManager();
            });
        };
        ThyAutocompleteComponent.prototype.initKeyManager = function () {
            var _this = this;
            var changedOrDestroyed$ = rxjs.merge(this.options.changes, this.ngUnsubscribe$);
            this.keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();
            this.keyManager.change.pipe(operators.takeUntil(changedOrDestroyed$)).subscribe(function (index) {
                _this.thyOptionActivated.emit({ source: _this, option: _this.options.toArray()[index] || null });
            });
        };
        ThyAutocompleteComponent.prototype.open = function () {
            this.isOpened = true;
            this.changeDetectorRef.markForCheck();
            this.thyOpened.emit();
        };
        ThyAutocompleteComponent.prototype.close = function () {
            this.isOpened = false;
            this.thyClosed.emit();
        };
        ThyAutocompleteComponent.prototype.resetOptions = function () {
            var _this = this;
            var changedOrDestroyed$ = rxjs.merge(this.options.changes, this.ngUnsubscribe$);
            this.optionSelectionChanges.pipe(operators.takeUntil(changedOrDestroyed$)).subscribe(function (event) {
                _this.onSelect(event.option, event.isUserInput);
            });
        };
        ThyAutocompleteComponent.prototype.instanceSelectionModel = function () {
            if (this.selectionModel) {
                this.selectionModel.clear();
            }
            this.selectionModel = new collections.SelectionModel(this.isMultiple);
            this.selectionModel.changed.pipe(operators.takeUntil(this.ngUnsubscribe$)).subscribe(function (event) {
                event.added.forEach(function (option) { return option.select(); });
                event.removed.forEach(function (option) { return option.deselect(); });
            });
        };
        ThyAutocompleteComponent.prototype.onSelect = function (option, isUserInput) {
            var wasSelected = this.selectionModel.isSelected(option);
            if (option.thyValue == null && !this.isMultiple) {
                option.deselect();
                this.selectionModel.clear();
            }
            else {
                if (wasSelected !== option.selected) {
                    option.selected ? this.selectionModel.select(option) : this.selectionModel.deselect(option);
                }
                if (isUserInput) {
                    this.keyManager.setActiveItem(option);
                }
                // if (this.isMultiple) {
                //     this.sortValues();
                //     if (isUserInput) {
                //         this.focus();
                //     }
                // }
            }
            if (wasSelected !== this.selectionModel.isSelected(option)) {
                this.thyOptionSelected.emit(new shared.ThyOptionSelectionChangeEvent(option, false));
            }
            this.changeDetectorRef.markForCheck();
        };
        ThyAutocompleteComponent.prototype.setDropDownClass = function () {
            var _a;
            var modeClass = '';
            if (this.isMultiple) {
                modeClass = "thy-select-dropdown-" + this.mode;
            }
            else {
                modeClass = "thy-select-dropdown-single";
            }
            this.dropDownClass = (_a = {},
                _a["thy-select-dropdown"] = true,
                _a[modeClass] = true,
                _a);
        };
        ThyAutocompleteComponent.prototype.ngOnDestroy = function () {
            _super.prototype.ngOnDestroy.call(this);
        };
ThyAutocompleteComponent.ɵfac = function ThyAutocompleteComponent_Factory(t) { return new (t || ThyAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ThyAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyAutocompleteComponent, selectors: [["thy-autocomplete"]], contentQueries: function ThyAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, shared.ThyOptionComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, viewQuery: function ThyAutocompleteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionsContainer = _t.first);
    } }, inputs: { thyAutoActiveFirstOption: "thyAutoActiveFirstOption", thyEmptyText: "thyEmptyText" }, outputs: { thyOptionSelected: "thyOptionSelected", thyOpened: "thyOpened", thyClosed: "thyClosed", thyOptionActivated: "thyOptionActivated" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: shared.THY_OPTION_PARENT_COMPONENT,
                useExisting: ThyAutocompleteComponent
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 2, vars: 0, consts: [["contentTemplate", ""], ["thyStopPropagation", "", 3, "ngClass"], [1, "thy-select-dropdown-options"], ["panel", ""], [3, "thyMessage", 4, "ngIf"], [3, "thyMessage"]], template: function ThyAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ThyAutocompleteComponent_ng_template_0_Template, 5, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc6.ThyStopPropagationDirective, ɵngcc7.NgClass, ɵngcc7.NgIf, ɵngcc8.ThyEmptyComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteComponent, [{
        type: i0.Component,
        args: [{
                selector: 'thy-autocomplete',
                template: "<ng-template #contentTemplate>\n  <div thyStopPropagation [ngClass]=\"dropDownClass\">\n    <div #panel class=\"thy-select-dropdown-options\">\n      <ng-content></ng-content>\n      <thy-empty *ngIf=\"isEmptyOptions\" [thyMessage]=\"thyEmptyText\"></thy-empty>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: i0.ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: shared.THY_OPTION_PARENT_COMPONENT,
                        useExisting: ThyAutocompleteComponent
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { thyAutoActiveFirstOption: [{
            type: i0.Input
        }], contentTemplateRef: [{
            type: i0.ViewChild,
            args: ['contentTemplate', { static: true }]
        }], optionsContainer: [{
            type: i0.ViewChild,
            args: ['panel']
        }], options: [{
            type: i0.ContentChildren,
            args: [shared.ThyOptionComponent, { descendants: true }]
        }], thyEmptyText: [{
            type: i0.Input
        }], thyOptionSelected: [{
            type: i0.Output
        }], thyOpened: [{
            type: i0.Output
        }], thyClosed: [{
            type: i0.Output
        }], thyOptionActivated: [{
            type: i0.Output
        }] }); })();
        return ThyAutocompleteComponent;
    }(_MixinBase));
    ThyAutocompleteComponent.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: i0.ChangeDetectorRef }
    ]; };
    ThyAutocompleteComponent.propDecorators = {
        contentTemplateRef: [{ type: i0.ViewChild, args: ['contentTemplate', { static: true },] }],
        optionsContainer: [{ type: i0.ViewChild, args: ['panel',] }],
        options: [{ type: i0.ContentChildren, args: [shared.ThyOptionComponent, { descendants: true },] }],
        thyEmptyText: [{ type: i0.Input }],
        thyAutoActiveFirstOption: [{ type: i0.Input }],
        thyOptionSelected: [{ type: i0.Output }],
        thyOpened: [{ type: i0.Output }],
        thyClosed: [{ type: i0.Output }],
        thyOptionActivated: [{ type: i0.Output }]
    };

    var ThyAutocompleteModule = /** @class */ (function () {
        function ThyAutocompleteModule() {
        }
ThyAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyAutocompleteModule });
ThyAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyAutocompleteModule_Factory(t) { return new (t || ThyAutocompleteModule)(); }, providers: [THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER], imports: [[
            i4.CommonModule,
            forms.FormsModule,
            input.ThyInputModule,
            label.ThyLabelModule,
            i1.OverlayModule,
            portal.PortalModule,
            loading.ThyLoadingModule,
            shared.ThySharedModule,
            icon.ThyIconModule,
            empty.ThyEmptyModule,
            shared.ThyOptionModule
        ], ɵngcc6.ThyOptionModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyAutocompleteModule, { declarations: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent], imports: [ɵngcc7.CommonModule, ɵngcc9.FormsModule, ɵngcc10.ThyInputModule, ɵngcc11.ThyLabelModule, ɵngcc3.OverlayModule, ɵngcc2.PortalModule, ɵngcc12.ThyLoadingModule, ɵngcc6.ThySharedModule, ɵngcc13.ThyIconModule, ɵngcc8.ThyEmptyModule, ɵngcc6.ThyOptionModule], exports: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent, ɵngcc6.ThyOptionModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyAutocompleteModule, [{
        type: i0.NgModule,
        args: [{
                imports: [
                    i4.CommonModule,
                    forms.FormsModule,
                    input.ThyInputModule,
                    label.ThyLabelModule,
                    i1.OverlayModule,
                    portal.PortalModule,
                    loading.ThyLoadingModule,
                    shared.ThySharedModule,
                    icon.ThyIconModule,
                    empty.ThyEmptyModule,
                    shared.ThyOptionModule
                ],
                declarations: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent],
                entryComponents: [ThyAutocompleteContainerComponent],
                exports: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent, shared.ThyOptionModule],
                providers: [THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER]
            }]
    }], function () { return []; }, null); })();
        return ThyAutocompleteModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.THY_AUTOCOMPLETE_DEFAULT_CONFIG = THY_AUTOCOMPLETE_DEFAULT_CONFIG;
    exports.THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER = THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER;
    exports.ThyAutocompleteComponent = ThyAutocompleteComponent;
    exports.ThyAutocompleteConfig = ThyAutocompleteConfig;
    exports.ThyAutocompleteContainerComponent = ThyAutocompleteContainerComponent;
    exports.ThyAutocompleteModule = ThyAutocompleteModule;
    exports.ThyAutocompleteService = ThyAutocompleteService;
    exports.ThyAutocompleteTriggerDirective = ThyAutocompleteTriggerDirective;
    exports.thyAutocompleteAnimations = thyAutocompleteAnimations;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-tethys-autocomplete.umd.js.map