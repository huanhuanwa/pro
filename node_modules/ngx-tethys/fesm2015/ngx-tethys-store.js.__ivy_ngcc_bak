import { InjectionToken, NgModule, NgModuleRef, isDevMode, Injectable } from '@angular/core';
import { __decorate, __metadata } from 'tslib';
import { BehaviorSubject, Subscription, combineLatest, Observable, of, throwError, from } from 'rxjs';
import { switchMap, map, tap, catchError, shareReplay, exhaustMap, distinctUntilChanged } from 'rxjs/operators';
import { helpers, buildReferencesKeyBy, produce, mergeReferences } from 'ngx-tethys/util';

const META_KEY = '__THY_META__';
const ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
const FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
// export type Newable<T> = { new (...args: any[]): T };

class ThyStoreModuleIsNotImported extends Error {
    constructor() {
        super(`You've forgotten to import "ThyStoreModule"!`);
    }
}
let injector = null;
function assertDefined(actual) {
    if (actual == null) {
        throw new ThyStoreModuleIsNotImported();
    }
}
function setInjector(parentInjector) {
    injector = parentInjector;
}
/**
 * Ensure that we don't keep any references in case of the bootstrapped
 * module is destroyed via `NgModuleRef.destroy()`.
 */
function clearInjector() {
    injector = null;
}
function getInjector() {
    assertDefined(injector);
    return injector;
}

class ThyRootStoreModule {
    constructor(ngModuleRef) {
        setInjector(ngModuleRef.injector);
        ngModuleRef.onDestroy(clearInjector);
    }
}
ThyRootStoreModule.decorators = [
    { type: NgModule }
];
ThyRootStoreModule.ctorParameters = () => [
    { type: NgModuleRef }
];
class ThyFeatureStoreModule {
}
ThyFeatureStoreModule.decorators = [
    { type: NgModule }
];
class ThyStoreModule {
    static forRoot(stores = []) {
        return {
            ngModule: ThyRootStoreModule,
            providers: [
                ...stores,
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: stores
                }
            ]
        };
    }
    static forFeature(stores = []) {
        return {
            ngModule: ThyFeatureStoreModule,
            providers: [
                ...stores,
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: stores
                }
            ]
        };
    }
}
ThyStoreModule.decorators = [
    { type: NgModule, args: [{},] }
];

class StorePlugin {
}
function tinyStateVersion() {
    return 'v0.6.0';
}
class ReduxDevtoolsPlugin {
    constructor() {
        this._devTools = null;
        this._window = window;
        if (this._window == null) {
            return;
        }
        const globalDevtools = this._window['__REDUX_DEVTOOLS_EXTENSION__'] ||
            this._window['devToolsExtension'];
        if (!globalDevtools) {
            console.log(`未安装Chrome浏览器的拓展插件: Redux DevTools.`);
            console.log(`插件下载地址: https://www.chromefor.com/redux-devtools_v2-17-0/`);
            return;
        }
        this._devTools = globalDevtools.connect({
            name: `NgxStore ${tinyStateVersion()}`
        });
    }
    handleNewState(actionName, state) {
        if (this.isConnectSuccessed()) {
            this._devTools.send(actionName, state);
        }
    }
    isConnectSuccessed() {
        if (this._devTools === null) {
            return false;
        }
        return true;
    }
}
function getReduxDevToolsPlugin() {
    if (!window[`___ReduxDevtoolsPlugin___`]) {
        window[`___ReduxDevtoolsPlugin___`] = new ReduxDevtoolsPlugin();
    }
    return window[`___ReduxDevtoolsPlugin___`];
}

// @dynamic
class ActionState {
    static changeAction(actionName) {
        this.actionName = actionName;
    }
    static getActionName() {
        return this.actionName;
    }
}
ActionState.actionName = '';

let rootStore;
/**
 * @internal
 */
class RootStore {
    constructor() {
        this.connectSuccessed = false;
        /**
         * 数据流 数据是一个Map，k,v键值对，关键字->状态数据
         */
        this._containers = new BehaviorSubject(new Map());
        this._plugin = getReduxDevToolsPlugin();
        this._combinedStateSubscription = new Subscription();
        if (this._plugin.isConnectSuccessed()) {
            this.connectSuccessed = true;
            this._assignCombinedState(); // 最终调用handleNewState
            console.log(`是否在Angular开发环境：${isDevMode()}, 初始化root-store`);
        }
    }
    _assignCombinedState() {
        this._combinedStateSubscription = this._containers
            .pipe(switchMap(containers => this._getCombinedState(containers)))
            .pipe(map(states => {
            const actionName = ActionState.getActionName();
            const state = states.reduce((acc, curr) => {
                acc[curr.containerName] = curr.state;
                return acc;
            }, {});
            return { state: state, actionName: actionName };
        }))
            .subscribe(c => {
            this._plugin.handleNewState(c.actionName, c.state);
        });
    }
    /**
     * 合并数据流
     * 合并状态数据，把状态数据转换为这样的数据：{ containerName: string, state: any }，并且
     * 通过combineLatest合并成一个数据数据流，这样状态数据只有涉及更新，那么这边就会得到通知
     * @param containers 状态数据的Map
     */
    _getCombinedState(containers) {
        return combineLatest(...Array.from(containers.entries()).map(([containerName, container]) => {
            return container.state$.pipe(map(state => ({ containerName, state })), tap(data => { }));
        }));
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this._combinedStateSubscription.unsubscribe();
    }
    /**
     * @internal
     */
    registerStore(store) {
        if (!this.connectSuccessed) {
            return;
        }
        const containers = new Map(this._containers.value);
        if (containers.has(store.getStoreInstanceId())) {
            throw new Error(`Store: Store with duplicate instance ID found! ${store.getStoreInstanceId()}` +
                ` is already registered. Please check your getStoreInstanceId() methods!`);
        }
        containers.set(store.getStoreInstanceId(), store);
        this._containers.next(containers);
    }
    existStoreInstanceId(instanceId) {
        const containers = new Map(this._containers.value);
        if (containers.has(instanceId)) {
            return true;
        }
        return false;
    }
    /**
     * @internal
     */
    unregisterStore(store) {
        if (!this.connectSuccessed) {
            return;
        }
        const containers = new Map(this._containers.value);
        containers.delete(store.getStoreInstanceId());
        this._containers.next(containers);
    }
}
RootStore.decorators = [
    { type: Injectable }
];
RootStore.ctorParameters = () => [];
function getSingletonRootStore() {
    if (!rootStore) {
        rootStore = new RootStore();
    }
    return rootStore;
}

function findAndCreateStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        const defaultMetadata = {
            actions: {},
            path: null,
            children: [],
            instance: null
        };
        target[META_KEY] = defaultMetadata;
    }
    return target[META_KEY];
}

/**
 * Decorates a method with a action information.
 */
function Action(action) {
    return function (target, name, descriptor) {
        const meta = findAndCreateStoreMetadata(target);
        // default use function name as action type
        if (!action) {
            action = {
                type: name
            };
        }
        // support string for type
        if (typeof action === 'string') {
            action = {
                type: action
            };
        }
        const type = action.type;
        if (!action.type) {
            throw new Error(`Action ${action.type} is missing a static "type" property`);
        }
        const originalFn = descriptor.value;
        meta.actions[type] = {
            fn: name,
            originalFn: originalFn,
            type
        };
        descriptor.value = function (...args) {
            ActionState.changeAction(`${target.constructor.name}-${name}`);
            let result = originalFn.call(this, ...args);
            if (result instanceof Observable) {
                result = result.pipe(catchError(error => {
                    return of({ status: "ERRORED" /* Errored */, action: action, error: error });
                }), shareReplay(), exhaustMap((result) => {
                    if (result && result.status === "ERRORED" /* Errored */) {
                        return throwError(result.error);
                    }
                    else {
                        return of(result);
                    }
                }));
                result.subscribe();
            }
            return result;
        };
    };
}

class Store {
    constructor(initialState) {
        this.reduxToolEnabled = isDevMode();
        this._defaultStoreInstanceId = this._getClassName();
        this.state$ = new BehaviorSubject(initialState);
        this.initialStateCache = Object.assign({}, initialState);
        if (this.reduxToolEnabled) {
            const rootStore = getSingletonRootStore();
            ActionState.changeAction(`Add-${this._defaultStoreInstanceId}`);
            rootStore.registerStore(this);
        }
    }
    get snapshot() {
        return this.state$.getValue();
    }
    dispatch(type, payload) {
        ActionState.changeAction(`${this._defaultStoreInstanceId}-${type}`);
        const result = this._dispatch({
            type: type,
            payload: payload
        });
        result.subscribe();
        return result;
    }
    _dispatch(action) {
        const meta = this[META_KEY];
        if (!meta) {
            throw new Error(`${META_KEY} is not found, current store has not action`);
        }
        const actionMeta = meta.actions[action.type];
        if (!actionMeta) {
            throw new Error(`${action.type} is not found`);
        }
        // let result: any = this[actionMeta.fn](this.snapshot, action.payload);
        let result = actionMeta.originalFn.call(this, this.snapshot, action.payload);
        if (result instanceof Promise) {
            result = from(result);
        }
        if (result instanceof Observable) {
            result = result.pipe(map(r => r));
        }
        else {
            result = new Observable((observer) => {
                observer.next({});
            });
        }
        return result.pipe(shareReplay());
    }
    select(selector) {
        return this.state$.pipe(map(selector), distinctUntilChanged());
    }
    next(state) {
        this.state$.next(state);
    }
    error(error) {
        this.state$.error(error);
    }
    complete() {
        this.state$.complete();
    }
    subscribe(next, error, complete) {
        return this.state$.subscribe(next, error, complete);
    }
    /**
     * set store new state
     *
     * @example
     * this.setState(newState);
     * this.setState({ users: produce(this.snapshot.users).add(user) });
     * this.setState((state) => {
     *    return {
     *        users: produce(state.users).add(user)
     *    }
     * });
     * @param fn
     */
    setState(fn) {
        if (helpers.isFunction(fn)) {
            this.next(Object.assign(Object.assign({}, this.snapshot), fn(this.snapshot)));
        }
        else {
            this.next(Object.assign(Object.assign({}, this.snapshot), fn));
        }
    }
    getState() {
        return this.snapshot;
    }
    clearState() {
        this.setState(this.initialStateCache);
    }
    ngOnDestroy() {
        if (this.reduxToolEnabled) {
            const rootStore = getSingletonRootStore();
            rootStore.unregisterStore(this);
        }
    }
    /**
     * You can override this method if you want to give your container instance a custom id.
     * The returned id must be unique in the application.
     */
    getStoreInstanceId() {
        return this._defaultStoreInstanceId;
    }
    _getClassName() {
        const name = this.constructor.name || /function (.+)\(/.exec(this.constructor + '')[1];
        if (this.reduxToolEnabled) {
            const rootStore = getSingletonRootStore();
            if (!rootStore.existStoreInstanceId(name)) {
                return name;
            }
            let j = 0;
            for (let i = 1; i < 20; i++) {
                if (!rootStore.existStoreInstanceId(`${name}-${i}`)) {
                    j = i;
                    break;
                }
            }
            return `${name}-${j}`;
        }
        return name;
    }
}
Store.decorators = [
    { type: Injectable }
];
Store.ctorParameters = () => [
    { type: undefined }
];
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Store.prototype, "clearState", null);

class EntityStore extends Store {
    constructor(initialState = {
        entities: []
    }, options = { idKey: '_id' }) {
        super(initialState);
        this.entities$ = this.select(state => {
            return state.entities;
        });
        this.entitiesWithRefs$ = this.entities$.pipe(map(entities => {
            if (!entities) {
                return entities;
            }
            return entities.map(entity => {
                const newEntity = Object.assign({}, entity);
                if (this['onCombineRefs']) {
                    if (!newEntity['refs']) {
                        newEntity['refs'] = {};
                    }
                    this['onCombineRefs'](newEntity, this.internalReferencesIdMap, this.snapshot.references);
                }
                else {
                    throw new Error(`onCombineRefs is not empty`);
                }
                return newEntity;
            });
        }));
        this.trackBy = (_index, entity) => {
            return entity[this.options.idKey];
        };
        this.options = Object.assign({ idKey: '_id' }, options);
        if (!this.options.idKey) {
            throw new Error(`idKey is required in EntityStore`);
        }
        this.buildReferencesIdMap();
    }
    get entities() {
        return this.snapshot.entities;
    }
    resetPagination(pagination, count) {
        pagination.count = count;
        // 向上取整 21 / 20 = 1.05 = 2 pageCount is 2
        const pageCount = Math.ceil(pagination.count / pagination.pageSize);
        pagination.pageCount = pageCount;
        this.snapshot.pagination = Object.assign({}, pagination);
    }
    increasePagination(amount) {
        const pagination = this.snapshot.pagination;
        this.resetPagination(pagination, pagination.count + amount);
    }
    decreasePagination(amount) {
        const pagination = this.snapshot.pagination;
        if (pagination) {
            this.resetPagination(pagination, pagination.count - amount);
        }
    }
    buildReferencesIdMap() {
        if (this.snapshot.references) {
            this.internalReferencesIdMap = buildReferencesKeyBy(this.snapshot.references, this.options.referencesIdKeys);
        }
    }
    /**
     *
     * Replace current collection with provided collection
     *
     * @example
     * this.store.initialize([Entity, Entity], pagination: PaginationInfo);
     *
     */
    initialize(entities, pagination) {
        const state = this.snapshot;
        state.entities = entities || [];
        state.pagination = pagination;
        this.next(state);
    }
    /**
     *
     * Replace current collection with provided collection with references
     *
     * @example
     * this.store.initializeWithReferences([Entity, Entity], references: TReferences, pagination: PaginationInfo);
     *
     */
    initializeWithReferences(entities, references, pagination) {
        const state = this.snapshot;
        state.entities = entities || [];
        state.pagination = pagination;
        state.references = references;
        this.buildReferencesIdMap();
        this.next(state);
    }
    /**
     * Add entity or entities for internal
     * @param entity
     * @param references
     * @param addOptions
     */
    addInternal(entity, references, addOptions) {
        const addEntities = helpers.coerceArray(entity);
        if (addEntities.length === 0) {
            return;
        }
        const state = this.snapshot;
        state.entities = produce(state.entities).add(addEntities, addOptions);
        if (state.references) {
            mergeReferences(state.references, references, this.options.referencesIdKeys);
            this.buildReferencesIdMap();
        }
        if (state.pagination) {
            this.increasePagination(addEntities.length);
            if (addOptions && !addOptions.prepend && addOptions.autoGotoLastPage) {
                state.pagination.pageIndex = state.pagination.pageCount;
            }
        }
        this.next(state);
    }
    /**
     * Add an entity or entities to the store.
     *
     * @example
     * this.store.add(Entity);
     * this.store.add([Entity, Entity]);
     * this.store.add(Entity, { prepend: true });
     */
    add(entity, addOptions) {
        this.addInternal(entity, undefined, addOptions);
    }
    /**
     * Add an entity or entities to the store with references.
     *
     * @example
     * this.store.add(Entity);
     * this.store.add([Entity, Entity]);
     * this.store.add(Entity, { prepend: true });
     */
    addWithReferences(entity, references, addOptions) {
        this.addInternal(entity, references, addOptions);
    }
    /**
     *
     * Update an entity or entities in the store.
     *
     * @example
     * this.store.update(3, {
     *   name: 'New Name'
     * }, references);
     *
     *  this.store.update(3, entity => {
     *    return {
     *      ...entity,
     *      name: 'New Name'
     *    }
     *  }, references);
     *
     * this.store.update([1,2,3], {
     *   name: 'New Name'
     * }, references);
     */
    updateInternal(idsOrFn, 
    // | Partial<TState>
    // | ((state: Readonly<TState>) => Partial<TState>)
    // | ((entity: Readonly<TEntity>) => boolean),
    newStateOrFn, references) {
        const ids = helpers.coerceArray(idsOrFn);
        const state = this.snapshot;
        for (let i = 0; i < state.entities.length; i++) {
            const oldEntity = state.entities[i];
            if (ids.indexOf(oldEntity[this.options.idKey]) > -1) {
                const newState = helpers.isFunction(newStateOrFn) ? newStateOrFn(oldEntity) : newStateOrFn;
                state.entities[i] = Object.assign(Object.assign({}, oldEntity), newState);
            }
        }
        state.entities = [...state.entities];
        if (state.references) {
            mergeReferences(state.references, references, this.options.referencesIdKeys);
            this.buildReferencesIdMap();
        }
        this.next(state);
    }
    /**
     *
     * Update an entity or entities in the store with references.
     *
     * @example
     * this.store.update(3, {
     *   name: 'New Name'
     * }, references);
     *
     *  this.store.update(3, entity => {
     *    return {
     *      ...entity,
     *      name: 'New Name'
     *    }
     *  }, references);
     *
     * this.store.update([1,2,3], {
     *   name: 'New Name'
     * }, references);
     */
    update(idsOrFn, newStateOrFn) {
        this.updateInternal(idsOrFn, newStateOrFn, undefined);
    }
    /**
     *
     * Update an entity or entities in the store with references.
     *
     * @example
     * this.store.updateWithReferences(3, {
     *   name: 'New Name'
     * }, references);
     *
     *  this.store.updateWithReferences(3, entity => {
     *    return {
     *      ...entity,
     *      name: 'New Name'
     *    }
     *  }, references);
     *
     * this.store.updateWithReferences([1,2,3], {
     *   name: 'New Name'
     * }, references);
     */
    updateWithReferences(idsOrFn, newStateOrFn, references) {
        this.updateInternal(idsOrFn, newStateOrFn, references);
    }
    remove(idsOrFn) {
        const state = this.snapshot;
        const originalLength = state.entities.length;
        state.entities = produce(state.entities, this.options).remove(idsOrFn);
        this.decreasePagination(originalLength - state.entities.length);
        this.next(state);
    }
    clearPagination() {
        const state = this.snapshot;
        state.pagination = null;
        this.next(state);
    }
    clear() {
        const state = this.snapshot;
        state.entities = [];
        state.pagination = null;
        state.references = null;
        this.next(state);
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { Action, EntityStore, FEATURE_STATE_TOKEN, META_KEY, ROOT_STATE_TOKEN, RootStore, Store, ThyFeatureStoreModule, ThyRootStoreModule, ThyStoreModule, getSingletonRootStore };
//# sourceMappingURL=ngx-tethys-store.js.map
