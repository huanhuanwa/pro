import { Sanitizer } from '@angular/core';
import { inject } from '@angular/core/testing';
import { ThyIconRegistry } from 'ngx-tethys/icon';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * Creates a browser MouseEvent with the specified options.
 * @docs-private
 */
function createMouseEvent(type, clientX = 0, clientY = 0, button = 0, modifiers = {}, relatedTarget) {
    const event = document.createEvent('MouseEvent');
    const originalPreventDefault = event.preventDefault.bind(event);
    // Note: We cannot determine the position of the mouse event based on the screen
    // because the dimensions and position of the browser window are not available
    // To provide reasonable `screenX` and `screenY` coordinates, we simply use the
    // client coordinates as if the browser is opened in fullscreen.
    const screenX = clientX;
    const screenY = clientY;
    event.initMouseEvent(type, 
    /* canBubble */ true, 
    /* cancelable */ true, 
    /* view */ window, 
    /* detail */ 0, 
    /* screenX */ screenX, 
    /* screenY */ screenY, 
    /* clientX */ clientX, 
    /* clientY */ clientY, 
    /* ctrlKey */ !!modifiers.control, 
    /* altKey */ !!modifiers.alt, 
    /* shiftKey */ !!modifiers.shift, 
    /* metaKey */ !!modifiers.meta, 
    /* button */ button, 
    /* relatedTarget */ relatedTarget);
    // `initMouseEvent` doesn't allow us to pass the `buttons` and
    // defaults it to 0 which looks like a fake event.
    defineReadonlyEventProperty(event, 'buttons', 1);
    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
    event.preventDefault = function () {
        defineReadonlyEventProperty(event, 'defaultPrevented', true);
        return originalPreventDefault();
    };
    return event;
}
/**
 * Creates a browser `PointerEvent` with the specified options. Pointer events
 * by default will appear as if they are the primary pointer of their type.
 * https://www.w3.org/TR/pointerevents2/#dom-pointerevent-isprimary.
 *
 * For example, if pointer events for a multi-touch interaction are created, the non-primary
 * pointer touches would need to be represented by non-primary pointer events.
 *
 * @docs-private
 */
function createPointerEvent(type, clientX = 0, clientY = 0, options = { isPrimary: true }) {
    return new PointerEvent(type, Object.assign({ bubbles: true, cancelable: true, view: window, clientX,
        clientY }, options));
}
/**
 * Creates a browser TouchEvent with the specified pointer coordinates.
 * @docs-private
 */
function createTouchEvent(type, pageX = 0, pageY = 0) {
    // In favor of creating events that work for most of the browsers, the event is created
    // as a basic UI Event. The necessary details for the event will be set manually.
    const event = document.createEvent('UIEvent');
    const touchDetails = { pageX, pageY };
    // TS3.6 removes the initUIEvent method and suggests porting to "new UIEvent()".
    event.initUIEvent(type, true, true, window, 0);
    // Most of the browsers don't have a "initTouchEvent" method that can be used to define
    // the touch details.
    defineReadonlyEventProperty(event, 'touches', [touchDetails]);
    defineReadonlyEventProperty(event, 'targetTouches', [touchDetails]);
    defineReadonlyEventProperty(event, 'changedTouches', [touchDetails]);
    return event;
}
/**
 * Creates a keyboard event with the specified key and modifiers.
 * @docs-private
 */
function createKeyboardEvent(type, keyCode = 0, key = '', modifiers = {}) {
    const event = document.createEvent('KeyboardEvent');
    const originalPreventDefault = event.preventDefault.bind(event);
    // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.
    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyEvent.
    if (event.initKeyEvent !== undefined) {
        event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);
    }
    else {
        // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string
        // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent
        let modifiersList = '';
        if (modifiers.control) {
            modifiersList += 'Control ';
        }
        if (modifiers.alt) {
            modifiersList += 'Alt ';
        }
        if (modifiers.shift) {
            modifiersList += 'Shift ';
        }
        if (modifiers.meta) {
            modifiersList += 'Meta ';
        }
        // TS3.6 removed the `initKeyboardEvent` method and suggested porting to
        // `new KeyboardEvent()` constructor. We cannot use that as we support IE11.
        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent.
        event.initKeyboardEvent(type, true /* canBubble */, true /* cancelable */, window /* view */, 0 /* char */, key /* key */, 0 /* location */, modifiersList.trim() /* modifiersList */, false /* repeat */);
    }
    // Webkit Browsers don't set the keyCode when calling the init function.
    // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735
    defineReadonlyEventProperty(event, 'keyCode', keyCode);
    defineReadonlyEventProperty(event, 'key', key);
    defineReadonlyEventProperty(event, 'ctrlKey', !!modifiers.control);
    defineReadonlyEventProperty(event, 'altKey', !!modifiers.alt);
    defineReadonlyEventProperty(event, 'shiftKey', !!modifiers.shift);
    defineReadonlyEventProperty(event, 'metaKey', !!modifiers.meta);
    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
    event.preventDefault = function () {
        defineReadonlyEventProperty(event, 'defaultPrevented', true);
        return originalPreventDefault();
    };
    return event;
}
/**
 * Creates a fake event object with any desired event type.
 * @docs-private
 */
function createFakeEvent(type, canBubble = false, cancelable = true) {
    const event = document.createEvent('Event');
    event.initEvent(type, canBubble, cancelable);
    return event;
}
function createDragEvent(type, dataTransfer = null, canBubble = false, cancelable = true) {
    const event = document.createEvent('DragEvent');
    event.initEvent(type, canBubble, cancelable);
    defineReadonlyEventProperty(event, 'dataTransfer', dataTransfer);
    return event;
}
/**
 * Defines a readonly property on the given event object. Readonly properties on an event object
 * are always set as configurable as that matches default readonly properties for DOM event objects.
 */
function defineReadonlyEventProperty(event, propertyName, value) {
    Object.defineProperty(event, propertyName, { get: () => value, configurable: true });
}

/**
 * Utility to dispatch any event on a Node.
 * @docs-private
 */
function dispatchEvent(node, event) {
    node.dispatchEvent(event);
    return event;
}
/**
 * Shorthand to dispatch a fake event on a specified node.
 * @docs-private
 */
function dispatchFakeEvent(node, type, canBubble) {
    return dispatchEvent(node, createFakeEvent(type, canBubble));
}
/**
 * Shorthand to dispatch a keyboard event with a specified key code and
 * optional modifiers.
 * @docs-private
 */
function dispatchKeyboardEvent(node, type, keyCode, key, modifiers) {
    return dispatchEvent(node, createKeyboardEvent(type, keyCode, key, modifiers));
}
/**
 * Shorthand to dispatch a mouse event on the specified coordinates.
 * @docs-private
 */
function dispatchMouseEvent(node, type, clientX = 0, clientY = 0, button, modifiers, relatedTarget) {
    return dispatchEvent(node, createMouseEvent(type, clientX, clientY, button, modifiers, relatedTarget));
}
/**
 * Shorthand to dispatch a pointer event on the specified coordinates.
 * @docs-private
 */
function dispatchPointerEvent(node, type, clientX = 0, clientY = 0, options) {
    return dispatchEvent(node, createPointerEvent(type, clientX, clientY, options));
}
/**
 * Shorthand to dispatch a touch event on the specified coordinates.
 * @docs-private
 */
function dispatchTouchEvent(node, type, x = 0, y = 0) {
    return dispatchEvent(node, createTouchEvent(type, x, y));
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Patches an elements focus and blur methods to emit events consistently and predictably.
 * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,
 * while others won't fire them at all if the browser window is not focused.
 */
function patchElementFocus(element) {
    element.focus = () => dispatchFakeEvent(element, 'focus');
    element.blur = () => dispatchFakeEvent(element, 'blur');
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Focuses an input, sets its value and dispatches
 * the `input` event, simulating the user typing.
 * @param value Value to be set on the input.
 * @param element Element onto which to set the value.
 */
function typeInElement(value, element) {
    element.focus();
    element.value = value;
    dispatchFakeEvent(element, 'input');
}

const bypassSanitizeProvider = {
    provide: Sanitizer,
    useValue: {
        sanitize: (context, html) => html
    }
};
const defaultInlineIconSet = `
  <svg>
    <defs>
        <svg id="inbox"></svg>
        <svg id="close"></svg>
        <svg id="close-bold"></svg>
        <svg id="calendar-check"></svg>
        <svg id="calendar"></svg>
        <svg id="angle-down"></svg>
        <svg id="check"></svg>
        <svg id="application-fill"></svg>
        <svg id="angle-right"></svg>
        <svg id="minus-circle-fill"></svg>
        <svg id="check-circle-fill"></svg>
        <svg id="waring-fill"></svg>
        <svg id="close-circle-fill"></svg>
        <svg id="question-circle-fill"></svg>
        <svg id="more-bold"></svg>
        <svg id="filter"></svg>
        <svg id="close-circle-bold-fill"></svg>
    </defs>
  </svg>
`;
const defaultSvgHtml = `
<svg viewBox="0 0 16 16" id="close1" xmlns="http://www.w3.org/2000/svg">
   <path d="M7.978 11.997l-.005.006L2.3 6.33l.83-.831 4.848 4.848L12.826 5.5l.83.83-5.673 5.673-.005-.006z"/>
</svg>`;
const injectDefaultSvgIconSet = () => {
    inject([ThyIconRegistry, DomSanitizer], (iconRegistry, domSanitizer) => {
        iconRegistry.addSvgIconSetLiteral(domSanitizer.bypassSecurityTrustHtml(defaultInlineIconSet));
    })();
};

function removeFromArray(array, item) {
    const index = array.indexOf(item);
    if (index >= 0) {
        array.splice(index, 1);
    }
}
class FakeDataTransferItem {
    constructor(file, kind) {
        this.file = file;
        this.kind = kind;
    }
    getAsFile() {
        return this.file;
    }
    getAsString(callback) {
        throw new Error('Method not implemented.');
    }
    webkitGetAsEntry() {
        return this.file;
    }
}
class FakeDataTransfer {
    constructor(files, items) {
        this.dataByFormat = {};
        this.dropEffect = 'none';
        this.effectAllowed = 'all';
        this.types = [];
        this.getData = function (dataFormat) {
            return this.dataByFormat[dataFormat];
        };
        this.setDragImage = function () {
            // don't do anything (the stub just makes sure there is no error thrown if someone tries to call the method)
        };
        this.files = files;
        this.items = items;
    }
    clearData(dataFormat) {
        if (dataFormat) {
            delete this.dataByFormat[dataFormat];
            removeFromArray(this.types, dataFormat);
        }
        else {
            this.dataByFormat = {};
            this.types = [];
        }
    }
    setData(dataFormat, data) {
        this.dataByFormat[dataFormat] = data;
        if (this.types.indexOf(dataFormat) < 0) {
            this.types.push(dataFormat);
        }
        return true;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { FakeDataTransfer, FakeDataTransferItem, bypassSanitizeProvider, createDragEvent, createFakeEvent, createKeyboardEvent, createMouseEvent, createPointerEvent, createTouchEvent, defaultInlineIconSet, defaultSvgHtml, dispatchEvent, dispatchFakeEvent, dispatchKeyboardEvent, dispatchMouseEvent, dispatchPointerEvent, dispatchTouchEvent, injectDefaultSvgIconSet, patchElementFocus, typeInElement };

//# sourceMappingURL=ngx-tethys-testing.js.map