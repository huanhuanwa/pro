import * as i1 from '@angular/cdk/overlay';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { CdkPortalOutlet, ComponentPortal, PortalModule } from '@angular/cdk/portal';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ElementRef, Inject, ChangeDetectorRef, ViewChild, HostBinding, Input, Injector, Injectable, Optional, ContentChild, Output, NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { ThyButtonModule } from 'ngx-tethys/button';
import { ThyFormModule } from 'ngx-tethys/form';
import { ThyIconModule } from 'ngx-tethys/icon';
import { ThySharedModule } from 'ngx-tethys/shared';
import { of } from 'rxjs';
import * as i3 from 'ngx-tethys/core';
import { ThyAbstractOverlayConfig, ThyAbstractOverlayContainer, ThyClickPositioner, ThyAbstractOverlayRef, ThyAbstractInternalOverlayRef, ThyAbstractOverlayService, UpdateHostClassService, ThyTranslate } from 'ngx-tethys/core';
import { state, style, transition, animate, trigger } from '@angular/animations';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { filter, finalize } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from 'ngx-tethys/util';

var ThyDialogSizes;
(function (ThyDialogSizes) {
    ThyDialogSizes["lg"] = "lg";
    ThyDialogSizes["supperLg"] = "supper-lg";
    ThyDialogSizes["maxLg"] = "max-lg";
    ThyDialogSizes["md"] = "md";
    ThyDialogSizes["sm"] = "sm";
    ThyDialogSizes["full"] = "full";
})(ThyDialogSizes || (ThyDialogSizes = {}));
/**
 * Configuration for opening a modal dialog with the ThyDialog service.
 */
class ThyDialogConfig extends ThyAbstractOverlayConfig {
    constructor() {
        super(...arguments);
        /** The ARIA role of the dialog element. */
        this.role = 'dialog';
    }
}
/** Injection token that can be used to specify default dialog options. */
const THY_DIALOG_DEFAULT_OPTIONS = new InjectionToken('thy-dialog-default-options');
const ɵ0 = {
    role: 'dialog',
    hasBackdrop: true,
    backdropClass: '',
    panelClass: '',
    backdropClosable: true,
    closeOnNavigation: true,
    autoFocus: true,
    restoreFocus: true
};
const THY_DIALOG_DEFAULT_OPTIONS_PROVIDER = {
    provide: THY_DIALOG_DEFAULT_OPTIONS,
    useValue: ɵ0
};
class ThyDialogLayoutConfig {
}
const THY_DIALOG_LAYOUT_CONFIG = new InjectionToken('thy-dialog-layout-config');
const ɵ1 = {
    footerAlign: 'left',
    footerDivided: false
};
const THY_DIALOG_LAYOUT_CONFIG_PROVIDER = {
    provide: THY_DIALOG_LAYOUT_CONFIG,
    useValue: ɵ1
};

const animationBody = [
    // Note: The `enter` animation transitions to `transform: none`, because for some reason
    // specifying the transform explicitly, causes IE both to blur the dialog content and
    // decimate the animation performance. Leaving it as `none` solves both issues. translate(-300px,-100px)
    state('void, exit', style({ opacity: 0, transform: 'scale(0.1)' })),
    state('enter', style({ transform: 'none' })),
    transition('* => enter', animate('200ms cubic-bezier(0, 0, 0.57, 1)', style({ transform: 'none', opacity: 1 }))),
    transition('* => exit', animate('150ms cubic-bezier(0.24, 0.18, 0.96, 0.52)', style({ transform: 'scale(0.3)', opacity: 0 })))
];
/**
 * Animations used by MatDialog.
 * @docs-private
 */
const thyDialogAnimations = {
    dialogContainer: trigger('dialogContainer', animationBody)
};
// export const setAnimationStart

const dialogUpperOverlayOptions = {
    name: 'dialog',
    animationEnabled: true,
    disposeWhenClose: true
};

class ThyDialogContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, clickPositioner, focusTrapFactory) {
        super(dialogUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.clickPositioner = clickPositioner;
        this.focusTrapFactory = focusTrapFactory;
        /** State of the dialog animation. */
        this.animationState = 'void';
        /** Emits when an animation state changes. */
        this.animationStateChanged = new EventEmitter();
        /** ID of the element that should be considered as the dialog's label. */
        this.ariaLabelledBy = null;
        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
        this.elementFocusedBeforeDialogWasOpened = null;
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'void';
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
    }
    savePreviouslyFocusedElement() {
        if (this.document) {
            this.elementFocusedBeforeDialogWasOpened = this.document.activeElement;
            // Note that there is no focus method when rendering on the server.
            if (this.elementRef.nativeElement.focus) {
                // Move focus onto the dialog immediately in order to prevent the user from accidentally
                // opening multiple dialogs at the same time. Needs to be async, because the element
                // may not be focusable immediately.
                Promise.resolve().then(() => this.elementRef.nativeElement.focus());
            }
        }
    }
    /** Moves the focus inside the focus trap. */
    trapFocus() {
        const element = this.elementRef.nativeElement;
        if (!this.focusTrap) {
            this.focusTrap = this.focusTrapFactory.create(element);
        }
        // If we were to attempt to focus immediately, then the content of the dialog would not yet be
        // ready in instances where change detection has to run first. To deal with this, we simply
        // wait for the microtask queue to be empty.
        if (this.config.autoFocus) {
            this.focusTrap.focusInitialElementWhenReady();
        }
        else {
            const activeElement = this.document.activeElement;
            // Otherwise ensure that focus is on the dialog container. It's possible that a different
            // component tried to move focus while the open animation was running. See:
            // https://github.com/angular/components/issues/16215. Note that we only want to do this
            // if the focus isn't inside the dialog already, because it's possible that the consumer
            // turned off `autoFocus` in order to move focus themselves.
            if (activeElement !== element && !element.contains(activeElement)) {
                element.focus();
            }
        }
    }
    restoreFocus() {
        const toFocus = this.elementFocusedBeforeDialogWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (this.config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
        if (this.focusTrap) {
            this.focusTrap.destroy();
        }
    }
    setTransformOrigin() {
        this.clickPositioner.runTaskUseLastPosition(lastPosition => {
            if (lastPosition) {
                const containerElement = this.elementRef.nativeElement;
                const transformOrigin = `${lastPosition.x - containerElement.offsetLeft}px ${lastPosition.y -
                    containerElement.offsetTop}px 0px`;
                containerElement.style['transform-origin'] = transformOrigin;
                // 手动修改动画状态为从 void 到 enter, 开启动画
            }
            this.animationState = 'enter';
        });
    }
    beforeAttachPortal() {
        this.setTransformOrigin();
        this.savePreviouslyFocusedElement();
    }
    /** Callback, invoked whenever an animation on the host completes. */
    onAnimationDone(event) {
        if (event.toState === 'void') {
            this.trapFocus();
        }
        else if (event.toState === 'exit') {
            this.restoreFocus();
        }
        this.animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    ngOnDestroy() {
        super.destroy();
    }
}
ThyDialogContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-dialog-container',
                template: `
        <ng-template cdkPortalOutlet></ng-template>
    `,
                // Using OnPush for dialogs caused some sync issues, e.g. custom ngModel can't to detect changes
                // Disabled until we can track them down.
                changeDetection: ChangeDetectionStrategy.Default,
                animations: [thyDialogAnimations.dialogContainer],
                host: {
                    class: 'thy-dialog-container',
                    tabindex: '-1',
                    'aria-modal': 'true',
                    '[attr.id]': 'id',
                    '[attr.role]': 'config.role',
                    '[attr.aria-labelledby]': 'config.ariaLabel ? null : ariaLabelledBy',
                    '[attr.aria-label]': 'config.ariaLabel',
                    '[attr.aria-describedby]': 'config.ariaDescribedBy || null',
                    '[@dialogContainer]': 'animationState',
                    '(@dialogContainer.start)': 'onAnimationStart($event)',
                    '(@dialogContainer.done)': 'onAnimationDone($event)'
                }
            },] }
];
ThyDialogContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThyDialogConfig },
    { type: ChangeDetectorRef },
    { type: ThyClickPositioner },
    { type: FocusTrapFactory }
];
ThyDialogContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }],
    id: [{ type: HostBinding, args: [`attr.id`,] }]
};

class ThyDialogRef extends ThyAbstractOverlayRef {
}
class ThyInternalDialogRef extends ThyAbstractInternalOverlayRef {
    constructor(overlayRef, containerInstance, config) {
        super(dialogUpperOverlayOptions, overlayRef, containerInstance, config);
    }
    /**
     * Updates the dialog's position.
     * @param position New dialog position.
     */
    updatePosition(position) {
        this.updateGlobalPosition(position);
        return this;
    }
    /**
     * Updates the dialog's width and height.
     * @param width New width of the dialog.
     * @param height New height of the dialog.
     */
    updateSizeAndPosition(width = '', height = '', position) {
        this.getPositionStrategy().width(width).height(height);
        this.updatePosition(position);
        return this;
    }
}

const THY_CONFIRM_DEFAULT_OPTIONS = new InjectionToken('thy-confirm-default-options');
const THY_CONFIRM_DEFAULT_OPTIONS_VALUE = {
    title: '确认删除',
    okText: '确认',
    okType: 'danger',
    cancelText: '取消',
    footerAlign: 'left'
};
const THY_CONFIRM_DEFAULT_OPTIONS_PROVIDER = {
    provide: THY_CONFIRM_DEFAULT_OPTIONS,
    useValue: THY_CONFIRM_DEFAULT_OPTIONS_VALUE
};

class ThyConfirmComponent {
    constructor(dialogRef, changeDetectorRef, defaultConfig) {
        this.dialogRef = dialogRef;
        this.changeDetectorRef = changeDetectorRef;
        this.defaultConfig = defaultConfig;
        this.defaultConfig = Object.assign(Object.assign({}, THY_CONFIRM_DEFAULT_OPTIONS_VALUE), this.defaultConfig);
    }
    ngOnInit() {
        this.defaultConfig = Object.assign(Object.assign({}, this.defaultConfig), this.options);
        this.title = this.defaultConfig.title;
        this.content = this.defaultConfig.content;
        this.okText = this.defaultConfig.okText;
        this.okType = this.defaultConfig.okType;
        this.cancelText = this.defaultConfig.cancelText;
        this.okLoadingText = this.defaultConfig.okLoadingText || this.okText;
        this.footerAlign = this.defaultConfig.footerAlign;
    }
    confirm() {
        this.loading = true;
        const result = this.options.onOk();
        if (result && result.subscribe) {
            result
                .pipe(finalize(() => {
                this.loading = false;
                this.changeDetectorRef.markForCheck();
            }))
                .subscribe(success => {
                if (success) {
                    this.close();
                }
            });
        }
        else {
            this.close();
        }
    }
    close() {
        this.dialogRef.close();
    }
    ngOnDestroy() { }
}
ThyConfirmComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-confirm-default',
                template: "<thy-dialog-header [thyTitle]=\"title || 'Install Angular'\" (thyOnClose)=\"close()\"> </thy-dialog-header>\n<thy-dialog-body class=\"thy-form\">\n  <form thyForm name=\"thyConfirm\" thyLayout=\"vertical\">\n    <div class=\"form-group\">\n      <p [innerHTML]=\"content\"></p>\n    </div>\n    <thy-form-group-footer [thyAlign]=\"footerAlign\">\n      <div class=\"thy-confirm-footer\" [ngClass]=\"'thy-confirm-footer-' + footerAlign\">\n        <button [thyButton]=\"okType\" (click)=\"confirm()\" [thyLoading]=\"loading\" [thyLoadingText]=\"okLoadingText\">{{ okText }}</button>\n        <button thyButton=\"link-secondary\" (click)=\"close()\" class=\"thy-confirm-cancel\">{{ cancelText }}</button>\n      </div>\n    </thy-form-group-footer>\n  </form>\n</thy-dialog-body>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ThyConfirmComponent.ctorParameters = () => [
    { type: ThyDialogRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [THY_CONFIRM_DEFAULT_OPTIONS,] }] }
];
ThyConfirmComponent.propDecorators = {
    options: [{ type: Input }]
};

class ThyDialog extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig, clickPositioner) {
        super(dialogUpperOverlayOptions, overlay, injector, defaultConfig);
        clickPositioner.initialize();
    }
    buildOverlayConfig(config) {
        const size = config.size || ThyDialogSizes.md;
        const overlayConfig = this.buildBaseOverlayConfig(config, [`dialog-${size}`]);
        overlayConfig.positionStrategy = this.overlay.position().global();
        overlayConfig.scrollStrategy = config.scrollStrategy || this.overlay.scrollStrategies.block();
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThyDialogConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThyDialogContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalDialogRef(overlayRef, containerInstance, config);
    }
    createInjector(config, dialogRef, dialogContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            { provide: ThyDialogContainerComponent, useValue: dialogContainer },
            {
                provide: ThyDialogRef,
                useValue: dialogRef
            }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    open(componentOrTemplateRef, config) {
        const dialogRef = this.openUpperOverlay(componentOrTemplateRef, config);
        const dialogRefInternal = dialogRef;
        dialogRefInternal.updateSizeAndPosition(dialogRef.containerInstance.config.width, dialogRef.containerInstance.config.height, dialogRef.containerInstance.config.position);
        return dialogRef;
    }
    confirm(options) {
        return this.open(ThyConfirmComponent, {
            initialState: {
                options: options
            }
        });
    }
    getDialogById(id) {
        return this.getUpperOverlayById(id);
    }
    /**
     * Finds the closest ThyDialogRef to an element by looking at the DOM.
     */
    getClosestDialog(element) {
        let parent = element.parentElement;
        while (parent && !parent.classList.contains('thy-dialog-container')) {
            parent = parent.parentElement;
        }
        if (parent && parent.id) {
            return this.getDialogById(parent.id);
        }
        return null;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyDialog.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyDialog_Factory() { return new ThyDialog(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(THY_DIALOG_DEFAULT_OPTIONS, 8), i0.ɵɵinject(i3.ThyClickPositioner)); }, token: ThyDialog, providedIn: "root" });
ThyDialog.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ThyDialog.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThyDialogConfig, decorators: [{ type: Optional }, { type: Inject, args: [THY_DIALOG_DEFAULT_OPTIONS,] }] },
    { type: ThyClickPositioner }
];

class DialogBodyComponent {
    constructor(dialog) {
        this.dialog = dialog;
        this._isDialogBody = true;
        this.thyClearPaddingClassName = false;
    }
    set thyClearPadding(value) {
        this.thyClearPaddingClassName = coerceBooleanProperty(value);
    }
    ngOnInit() { }
}
DialogBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-dialog-body',
                template: '<ng-content></ng-content>',
                // changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'thyDialogBody'
            },] }
];
DialogBodyComponent.ctorParameters = () => [
    { type: ThyDialog }
];
DialogBodyComponent.propDecorators = {
    _isDialogBody: [{ type: HostBinding, args: [`class.dialog-body`,] }],
    thyClearPaddingClassName: [{ type: HostBinding, args: [`class.dialog-body-clear-padding`,] }],
    thyClearPadding: [{ type: Input }]
};

class DialogFooterComponent {
    constructor(dialogLayoutConfig, updateHostClassService, elementRef) {
        this.dialogLayoutConfig = dialogLayoutConfig;
        this.updateHostClassService = updateHostClassService;
        this.elementRef = elementRef;
        this.updateHostClassService.initializeElement(this.elementRef.nativeElement);
        this.divided = this.dialogLayoutConfig.footerDivided;
    }
    set thyDivided(value) {
        this.divided = coerceBooleanProperty(value);
    }
    get align() {
        return !!this.thyAlign ? this.thyAlign : this.dialogLayoutConfig.footerAlign;
    }
    ngOnInit() {
        this.updateHostClassService.updateClassByMap({
            'dialog-footer': true,
            [`dialog-footer-actions-align-${this.align}`]: true,
            'dialog-footer-border-top': this.divided
        });
    }
}
DialogFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-dialog-footer',
                template: "<div class=\"dialog-footer-actions btn-pair\">\n  <ng-content></ng-content>\n</div>\n<div class=\"dialog-footer-description\" *ngIf=\"description\">\n  <ng-container [ngTemplateOutlet]=\"description\"></ng-container>\n</div>\n",
                // changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'thyDialogFooter',
                providers: [UpdateHostClassService]
            },] }
];
DialogFooterComponent.ctorParameters = () => [
    { type: ThyDialogLayoutConfig, decorators: [{ type: Inject, args: [THY_DIALOG_LAYOUT_CONFIG,] }] },
    { type: UpdateHostClassService },
    { type: ElementRef }
];
DialogFooterComponent.propDecorators = {
    description: [{ type: ContentChild, args: ['description',] }],
    thyDivided: [{ type: Input }],
    thyAlign: [{ type: Input }]
};

class DialogHeaderComponent {
    constructor(elementRef, dialog, translate, dialogContainer) {
        this.elementRef = elementRef;
        this.dialog = dialog;
        this.translate = translate;
        this.dialogContainer = dialogContainer;
        this.isDialogHeader = true;
        this.isDialogHeaderLg = false;
        this.thyOnClose = new EventEmitter();
    }
    set thySize(value) {
        this.isDialogHeaderLg = value === 'lg';
    }
    set thyTitleTranslationKey(key) {
        if (key && !this.thyTitle) {
            this.thyTitle = this.translate.instant(key);
        }
    }
    ngOnInit() {
        if (!this.dialogContainer) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the ThyDialogContainerComponent isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the ThyDialogContainerComponent by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            const dialogRef = this.dialog.getClosestDialog(this.elementRef.nativeElement);
            this.dialogContainer = dialogRef ? dialogRef.containerInstance : null;
        }
        // change in next microtask avoid throw ExpressionChangedAfterItHasBeenCheckedError
        // because sub component change parent's HostBinding property (ariaLabelledBy)
        Promise.resolve().then(() => {
            if (this.dialogContainer) {
                this.dialogContainer.ariaLabelledBy = this.thyTitle;
            }
        });
    }
    close(event) {
        if (this.thyOnClose.observers.length > 0) {
            this.thyOnClose.emit(event);
        }
        else {
            this.dialog.close();
        }
    }
}
DialogHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-dialog-header',
                template: "<ng-container *ngIf=\"headerTemplate; else defaultHeader\">\n  <template [ngTemplateOutlet]=\"headerTemplate\"></template>\n</ng-container>\n<ng-template #defaultHeader>\n  <h3 class=\"dialog-title\"><thy-icon [thyIconName]=\"thyIcon\"></thy-icon>{{ thyTitle }}</h3>\n  <button type=\"button\" class=\"close\" (click)=\"close($event)\">\n    <thy-icon thyIconName=\"close-bold\"></thy-icon>\n  </button>\n</ng-template>\n",
                // changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'thyDialogHeader'
            },] }
];
DialogHeaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ThyDialog },
    { type: ThyTranslate },
    { type: ThyDialogContainerComponent, decorators: [{ type: Optional }] }
];
DialogHeaderComponent.propDecorators = {
    isDialogHeader: [{ type: HostBinding, args: [`class.dialog-header`,] }],
    isDialogHeaderLg: [{ type: HostBinding, args: [`class.dialog-header-lg`,] }],
    headerTemplate: [{ type: ContentChild, args: ['dialogHeader',] }],
    thyTitle: [{ type: Input }],
    thySize: [{ type: Input }],
    thyTitleTranslationKey: [{ type: Input }],
    thyIcon: [{ type: Input }],
    thyOnClose: [{ type: Output }]
};

class ThyDialogModule {
}
ThyDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ThyDialogContainerComponent, DialogHeaderComponent, DialogBodyComponent, DialogFooterComponent, ThyConfirmComponent],
                imports: [CommonModule, ThySharedModule, PortalModule, OverlayModule, ThyButtonModule, ThyIconModule, ThyFormModule, FormsModule],
                providers: [ThyDialog, THY_DIALOG_DEFAULT_OPTIONS_PROVIDER, THY_CONFIRM_DEFAULT_OPTIONS_PROVIDER, THY_DIALOG_LAYOUT_CONFIG_PROVIDER],
                entryComponents: [ThyDialogContainerComponent, ThyConfirmComponent],
                exports: [ThyDialogContainerComponent, DialogHeaderComponent, DialogBodyComponent, DialogFooterComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { DialogBodyComponent, DialogFooterComponent, DialogHeaderComponent, THY_CONFIRM_DEFAULT_OPTIONS, THY_CONFIRM_DEFAULT_OPTIONS_PROVIDER, THY_CONFIRM_DEFAULT_OPTIONS_VALUE, THY_DIALOG_DEFAULT_OPTIONS, THY_DIALOG_DEFAULT_OPTIONS_PROVIDER, THY_DIALOG_LAYOUT_CONFIG, THY_DIALOG_LAYOUT_CONFIG_PROVIDER, ThyConfirmComponent as ThyConfirmComponent$1, ThyDialog, ThyDialogConfig, ThyDialogContainerComponent, ThyDialogLayoutConfig, ThyDialogModule, ThyDialogRef, ThyDialogSizes, thyDialogAnimations, ɵ0, ɵ1 };
//# sourceMappingURL=ngx-tethys-dialog.js.map
