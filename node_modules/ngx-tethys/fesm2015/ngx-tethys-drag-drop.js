import * as i0 from '@angular/core';
import { Injectable, InjectionToken, Directive, Inject, Optional, NgZone, ElementRef, Input, HostBinding, EventEmitter, Output, ContentChildren, NgModule } from '@angular/core';
import { coerceElement, coerceBooleanProperty } from '@angular/cdk/coercion';
import { Subject, fromEvent, defer, merge } from 'rxjs';
import { takeUntil, startWith, take, switchMap } from 'rxjs/operators';
import { coerceArray } from 'ngx-tethys/util';
import { DOCUMENT } from '@angular/common';
import { mixinUnsubscribe, MixinBase } from 'ngx-tethys/core';

import * as ɵngcc0 from '@angular/core';
var ThyDropPosition;
(function (ThyDropPosition) {
    ThyDropPosition["in"] = "in";
    ThyDropPosition["before"] = "before";
    ThyDropPosition["after"] = "after";
})(ThyDropPosition || (ThyDropPosition = {}));

const dropPositionClass = {
    [ThyDropPosition.in]: 'thy-drop-position-in',
    [ThyDropPosition.before]: 'thy-drop-position-before',
    [ThyDropPosition.after]: 'thy-drop-position-after'
};
class DragRef {
    constructor(element, drag, container, dragDropService, document, ngZone) {
        this.drag = drag;
        this.container = container;
        this.dragDropService = dragDropService;
        this.document = document;
        this.ngZone = ngZone;
        this.ngUnsubscribe$ = new Subject();
        this.started = new Subject();
        this.ended = new Subject();
        this.overed = new Subject();
        this.dropped = new Subject();
        this.entered = new Subject();
        this.leaved = new Subject();
        this._disabled = false;
        this.withRootElement(element);
    }
    get disabled() {
        return (this.container && this.container.disabled) || this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    withRootElement(rootElement) {
        const element = coerceElement(rootElement);
        this.rootElement = element;
        this.registerDragDropEvents();
        return this;
    }
    withContentElement(contentElement) {
        this.contentElement = coerceElement(contentElement);
        return this;
    }
    withHandles(handleOrHandles) {
        this.handles = coerceArray(handleOrHandles);
        return this;
    }
    registerDragDropEvents() {
        const events = {
            dragstart: this.dragStart,
            dragover: this.dragOver,
            dragend: this.dragEnd,
            drop: this.dragDrop,
            dragleave: this.dragLeave,
            dragenter: (event) => {
                this.entered.next(event);
            },
            mouseover: (event) => {
                this.target = event.target;
            }
        };
        this.ngZone.runOutsideAngular(() => {
            for (const name in events) {
                if (events.hasOwnProperty(name)) {
                    fromEvent(this.rootElement, name)
                        .pipe(takeUntil(this.ngUnsubscribe$))
                        .subscribe(events[name].bind(this));
                }
            }
        });
    }
    dragStart(event) {
        event.stopPropagation();
        const dragStartEvent = {
            event: event,
            item: this.drag.data,
            containerItems: this.container.data,
            currentIndex: this.container.data.indexOf(this.drag.data)
        };
        if (this.disabled || !this.isTriggerHandle() || (this.container.beforeStart && !this.container.beforeStart(dragStartEvent))) {
            event.preventDefault();
            return false;
        }
        this.dragDropService.previousDrag = this.drag;
        this.ngZone.run(() => {
            this.started.next(dragStartEvent);
        });
    }
    isTriggerHandle() {
        if (this.handles && this.handles.length > 0) {
            const targetHandle = this.handles.find(handle => {
                return (!handle.disabled && (handle.element.nativeElement === this.target || handle.element.nativeElement.contains(this.target)));
            });
            return !!targetHandle;
        }
        else {
            return true;
        }
    }
    getPreviousEventData() {
        const previousItem = this.dragDropService.previousDrag.data;
        const previousContainerItems = this.dragDropService.previousDrag.container.data;
        return {
            previousItem: previousItem,
            previousContainerItems: this.dragDropService.previousDrag.container.data,
            previousIndex: previousContainerItems.indexOf(previousItem)
        };
    }
    isContinueDragOver(event, container) {
        if (event.item === event.previousItem && event.position === ThyDropPosition.in) {
            return false;
        }
        if (container && container.beforeOver) {
            return container.beforeOver(event);
        }
        return true;
    }
    dragOver(event) {
        event.stopPropagation();
        event.preventDefault();
        const dropPosition = this.calcDropPosition(event);
        const dragOverEvent = Object.assign({ event: event, item: this.drag.data, containerItems: this.drag.container.data, currentIndex: this.container.data.indexOf(this.drag.data), position: dropPosition }, this.getPreviousEventData());
        if (this.isContinueDragOver(dragOverEvent, this.container)) {
            this.dragOverHandler(dropPosition);
            this.overed.next(dragOverEvent);
        }
    }
    dragOverHandler(position) {
        const element = this.contentElement || this.rootElement;
        if (this.dragDropService.dropPosition !== position) {
            this.clearDragPositionClass();
        }
        element.classList.add(dropPositionClass[position]);
        this.dragDropService.dropPosition = position;
    }
    dragDrop(event) {
        event.stopPropagation();
        this.clearDragPositionClass();
        const dragDropEvent = Object.assign({ event: event, item: this.drag.data, containerItems: this.drag.container.data, currentIndex: this.container.data.indexOf(this.drag.data), position: this.calcDropPosition(event) }, this.getPreviousEventData());
        if (this.dragDropService.previousDrag === this.drag || (this.container.beforeDrop && !this.container.beforeDrop(dragDropEvent))) {
            event.preventDefault();
            return;
        }
        this.ngZone.run(() => {
            this.dropped.next(dragDropEvent);
        });
    }
    dragEnd(event) {
        this.ngZone.run(() => {
            this.ended.next({
                event: event,
                item: this.drag.data,
                containerItems: this.container.data
            });
        });
    }
    dragLeave(event) {
        event.stopPropagation();
        this.clearDragPositionClass();
        this.leaved.next(event);
    }
    clearDragPositionClass() {
        const element = this.contentElement || this.rootElement;
        for (const key in dropPositionClass) {
            if (dropPositionClass[key]) {
                element.classList.remove(dropPositionClass[key]);
            }
        }
    }
    calcDropPosition(event) {
        const sideRange = 0.25;
        const minGap = 2;
        const { clientY } = event;
        const { top, bottom, height } = event.srcElement
            ? event.srcElement.getBoundingClientRect()
            : event.target.getBoundingClientRect();
        const des = Math.max(height * sideRange, minGap);
        if (clientY <= top + des) {
            return ThyDropPosition.before;
        }
        else if (clientY >= bottom - des) {
            return ThyDropPosition.after;
        }
        return ThyDropPosition.in;
    }
    dispose() {
        this.ngUnsubscribe$.complete();
    }
}

class ThyDragDropService {
    constructor() { }
}
ThyDragDropService.ɵfac = function ThyDragDropService_Factory(t) { return new (t || ThyDragDropService)(); };
ThyDragDropService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyDragDropService_Factory() { return new ThyDragDropService(); }, token: ThyDragDropService, providedIn: "root" });
ThyDragDropService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDragDropService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

/**
 * Injection token used to provide the container directive to drag.
 */
const THY_DROP_CONTAINER_DIRECTIVE = new InjectionToken('THY_DROP_CONTAINER_DIRECTIVE');

const _MixinBase$1 = mixinUnsubscribe(MixinBase);
class ThyDragDirective extends _MixinBase$1 {
    constructor(document, container, ngZone, elementRef, service) {
        super();
        this.container = container;
        this.elementRef = elementRef;
        this.isDraggable = true;
        this._disabled = false;
        this.dragRef = new DragRef(elementRef, this, container, service, document, ngZone);
    }
    set dragData(data) {
        this.data = data;
    }
    set disabled(isDisabled) {
        this._disabled = isDisabled;
        if (isDisabled) {
            this.isDraggable = false;
        }
    }
    get disabled() {
        return this._disabled;
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.dragRef.dispose();
    }
}
ThyDragDirective.ɵfac = function ThyDragDirective_Factory(t) { return new (t || ThyDragDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(THY_DROP_CONTAINER_DIRECTIVE, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ThyDragDropService)); };
ThyDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyDragDirective, selectors: [["thy-drag"], ["", "thyDrag", ""]], hostVars: 1, hostBindings: function ThyDragDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("draggable", ctx.isDraggable);
    } }, inputs: { dragData: ["thyDrag", "dragData"], data: ["thyDragData", "data"], disabled: ["thyDragDisabled", "disabled"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
ThyDragDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [THY_DROP_CONTAINER_DIRECTIVE,] }] },
    { type: NgZone },
    { type: ElementRef },
    { type: ThyDragDropService }
];
ThyDragDirective.propDecorators = {
    dragData: [{ type: Input, args: ['thyDrag',] }],
    data: [{ type: Input, args: ['thyDragData',] }],
    isDraggable: [{ type: HostBinding, args: ['attr.draggable',] }],
    disabled: [{ type: Input, args: ['thyDragDisabled',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDragDirective, [{
        type: Directive,
        args: [{ selector: 'thy-drag,[thyDrag]' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [THY_DROP_CONTAINER_DIRECTIVE]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ThyDragDropService }]; }, { isDraggable: [{
            type: HostBinding,
            args: ['attr.draggable']
        }], dragData: [{
            type: Input,
            args: ['thyDrag']
        }], data: [{
            type: Input,
            args: ['thyDragData']
        }], disabled: [{
            type: Input,
            args: ['thyDragDisabled']
        }] }); })();

class ThyDragHandleDirective {
    constructor(element, drag) {
        this.element = element;
        this._disabled = false;
        if (drag) {
            drag.dragRef.withHandles(this);
        }
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
}
ThyDragHandleDirective.ɵfac = function ThyDragHandleDirective_Factory(t) { return new (t || ThyDragHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ThyDragDirective, 8)); };
ThyDragHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyDragHandleDirective, selectors: [["thy-drag-handle"], ["", "thyDragHandle", ""]], inputs: { disabled: ["thyDisabled", "disabled"] } });
ThyDragHandleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThyDragDirective, decorators: [{ type: Optional }] }
];
ThyDragHandleDirective.propDecorators = {
    disabled: [{ type: Input, args: ['thyDisabled',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDragHandleDirective, [{
        type: Directive,
        args: [{
                selector: 'thy-drag-handle,[thyDragHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ThyDragDirective, decorators: [{
                type: Optional
            }] }]; }, { disabled: [{
            type: Input,
            args: ['thyDisabled']
        }] }); })();

class ThyDragContentDirective {
    constructor(element, drag) {
        this.element = element;
        this.contentClass = true;
        if (drag) {
            drag.dragRef.withContentElement(this.element);
        }
    }
}
ThyDragContentDirective.ɵfac = function ThyDragContentDirective_Factory(t) { return new (t || ThyDragContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ThyDragDirective, 8)); };
ThyDragContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyDragContentDirective, selectors: [["thy-drag-content"], ["", "thyDragContent", ""]], hostVars: 2, hostBindings: function ThyDragContentDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-drag-content", ctx.contentClass);
    } } });
ThyDragContentDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThyDragDirective, decorators: [{ type: Optional }] }
];
ThyDragContentDirective.propDecorators = {
    contentClass: [{ type: HostBinding, args: ['class.thy-drag-content',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDragContentDirective, [{
        type: Directive,
        args: [{
                selector: 'thy-drag-content,[thyDragContent]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ThyDragDirective, decorators: [{
                type: Optional
            }] }]; }, { contentClass: [{
            type: HostBinding,
            args: ['class.thy-drag-content']
        }] }); })();

const _MixinBase = mixinUnsubscribe(MixinBase);
class ThyDropContainerDirective extends _MixinBase {
    constructor(ngZone) {
        super();
        this.ngZone = ngZone;
        this.started = new EventEmitter();
        this.ended = new EventEmitter();
        this.overed = new EventEmitter();
        this.dropped = new EventEmitter();
    }
    set dragContainer(data) {
        this.data = data;
    }
    ngOnInit() { }
    ngAfterContentInit() {
        this.draggables.changes.pipe(startWith(null), takeUntil(this.ngUnsubscribe$)).subscribe(() => {
            this.draggableChanges();
        });
    }
    draggableChanges() {
        this.resetDraggableChanges(item => item.dragRef.started).subscribe(event => {
            this.started.emit(event);
        });
        this.resetDraggableChanges(item => item.dragRef.ended).subscribe(event => {
            this.ended.emit(event);
        });
        this.resetDraggableChanges(item => item.dragRef.overed).subscribe(event => {
            this.overed.emit(event);
        });
        this.resetDraggableChanges(item => item.dragRef.dropped).subscribe(event => {
            this.dropped.emit(event);
        });
    }
    resetDraggableChanges(fn) {
        return defer(() => {
            if (this.draggables) {
                return merge(...this.draggables.map(fn));
            }
            return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.resetDraggableChanges.bind(this, fn)));
        }).pipe(takeUntil(merge(this.ngUnsubscribe$, this.draggables.changes)));
    }
}
ThyDropContainerDirective.ɵfac = function ThyDropContainerDirective_Factory(t) { return new (t || ThyDropContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ThyDropContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyDropContainerDirective, selectors: [["thy-drop-container"], ["", "thyDropContainer", ""]], contentQueries: function ThyDropContainerDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ThyDragDirective, false);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draggables = _t);
    } }, inputs: { dragContainer: ["thyDropContainer", "dragContainer"], data: ["thyDropContainerData", "data"], disabled: ["thyDropContainerDisabled", "disabled"], beforeStart: ["thyBeforeDragStart", "beforeStart"], beforeOver: ["thyBeforeDragOver", "beforeOver"], beforeDrop: ["thyBeforeDragDrop", "beforeDrop"] }, outputs: { started: "thyDragStarted", ended: "thyDragEnded", overed: "thyDragOvered", dropped: "thyDragDropped" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: THY_DROP_CONTAINER_DIRECTIVE,
                useExisting: ThyDropContainerDirective
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
ThyDropContainerDirective.ctorParameters = () => [
    { type: NgZone }
];
ThyDropContainerDirective.propDecorators = {
    dragContainer: [{ type: Input, args: ['thyDropContainer',] }],
    data: [{ type: Input, args: ['thyDropContainerData',] }],
    disabled: [{ type: Input, args: ['thyDropContainerDisabled',] }],
    beforeStart: [{ type: Input, args: ['thyBeforeDragStart',] }],
    beforeOver: [{ type: Input, args: ['thyBeforeDragOver',] }],
    beforeDrop: [{ type: Input, args: ['thyBeforeDragDrop',] }],
    started: [{ type: Output, args: ['thyDragStarted',] }],
    ended: [{ type: Output, args: ['thyDragEnded',] }],
    overed: [{ type: Output, args: ['thyDragOvered',] }],
    dropped: [{ type: Output, args: ['thyDragDropped',] }],
    draggables: [{ type: ContentChildren, args: [ThyDragDirective, {
                    descendants: false
                },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDropContainerDirective, [{
        type: Directive,
        args: [{
                selector: 'thy-drop-container,[thyDropContainer]',
                providers: [
                    {
                        provide: THY_DROP_CONTAINER_DIRECTIVE,
                        useExisting: ThyDropContainerDirective
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { started: [{
            type: Output,
            args: ['thyDragStarted']
        }], ended: [{
            type: Output,
            args: ['thyDragEnded']
        }], overed: [{
            type: Output,
            args: ['thyDragOvered']
        }], dropped: [{
            type: Output,
            args: ['thyDragDropped']
        }], dragContainer: [{
            type: Input,
            args: ['thyDropContainer']
        }], data: [{
            type: Input,
            args: ['thyDropContainerData']
        }], disabled: [{
            type: Input,
            args: ['thyDropContainerDisabled']
        }], beforeStart: [{
            type: Input,
            args: ['thyBeforeDragStart']
        }], beforeOver: [{
            type: Input,
            args: ['thyBeforeDragOver']
        }], beforeDrop: [{
            type: Input,
            args: ['thyBeforeDragDrop']
        }], draggables: [{
            type: ContentChildren,
            args: [ThyDragDirective, {
                    descendants: false
                }]
        }] }); })();

class ThyDragDropModule {
}
ThyDragDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyDragDropModule });
ThyDragDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyDragDropModule_Factory(t) { return new (t || ThyDragDropModule)(); }, providers: [], imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyDragDropModule, { declarations: [ThyDropContainerDirective, ThyDragDirective, ThyDragHandleDirective, ThyDragContentDirective], exports: [ThyDropContainerDirective, ThyDragDirective, ThyDragHandleDirective, ThyDragContentDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyDragDropModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [ThyDropContainerDirective, ThyDragDirective, ThyDragHandleDirective, ThyDragContentDirective],
                declarations: [ThyDropContainerDirective, ThyDragDirective, ThyDragHandleDirective, ThyDragContentDirective],
                providers: []
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { DragRef, THY_DROP_CONTAINER_DIRECTIVE, ThyDragContentDirective, ThyDragDirective, ThyDragDropModule, ThyDragDropService, ThyDragHandleDirective, ThyDropContainerDirective, ThyDropPosition };

//# sourceMappingURL=ngx-tethys-drag-drop.js.map