import { Directive, ViewContainerRef, Input, ElementRef, EventEmitter, NgZone, Renderer2, Output, ContentChildren, NgModule, ChangeDetectorRef, HostBinding, Component, ChangeDetectionStrategy, ViewChild, InjectionToken, Optional, Inject, HostListener, ViewEncapsulation, TemplateRef } from '@angular/core';
import { coerceBooleanProperty, keycodes, isUndefinedOrNull, ENTER, SPACE, hasModifierKey } from 'ngx-tethys/util';
import { Subject, Observable, fromEvent, merge, defer } from 'rxjs';
import { takeUntil, startWith, take, switchMap, debounceTime, map } from 'rxjs/operators';
import { CdkDrag } from '@angular/cdk/drag-drop';
import { mixinUnsubscribe, MixinBase, ThyTranslate, UpdateHostClassService, mixinDisabled } from 'ngx-tethys/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ThyIconModule } from 'ngx-tethys/icon';

class ThyTranscludeDirective {
    constructor(viewRef) {
        this.viewRef = viewRef;
    }
    set thyTransclude(templateRef) {
        this._ngTransclude = templateRef;
        if (templateRef) {
            this.viewRef.createEmbeddedView(templateRef);
        }
    }
    get thyTransclude() {
        return this._ngTransclude;
    }
}
ThyTranscludeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyTransclude]'
            },] }
];
ThyTranscludeDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
ThyTranscludeDirective.propDecorators = {
    thyTransclude: [{ type: Input }]
};

class ThyAutofocusDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        // 自动选择，用于只读的 input 输入框，方便复制粘贴
        this._autoSelect = false;
    }
    set thyAutoSelect(value) {
        this._autoSelect = coerceBooleanProperty(value);
    }
    // auto focus current element
    set thyAutofocus(value) {
        if (coerceBooleanProperty(value) !== false) {
            setTimeout(() => {
                this.elementRef.nativeElement.focus();
                if (this._autoSelect && this.elementRef.nativeElement.select) {
                    this.elementRef.nativeElement.select();
                }
            });
        }
    }
}
ThyAutofocusDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[thyAutofocus],textarea[thyAutofocus]'
            },] }
];
ThyAutofocusDirective.ctorParameters = () => [
    { type: ElementRef }
];
ThyAutofocusDirective.propDecorators = {
    thyAutoSelect: [{ type: Input }],
    thyAutofocus: [{ type: Input }]
};

/**
 * 与 (keydown.enter) 区别是支持组合键，当按 Ctrl + Enter 或者 Command + Enter 也会触发
 */
class ThyEnterDirective {
    constructor(ngZone, elementRef, renderer) {
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.thyEnter = new EventEmitter();
    }
    onKeydown(event) {
        const keyCode = event.which || event.keyCode;
        if (keyCode === keycodes.ENTER) {
            this.ngZone.run(() => {
                this.thyEnter.emit(event);
            });
        }
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.renderer.listen(this.elementRef.nativeElement, 'keydown', this.onKeydown.bind(this));
        });
    }
}
ThyEnterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyEnter]'
            },] }
];
ThyEnterDirective.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
ThyEnterDirective.propDecorators = {
    thyEnter: [{ type: Output }]
};

class ThyCtrlEnterDirective {
    constructor(ngZone, elementRef, renderer) {
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.thyCtrlEnter = new EventEmitter();
    }
    onKeydown(event) {
        const keyCode = event.which || event.keyCode;
        if ((event.ctrlKey || event.metaKey) && keyCode === keycodes.ENTER) {
            event.preventDefault();
            this.ngZone.run(() => {
                this.thyCtrlEnter.emit(event);
            });
        }
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.renderer.listen(this.elementRef.nativeElement, 'keydown', this.onKeydown.bind(this));
        });
    }
}
ThyCtrlEnterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyCtrlEnter]'
            },] }
];
ThyCtrlEnterDirective.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
ThyCtrlEnterDirective.propDecorators = {
    thyCtrlEnter: [{ type: Output }]
};

class ThyShowDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.thyShowChange = new EventEmitter();
    }
    unListenDocument() {
        if (this.unListenEvent) {
            this.unListenEvent();
            this.unListenEvent = null;
        }
    }
    set thyShow(condition) {
        if (condition) {
            this.renderer.setStyle(this.elementRef.nativeElement, 'display', 'block');
            setTimeout(() => {
                this.unListenDocument = this.renderer.listen('document', 'click', event => {
                    if (!this.elementRef.nativeElement.contains(event.target)) {
                        this.thyShowChange.emit(false);
                        this.unListenDocument();
                    }
                });
            });
        }
        else {
            this.renderer.setStyle(this.elementRef.nativeElement, 'display', 'none');
            this.unListenDocument();
        }
    }
    ngOnDestroy() {
        this.unListenDocument();
    }
}
ThyShowDirective.decorators = [
    { type: Directive, args: [{ selector: '[thyShow]' },] }
];
ThyShowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ThyShowDirective.propDecorators = {
    thyShowChange: [{ type: Output }],
    thyShow: [{ type: Input }]
};

/**
 * 将来会移动到 thy 组件库中
 */
class ThyStopPropagationDirective {
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._eventName = 'click';
        this.isStopPropagation = true;
    }
    set thyStopPropagation(value) {
        if (value === false || value === 'false') {
            this.isStopPropagation = false;
        }
        else {
            this.isStopPropagation = true;
            this._eventName = value || 'click';
        }
    }
    ngOnInit() {
        if (this.isStopPropagation) {
            this._listener = this._renderer.listen(this._elementRef.nativeElement, this._eventName, ($event) => {
                $event.stopPropagation();
            });
        }
    }
    ngOnDestroy() {
        if (this._listener) {
            this._listener();
        }
    }
}
ThyStopPropagationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyStopPropagation]'
            },] }
];
ThyStopPropagationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ThyStopPropagationDirective.propDecorators = {
    thyStopPropagation: [{ type: Input }]
};

class ThyContextMenuDirective {
    constructor(ngZone, elementRef, renderer) {
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.thyContextMenu = new EventEmitter();
    }
    rightClick(event) {
        event.preventDefault();
        this.ngZone.run(() => {
            this.thyContextMenu.emit(event);
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.renderer.listen(this.elementRef.nativeElement, 'contextmenu', this.rightClick.bind(this));
        });
    }
}
ThyContextMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyContextMenu]'
            },] }
];
ThyContextMenuDirective.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
ThyContextMenuDirective.propDecorators = {
    thyContextMenu: [{ type: Output }]
};

class ThyScrollDirective {
    constructor(elementRef, ngZone) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this._destroyed = new Subject();
        this._enable = true;
        this._initialled = false;
        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll')
            .pipe(takeUntil(this._destroyed))
            .subscribe(observer)));
        this.thyOnScrolled = new EventEmitter();
    }
    set thyEnable(value) {
        this._enable = coerceBooleanProperty(value);
        if (this._initialled) {
            if (this._enable && this._subscription === null) {
                this._subscription = this._elementScrolled.subscribe(() => this.thyOnScrolled.emit(this.elementRef));
            }
            else {
                if (this._subscription) {
                    this._subscription.unsubscribe();
                    this._subscription = null;
                }
            }
        }
    }
    ngOnInit() {
        if (this._enable) {
            this._subscription = this._elementScrolled.subscribe(() => this.thyOnScrolled.emit(this.elementRef));
        }
        this._initialled = true;
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    getElementRef() {
        return this.elementRef;
    }
}
ThyScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyScroll]'
            },] }
];
ThyScrollDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
ThyScrollDirective.propDecorators = {
    thyEnable: [{ type: Input }],
    thyOnScrolled: [{ type: Output }]
};

const _MixinBase$1 = mixinUnsubscribe(MixinBase);
class ThyDragDropDirective extends _MixinBase$1 {
    constructor() {
        super();
    }
    ngAfterContentInit() {
        if (this.draggables) {
            this.draggables.changes.pipe(startWith(this.draggables)).subscribe(() => {
                super.ngOnDestroy();
                this.ngUnsubscribe$ = new Subject();
                merge(...this.draggables.toArray().map(dragRef => {
                    return dragRef.started;
                }))
                    .pipe(takeUntil(this.ngUnsubscribe$))
                    .subscribe(() => {
                    document.body.classList.add('thy-dragging-body');
                });
                merge(...this.draggables.toArray().map(dragRef => dragRef.released))
                    .pipe(takeUntil(this.ngUnsubscribe$))
                    .subscribe(() => {
                    document.body.classList.remove('thy-dragging-body');
                });
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
ThyDragDropDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyDragDrop]'
            },] }
];
ThyDragDropDirective.ctorParameters = () => [];
ThyDragDropDirective.propDecorators = {
    draggables: [{ type: ContentChildren, args: [CdkDrag, { descendants: true },] }]
};

class ThySharedModule {
}
ThySharedModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ThyTranscludeDirective,
                    ThyAutofocusDirective,
                    ThyEnterDirective,
                    ThyCtrlEnterDirective,
                    ThyShowDirective,
                    ThyStopPropagationDirective,
                    ThyContextMenuDirective,
                    ThyScrollDirective,
                    ThyDragDropDirective
                ],
                exports: [
                    ThyTranscludeDirective,
                    ThyAutofocusDirective,
                    ThyEnterDirective,
                    ThyCtrlEnterDirective,
                    ThyShowDirective,
                    ThyStopPropagationDirective,
                    ThyContextMenuDirective,
                    ThyScrollDirective,
                    ThyDragDropDirective
                ],
                providers: []
            },] }
];

const noop = () => { };
const ɵ0 = noop;
class ThyFormCheckBaseComponent {
    constructor(thyTranslate, changeDetectorRef) {
        this.thyTranslate = thyTranslate;
        this.changeDetectorRef = changeDetectorRef;
        // The internal data model
        this._innerValue = null;
        this._disabled = false;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this._isFormCheck = true;
        this._isFormCheckInline = false;
        this._isChecked = false;
    }
    get _isNoText() {
        return this._isFormCheckInline && !this._labelText;
    }
    set thyInline(value) {
        this._isFormCheckInline = coerceBooleanProperty(value);
    }
    set thyLabelText(value) {
        this._labelText = value;
    }
    set thyLabelTextTranslateKey(value) {
        if (value) {
            this._labelText = this.thyTranslate.instant(value);
        }
        else {
            this._labelText = '';
        }
    }
    set thyDisabled(value) {
        this.setDisabledState(coerceBooleanProperty(value));
    }
    writeValue(obj) {
        if (obj !== this._innerValue) {
            this._innerValue = obj;
            this._isChecked = !!this._innerValue;
        }
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
        this.markForCheck();
    }
    updateValue(value) {
        this._innerValue = value;
        this._isChecked = !!this._innerValue;
        this.onChangeCallback(value);
        this.markForCheck();
    }
    change() {
        this.updateValue(!this._innerValue);
    }
    markForCheck() {
        if (this.changeDetectorRef) {
            this.changeDetectorRef.markForCheck();
        }
    }
}
ThyFormCheckBaseComponent.decorators = [
    { type: Directive }
];
ThyFormCheckBaseComponent.ctorParameters = () => [
    { type: ThyTranslate },
    { type: ChangeDetectorRef }
];
ThyFormCheckBaseComponent.propDecorators = {
    _isFormCheck: [{ type: HostBinding, args: ['class.form-check',] }],
    _isFormCheckInline: [{ type: HostBinding, args: ['class.form-check-inline',] }],
    _isChecked: [{ type: HostBinding, args: ['class.form-check-checked',] }],
    _isNoText: [{ type: HostBinding, args: ['class.form-check-inline-no-label-text',] }],
    thyInline: [{ type: Input }],
    thyLabelText: [{ type: Input }],
    thyLabelTextTranslateKey: [{ type: Input }],
    thyDisabled: [{ type: Input }]
};

class ThySelectControlComponent {
    constructor(renderer, element, updateHostClassService) {
        this.renderer = renderer;
        this.element = element;
        this.updateHostClassService = updateHostClassService;
        this.inputValue = '';
        this.isComposing = false;
        this.panelOpened = false;
        this.isMultiple = false;
        this.showSearch = false;
        this.disabled = false;
        this.thyAllowClear = false;
        this.thyPlaceholder = '';
        this.thyOnSearch = new EventEmitter();
        this.thyOnRemove = new EventEmitter();
        this.thyOnClear = new EventEmitter();
        this.updateHostClassService.initializeElement(this.element.nativeElement);
    }
    get thyPanelOpened() {
        return this.panelOpened;
    }
    set thyPanelOpened(value) {
        this.panelOpened = value;
        if (this.panelOpened && this.thyShowSearch) {
            Promise.resolve(null).then(() => {
                this.inputElement.nativeElement.focus();
            });
        }
        if (!this.panelOpened && this.thyShowSearch) {
            Promise.resolve(null).then(() => {
                this.setInputValue('');
            });
        }
        this.setSelectControlClass();
    }
    get thyIsMultiple() {
        return this.isMultiple;
    }
    set thyIsMultiple(value) {
        this.isMultiple = value;
        this.setSelectControlClass();
    }
    get thyShowSearch() {
        return this.showSearch;
    }
    set thyShowSearch(value) {
        this.showSearch = value;
        this.setSelectControlClass();
    }
    get thySelectedOptions() {
        return this.selectedOptions;
    }
    set thySelectedOptions(value) {
        let sameValue = false;
        const oldValue = this.selectedOptions;
        if (this.isMultiple) {
            if (oldValue instanceof Array && value instanceof Array && oldValue.length === value.length) {
                sameValue = value.every((option, index) => option.thyValue === oldValue[index].thyValue);
            }
        }
        else {
            if (oldValue && value) {
                sameValue = oldValue.thyValue === value.thyValue;
            }
        }
        this.selectedOptions = value;
        if (this.panelOpened && this.thyShowSearch) {
            if (!sameValue) {
                Promise.resolve(null).then(() => {
                    this.setInputValue('');
                });
            }
            this.inputElement.nativeElement.focus();
        }
    }
    get thyDisabled() {
        return this.disabled;
    }
    set thyDisabled(value) {
        this.disabled = value;
        this.setSelectControlClass();
    }
    get thySize() {
        return this.size;
    }
    set thySize(value) {
        this.size = value;
        this.setSelectControlClass();
    }
    get selectedValueStyle() {
        let showSelectedValue = false;
        if (this.showSearch) {
            if (this.panelOpened) {
                showSelectedValue = !(this.isComposing || this.inputValue);
            }
            else {
                showSelectedValue = true;
            }
        }
        else {
            showSelectedValue = true;
        }
        return { display: showSelectedValue ? 'block' : 'none' };
    }
    get placeholderStyle() {
        let placeholder = true;
        if (this.isSelectedValue) {
            placeholder = false;
        }
        if (!this.thyPlaceholder) {
            placeholder = false;
        }
        if (this.isComposing || this.inputValue) {
            placeholder = false;
        }
        return { display: placeholder ? 'block' : 'none' };
    }
    get selectedValue() {
        return this.thySelectedOptions;
    }
    get multipleSelectedValue() {
        return this.thySelectedOptions;
    }
    get showClearIcon() {
        return this.thyAllowClear && this.isSelectedValue;
    }
    get isSelectedValue() {
        return ((!this.isMultiple && !isUndefinedOrNull(this.thySelectedOptions)) ||
            (this.isMultiple && this.thySelectedOptions.length > 0));
    }
    ngOnInit() {
        this.setSelectControlClass();
    }
    setSelectControlClass() {
        const modeType = this.isMultiple ? 'multiple' : 'single';
        const selectControlClass = {
            [`form-control`]: true,
            [`form-control-${this.thySize}`]: !!this.thySize,
            [`form-control-custom`]: true,
            [`select-control`]: true,
            [`select-control-${modeType}`]: true,
            [`select-control-show-search`]: this.showSearch,
            [`panel-is-opened`]: this.panelOpened,
            [`disabled`]: this.disabled
        };
        this.updateHostClassService.updateClassByMap(selectControlClass);
        this.searchInputControlClass = {
            [`form-control`]: true,
            [`form-control-${this.thySize}`]: !!this.thySize,
            [`search-input-field`]: true,
            [`hidden`]: !this.thyShowSearch
        };
        this.choiceContentClass = {
            [`choice-content`]: true,
            [`text-truncate`]: true,
            [`font-size-${this.thySize}`]: !!this.thySize
        };
    }
    setInputValue(value) {
        if (value !== this.inputValue) {
            this.inputValue = value;
            this.updateWidth();
            this.thyOnSearch.emit(this.inputValue);
        }
    }
    handleBackspace(event) {
        if (event.isComposing) {
            return;
        }
        if (this.inputValue.length === 0 && this.selectedOptions instanceof Array) {
            if (this.selectedOptions.length > 0) {
                this.removeHandle(this.selectedOptions[this.selectedOptions.length - 1], event);
            }
        }
    }
    updateWidth() {
        if (this.isMultiple && this.thyShowSearch) {
            if (this.inputValue || this.isComposing) {
                this.renderer.setStyle(this.inputElement.nativeElement, 'width', `${this.inputElement.nativeElement.scrollWidth}px`);
            }
            else {
                this.renderer.removeStyle(this.inputElement.nativeElement, 'width');
            }
        }
    }
    removeHandle(item, $event) {
        this.thyOnRemove.emit({ item: item, $eventOrigin: $event });
    }
    clearHandle($event) {
        this.thyOnClear.emit($event);
    }
    trackValue(_index, option) {
        return option.thyValue;
    }
}
ThySelectControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-select-control,[thySelectControl]',
                template: "<ng-template #inputTemplate>\n  <input\n    #inputElement\n    (compositionstart)=\"isComposing = true\"\n    (compositionend)=\"isComposing = false\"\n    autocomplete=\"something-new\"\n    [ngClass]=\"searchInputControlClass\"\n    (input)=\"updateWidth()\"\n    [ngModel]=\"inputValue\"\n    (ngModelChange)=\"setInputValue($event)\"\n    (keydown.backspace)=\"handleBackspace($event)\"\n    [disabled]=\"thyDisabled\"\n  />\n</ng-template>\n\n<div class=\"select-control-rendered\">\n  <div class=\"text-placeholder text-truncate\" *ngIf=\"!isSelectedValue\" [ngStyle]=\"placeholderStyle\">\n    {{ thyPlaceholder }}\n  </div>\n  <ng-container *ngIf=\"isMultiple; else single\">\n    <ul>\n      <li class=\"choice\" *ngFor=\"let item of multipleSelectedValue; trackBy: trackValue\">\n        <div [ngClass]=\"choiceContentClass\">\n          <ng-template\n            #customDisplay\n            [ngTemplateOutlet]=\"customDisplayTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: item.thyRawValue || item.thyValue || item }\"\n          ></ng-template>\n          <ng-container *ngIf=\"!customDisplayTemplate; else customDisplay\">\n            {{ item.thyLabelText }}\n          </ng-container>\n        </div>\n        <span class=\"choice-remove font-size-base\" (click)=\"removeHandle(item, $event)\">\n          <thy-icon thyIconName=\"close\" class=\"font-size-sm\"></thy-icon>\n        </span>\n      </li>\n      <li class=\"select-control-search\">\n        <ng-template [ngTemplateOutlet]=\"inputTemplate\"></ng-template>\n      </li>\n    </ul>\n  </ng-container>\n  <ng-template #single>\n    <ng-container *ngIf=\"isSelectedValue\">\n      <div class=\"selected-value text-truncate\" [ngStyle]=\"selectedValueStyle\">\n        <ng-template\n          #customDisplay\n          [ngTemplateOutlet]=\"customDisplayTemplate\"\n          [ngTemplateOutletContext]=\"{\n            $implicit: selectedValue.thyRawValue || selectedValue.thyValue || selectedValue\n          }\"\n        ></ng-template>\n        <ng-container *ngIf=\"!customDisplayTemplate; else customDisplay\">\n          {{ selectedValue?.thyLabelText }}\n        </ng-container>\n      </div>\n    </ng-container>\n    <div class=\"select-control-search\">\n      <ng-template [ngTemplateOutlet]=\"inputTemplate\"></ng-template>\n    </div>\n  </ng-template>\n</div>\n<span class=\"select-control-arrow\">\n  <thy-icon thyIconName=\"angle-down\" class=\"font-size-base\"></thy-icon>\n</span>\n<span class=\"select-control-clear remove-link\" *ngIf=\"showClearIcon\" (click)=\"clearHandle($event)\">\n  <thy-icon class=\"remove-link-icon font-size-base\" thyIconName=\"close-circle-bold-fill\"></thy-icon>\n</span>\n",
                providers: [UpdateHostClassService],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ThySelectControlComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: UpdateHostClassService }
];
ThySelectControlComponent.propDecorators = {
    thyPanelOpened: [{ type: Input }],
    thyIsMultiple: [{ type: Input }],
    thyShowSearch: [{ type: Input }],
    thySelectedOptions: [{ type: Input }],
    thyDisabled: [{ type: Input }],
    customDisplayTemplate: [{ type: Input }],
    thyAllowClear: [{ type: Input }],
    thyPlaceholder: [{ type: Input }],
    thySize: [{ type: Input }],
    thyOnSearch: [{ type: Output }],
    thyOnRemove: [{ type: Output }],
    thyOnClear: [{ type: Output }],
    inputElement: [{ type: ViewChild, args: ['inputElement',] }]
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ThySelectCommonModule {
}
ThySelectCommonModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ThyIconModule],
                exports: [ThySelectControlComponent],
                declarations: [ThySelectControlComponent]
            },] }
];

/**
 * Injection token used to provide the parent component to options.
 */
const THY_OPTION_PARENT_COMPONENT = new InjectionToken('THY_OPTION_PARENT_COMPONENT');
/**
 * Injection token used to provide the parent component to options.
 */
const THY_OPTION_GROUP_COMPONENT = new InjectionToken('THY_OPTION_GROUP_COMPONENT');
/**
 * Injection token used to provide the parent component to options.
 */
const THY_LIST_OPTION_PARENT_COMPONENT = new InjectionToken('THY_LIST_OPTION_PARENT_COMPONENT');

let _uniqueIdCounter = 0;
class ThyListOptionComponent {
    constructor(element, changeDetector, 
    /** @docs-private */
    parentSelectionList) {
        this.element = element;
        this.changeDetector = changeDetector;
        this.parentSelectionList = parentSelectionList;
        this._role = 'option';
        this._tabIndex = -1;
        this.id = `thy-list-option-${_uniqueIdCounter++}`;
    }
    get _isListOption() {
        return this.parentSelectionList.layout === 'list';
    }
    get _parentLayout() {
        return this.parentSelectionList.layout === 'grid';
    }
    set thyDisabled(value) {
        this.disabled = coerceBooleanProperty(value);
    }
    /** Whether the option is selected. */
    get selected() {
        return this.parentSelectionList.isSelected(this);
    }
    onClick(event) {
        if (this.parentSelectionList.multiple || !this.parentSelectionList.isSelected(this)) {
            this.parentSelectionList.toggleOption(this, event);
            this.parentSelectionList.setActiveOption(this);
        }
    }
    // @HostListener('focus', ['$event'])
    // onFocus(event: Event) {
    //     this.parentSelectionList.setFocusedOption(this, event);
    // }
    /** Allows for programmatic focusing of the option. */
    // focus(origin?: FocusOrigin): void {
    //     this.element.nativeElement.focus();
    // }
    setActiveStyles() {
        this.element.nativeElement.classList.add('hover');
        this.parentSelectionList.scrollIntoView(this);
    }
    setInactiveStyles() {
        this.element.nativeElement.classList.remove('hover');
    }
    /**
     * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
     * @docs-private
     */
    getLabel() {
        return '';
    }
}
ThyListOptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-list-option,[thy-list-option]',
                template: "<ng-content></ng-content>\n<span class=\"checked-icon\" *ngIf=\"parentSelectionList.multiple && parentSelectionList.layout === 'list'\">\n  <thy-icon thyIconName=\"check\"></thy-icon>\n</span>\n<span *ngIf=\"parentSelectionList.layout === 'grid'\" class=\"checked-icon\">\n  <thy-icon thyIconName=\"check-circle-fill\"></thy-icon>\n</span>\n"
            },] }
];
ThyListOptionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [THY_LIST_OPTION_PARENT_COMPONENT,] }] }
];
ThyListOptionComponent.propDecorators = {
    _isListOption: [{ type: HostBinding, args: [`class.thy-list-option`,] }],
    _parentLayout: [{ type: HostBinding, args: [`class.thy-grid-option`,] }],
    _role: [{ type: HostBinding, args: [`attr.role`,] }],
    _tabIndex: [{ type: HostBinding, args: [`attr.tabindex`,] }],
    id: [{ type: Input }],
    thyValue: [{ type: Input }],
    thyDisabled: [{ type: Input }],
    disabled: [{ type: HostBinding, args: [`class.disabled`,] }],
    selected: [{ type: HostBinding, args: [`class.active`,] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

const _MixinBase = mixinDisabled(MixinBase);
class ThyOptionGroupComponent extends _MixinBase {
    set thyDisabled(value) {
        this.thyDisabled = value;
    }
}
ThyOptionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-list-option-group,[thy-list-option-group]',
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];

class SelectOptionBase {
}

class ThyOptionSelectionChangeEvent {
    constructor(option, isUserInput = false) {
        this.option = option;
        this.isUserInput = isUserInput;
    }
}
class ThyOptionVisibleChangeEvent {
}
class ThyOptionComponent extends SelectOptionBase {
    constructor(element, parent, group, cdr) {
        super();
        this.element = element;
        this.parent = parent;
        this.group = group;
        this.cdr = cdr;
        this._selected = false;
        this._hidden = false;
        this._disabled = false;
        this._isOptionItem = true;
        this.selectionChange = new EventEmitter();
        this.visibleChange = new EventEmitter();
    }
    set thyDisabled(value) {
        this._disabled = value;
    }
    get thyDisabled() {
        return this._disabled;
    }
    get disabled() {
        return this.hidden || this._disabled;
    }
    get hidden() {
        return this._hidden;
    }
    get tabIndex() {
        return this.disabled ? '-1' : '0';
    }
    get selected() {
        return this._selected;
    }
    getHostElement() {
        return this.element.nativeElement;
    }
    onClick(event) {
        this.selectViaInteraction();
    }
    handleKeydown(event) {
        if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {
            this.selectViaInteraction();
            event.preventDefault();
        }
    }
    selectViaInteraction() {
        if (!this.disabled) {
            this._selected = this.parent.isMultiple ? !this._selected : true;
            this.cdr.markForCheck();
            this.emitSelectionChangeEvent(true);
        }
    }
    select(event) {
        if (!this.disabled) {
            if (!this._selected) {
                this._selected = true;
                this.emitSelectionChangeEvent();
                this.cdr.markForCheck();
            }
        }
    }
    deselect() {
        if (this._selected) {
            this._selected = false;
            this.emitSelectionChangeEvent();
            this.cdr.markForCheck();
        }
    }
    hideOption() {
        if (!this._hidden) {
            this._hidden = true;
            this.visibleChange.emit({ option: this });
            this.cdr.markForCheck();
        }
    }
    showOption() {
        if (this._hidden) {
            this._hidden = false;
            this.visibleChange.emit({ option: this });
            this.cdr.markForCheck();
        }
    }
    matchSearchText(searchText) {
        if (this.thySearchKey) {
            if (this.thySearchKey.indexOf(searchText) >= 0) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (this.thyLabelText.indexOf(searchText) >= 0) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    setActiveStyles() {
        this.getHostElement().classList.add('hover');
        this.cdr.markForCheck();
    }
    setInactiveStyles() {
        this.getHostElement().classList.remove('hover');
        this.cdr.markForCheck();
    }
    getLabel() {
        return '';
    }
    emitSelectionChangeEvent(isUserInput = false) {
        this.selectionChange.emit(new ThyOptionSelectionChangeEvent(this, isUserInput));
    }
    ngOnDestroy() { }
}
ThyOptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-option',
                template: "<ng-container *ngIf=\"thyShowOptionCustom; else defaultOption\">\n  <ng-content></ng-content>\n  <span class=\"checked-icon\">\n    <i class=\"wtf wtf-checked\"></i>\n  </span>\n</ng-container>\n<ng-template #defaultOption>\n  <span class=\"text-truncate\">{{ thyLabelText }}</span>\n  <span class=\"checked-icon\">\n    <i class=\"wtf wtf-checked\"></i>\n  </span>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ThyOptionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [THY_OPTION_PARENT_COMPONENT,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [THY_OPTION_GROUP_COMPONENT,] }] },
    { type: ChangeDetectorRef }
];
ThyOptionComponent.propDecorators = {
    thyValue: [{ type: Input }],
    thyRawValue: [{ type: Input }],
    thyLabelText: [{ type: Input }],
    thyShowOptionCustom: [{ type: Input }],
    thySearchKey: [{ type: Input }],
    _isOptionItem: [{ type: HostBinding, args: ['class.thy-option-item',] }],
    template: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    thyDisabled: [{ type: Input }, { type: HostBinding, args: [`class.disabled`,] }],
    hidden: [{ type: HostBinding, args: ['class.hidden',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    selected: [{ type: HostBinding, args: [`class.active`,] }],
    selectionChange: [{ type: Output }],
    visibleChange: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

class ThySelectOptionGroupComponent {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this._hidden = false;
        this._isOptionGroup = true;
        this._destroy$ = new Subject();
        this.optionVisibleChanges = defer(() => {
            if (this.options) {
                return merge(...this.options.map(option => option.visibleChange));
            }
            return this._ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionVisibleChanges));
        });
    }
    get hidden() {
        return this._hidden;
    }
    ngAfterContentInit() {
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy$)).subscribe(() => {
            this._resetOptions();
        });
    }
    _resetOptions() {
        const changedOrDestroyed$ = merge(this.options.changes, this._destroy$);
        merge(...this.options.map(option => option.visibleChange))
            .pipe(takeUntil(changedOrDestroyed$), debounceTime(10), map((event) => {
            const hasOption = this.options.find(option => {
                if (!option.hidden) {
                    return true;
                }
            });
            if (hasOption) {
                return false;
            }
            else {
                return true;
            }
        }))
            .subscribe((data) => {
            this._hidden = data;
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
}
ThySelectOptionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-option-group',
                template: "<span class=\"group-name text-desc\">{{ thyGroupLabel }}</span>\n<ng-content></ng-content>\n",
                providers: [
                    {
                        provide: THY_OPTION_GROUP_COMPONENT,
                        useExisting: ThySelectOptionGroupComponent
                    }
                ]
            },] }
];
ThySelectOptionGroupComponent.ctorParameters = () => [
    { type: NgZone }
];
ThySelectOptionGroupComponent.propDecorators = {
    thyDisabled: [{ type: Input }, { type: HostBinding, args: [`class.disabled`,] }],
    _isOptionGroup: [{ type: HostBinding, args: ['class.thy-option-item-group',] }],
    hidden: [{ type: HostBinding, args: ['class.thy-select-option-group-hidden',] }],
    thyGroupLabel: [{ type: Input }],
    options: [{ type: ContentChildren, args: [ThyOptionComponent,] }]
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ThyOptionModule {
}
ThyOptionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ThyIconModule],
                exports: [ThyListOptionComponent, ThyOptionGroupComponent, ThyOptionComponent, ThySelectOptionGroupComponent],
                declarations: [ThyListOptionComponent, ThyOptionGroupComponent, ThyOptionComponent, ThySelectOptionGroupComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { SelectOptionBase, THY_LIST_OPTION_PARENT_COMPONENT, THY_OPTION_GROUP_COMPONENT, THY_OPTION_PARENT_COMPONENT, ThyAutofocusDirective, ThyContextMenuDirective, ThyCtrlEnterDirective, ThyDragDropDirective, ThyEnterDirective, ThyFormCheckBaseComponent, ThyListOptionComponent, ThyOptionComponent, ThyOptionGroupComponent, ThyOptionModule, ThyOptionSelectionChangeEvent, ThyOptionVisibleChangeEvent, ThyScrollDirective, ThySelectCommonModule, ThySelectControlComponent, ThySelectOptionGroupComponent, ThySharedModule, ThyShowDirective, ThyStopPropagationDirective, ThyTranscludeDirective, ɵ0 };
//# sourceMappingURL=ngx-tethys-shared.js.map
