import { Injectable, forwardRef, EventEmitter, Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { coerceNumberValue } from 'ngx-tethys/util';
import { __decorate, __metadata } from 'tslib';
import { Store, Action } from 'ngx-tethys/store';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function ThyTimePickerComponent_td_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0\u00A0\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_7_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵelementStart(1, "a", 1);
    ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_td_7_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.changeMinutes(ctx_r18.minuteStep); });
    ɵngcc0.ɵɵelement(2, "span", 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r1.canIncrementMinutes || !ctx_r1.isEditable);
} }
function ThyTimePickerComponent_td_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_9_Template(rf, ctx) { if (rf & 1) {
    const _r21 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵelementStart(1, "a", 1);
    ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_td_9_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r21); const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ctx_r20.changeSeconds(ctx_r20.secondsStep); });
    ɵngcc0.ɵɵelement(2, "span", 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r3.canIncrementSeconds || !ctx_r3.isEditable);
} }
function ThyTimePickerComponent_td_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0\u00A0\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td");
} }
function ThyTimePickerComponent_td_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0:\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_16_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 4);
    ɵngcc0.ɵɵelementStart(1, "input", 5);
    ɵngcc0.ɵɵlistener("wheel", function ThyTimePickerComponent_td_16_Template_input_wheel_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(); ctx_r22.prevDef($event); return ctx_r22.changeMinutes(ctx_r22.minuteStep * ctx_r22.wheelSign($event), "wheel"); })("keydown.ArrowUp", function ThyTimePickerComponent_td_16_Template_input_keydown_ArrowUp_1_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.changeMinutes(ctx_r24.minuteStep, "key"); })("keydown.ArrowDown", function ThyTimePickerComponent_td_16_Template_input_keydown_ArrowDown_1_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r25 = ɵngcc0.ɵɵnextContext(); return ctx_r25.changeMinutes(-ctx_r25.minuteStep, "key"); })("change", function ThyTimePickerComponent_td_16_Template_input_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.updateMinutes($event.target.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("has-error", ctx_r7.invalidMinutes);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("is-invalid", ctx_r7.invalidMinutes);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r7.minutesPlaceholder)("readonly", ctx_r7.readonlyInput)("disabled", ctx_r7.disabled)("value", ctx_r7.minutes);
} }
function ThyTimePickerComponent_td_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0:\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_18_Template(rf, ctx) { if (rf & 1) {
    const _r28 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 4);
    ɵngcc0.ɵɵelementStart(1, "input", 5);
    ɵngcc0.ɵɵlistener("wheel", function ThyTimePickerComponent_td_18_Template_input_wheel_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r27 = ɵngcc0.ɵɵnextContext(); ctx_r27.prevDef($event); return ctx_r27.changeSeconds(ctx_r27.secondsStep * ctx_r27.wheelSign($event), "wheel"); })("keydown.ArrowUp", function ThyTimePickerComponent_td_18_Template_input_keydown_ArrowUp_1_listener() { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r29 = ɵngcc0.ɵɵnextContext(); return ctx_r29.changeSeconds(ctx_r29.secondsStep, "key"); })("keydown.ArrowDown", function ThyTimePickerComponent_td_18_Template_input_keydown_ArrowDown_1_listener() { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r30 = ɵngcc0.ɵɵnextContext(); return ctx_r30.changeSeconds(-ctx_r30.secondsStep, "key"); })("change", function ThyTimePickerComponent_td_18_Template_input_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r31 = ɵngcc0.ɵɵnextContext(); return ctx_r31.updateSeconds($event.target.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("has-error", ctx_r9.invalidSeconds);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("is-invalid", ctx_r9.invalidSeconds);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r9.secondsPlaceholder)("readonly", ctx_r9.readonlyInput)("disabled", ctx_r9.disabled)("value", ctx_r9.seconds);
} }
function ThyTimePickerComponent_td_19_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0\u00A0\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_20_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵelementStart(1, "button", 8);
    ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_td_20_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(); return ctx_r32.toggleMeridian(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r11.isEditable || !ctx_r11.canToggleMeridian);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r11.isEditable || !ctx_r11.canToggleMeridian);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r11.meridian, " ");
} }
function ThyTimePickerComponent_td_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0\u00A0\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_26_Template(rf, ctx) { if (rf & 1) {
    const _r35 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵelementStart(1, "a", 1);
    ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_td_26_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r35); const ctx_r34 = ɵngcc0.ɵɵnextContext(); return ctx_r34.changeMinutes(-ctx_r34.minuteStep); });
    ɵngcc0.ɵɵelement(2, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r13.canDecrementMinutes || !ctx_r13.isEditable);
} }
function ThyTimePickerComponent_td_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_28_Template(rf, ctx) { if (rf & 1) {
    const _r37 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵelementStart(1, "a", 1);
    ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_td_28_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r37); const ctx_r36 = ɵngcc0.ɵɵnextContext(); return ctx_r36.changeSeconds(-ctx_r36.secondsStep); });
    ɵngcc0.ɵɵelement(2, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r15.canDecrementSeconds || !ctx_r15.isEditable);
} }
function ThyTimePickerComponent_td_29_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtext(1, "\u00A0\u00A0\u00A0");
    ɵngcc0.ɵɵelementEnd();
} }
function ThyTimePickerComponent_td_30_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td");
} }
const hoursPerDay = 24;
const hoursPerDayHalf = 12;
const minutesPerHour = 60;
const secondsPerMinute = 60;
function isValidDate(value) {
    if (!value) {
        return false;
    }
    if (value instanceof Date && isNaN(value.getHours())) {
        return false;
    }
    if (typeof value === 'string') {
        return isValidDate(new Date(value));
    }
    return true;
}
function isValidLimit(controls, newDate) {
    if (controls.min && newDate < controls.min) {
        return false;
    }
    if (controls.max && newDate > controls.max) {
        return false;
    }
    return true;
}
function parseHours(value, isPM = false) {
    const hour = coerceNumberValue(value);
    if (isNaN(hour) || hour < 0 || hour > (isPM ? hoursPerDayHalf : hoursPerDay)) {
        return NaN;
    }
    return hour;
}
function parseMinutes(value) {
    const minute = coerceNumberValue(value);
    if (isNaN(minute) || minute < 0 || minute > minutesPerHour) {
        return NaN;
    }
    return minute;
}
function parseSeconds(value) {
    const seconds = coerceNumberValue(value);
    if (isNaN(seconds) || seconds < 0 || seconds > secondsPerMinute) {
        return NaN;
    }
    return seconds;
}
function parseTime(value) {
    if (typeof value === 'string') {
        return new Date(value);
    }
    return value;
}
function changeTime(value, diff) {
    if (!value) {
        return changeTime(createDate(new Date(), 0, 0, 0), diff);
    }
    let hour = value.getHours();
    let minutes = value.getMinutes();
    let seconds = value.getSeconds();
    if (diff.hour) {
        hour = (hour + coerceNumberValue(diff.hour)) % hoursPerDay;
        if (hour < 0) {
            hour += hoursPerDay;
        }
    }
    if (diff.minute) {
        minutes = minutes + coerceNumberValue(diff.minute);
    }
    if (diff.seconds) {
        seconds = seconds + coerceNumberValue(diff.seconds);
    }
    return createDate(value, hour, minutes, seconds);
}
function setTime(value, opts) {
    let hour = parseHours(opts.hour);
    const minute = parseMinutes(opts.minute);
    const seconds = parseSeconds(opts.seconds) || 0;
    if (opts.isPM && hour !== 12) {
        hour += hoursPerDayHalf;
    }
    if (!value) {
        if (!isNaN(hour) && !isNaN(minute)) {
            return createDate(new Date(), hour, minute, seconds);
        }
        return value;
    }
    if (isNaN(hour) || isNaN(minute)) {
        return value;
    }
    return createDate(value, hour, minute, seconds);
}
function createDate(value, hours, minutes, seconds) {
    return new Date(value.getFullYear(), value.getMonth(), value.getDate(), hours, minutes, seconds, value.getMilliseconds());
}
function padNumber(value) {
    const _value = value.toString();
    if (_value.length > 1) {
        return _value;
    }
    return `0${_value}`;
}
function isHourInputValid(hours, isPM) {
    return !isNaN(parseHours(hours, isPM));
}
function isMinuteInputValid(minutes) {
    return !isNaN(parseMinutes(minutes));
}
function isSecondInputValid(seconds) {
    return !isNaN(parseSeconds(seconds));
}
function isInputLimitValid(diff, max, min) {
    const newDate = setTime(new Date(), diff);
    if (max && newDate > max) {
        return false;
    }
    if (min && newDate < min) {
        return false;
    }
    return true;
}
function isInputValid(hours, minutes = '0', seconds = '0', isPM) {
    return isHourInputValid(hours, isPM) && isMinuteInputValid(minutes) && isSecondInputValid(seconds);
}

function canChangeValue(state, event) {
    if (state.readonlyInput || state.disabled) {
        return false;
    }
    if (event) {
        if (event.source === 'wheel' && !state.mousewheel) {
            return false;
        }
        if (event.source === 'key' && !state.arrowKeys) {
            return false;
        }
    }
    return true;
}
function canChangeHours(event, controls) {
    if (!event.step) {
        return false;
    }
    if (event.step > 0 && !controls.canIncrementHours) {
        return false;
    }
    if (event.step < 0 && !controls.canDecrementHours) {
        return false;
    }
    return true;
}
function canChangeMinutes(event, controls) {
    if (!event.step) {
        return false;
    }
    if (event.step > 0 && !controls.canIncrementMinutes) {
        return false;
    }
    if (event.step < 0 && !controls.canDecrementMinutes) {
        return false;
    }
    return true;
}
function canChangeSeconds(event, controls) {
    if (!event.step) {
        return false;
    }
    if (event.step > 0 && !controls.canIncrementSeconds) {
        return false;
    }
    if (event.step < 0 && !controls.canDecrementSeconds) {
        return false;
    }
    return true;
}
function getControlsValue(state) {
    const { hourStep, minuteStep, secondsStep, readonlyInput, disabled, mousewheel, arrowKeys, showSpinners, showMeridian, showSeconds, meridians, min, max } = state;
    return {
        hourStep,
        minuteStep,
        secondsStep,
        readonlyInput,
        disabled,
        mousewheel,
        arrowKeys,
        showSpinners,
        showMeridian,
        showSeconds,
        meridians,
        min,
        max
    };
}
function timePickerControls(value, state) {
    const hoursPerDayHalf = 12;
    const { min, max, hourStep, minuteStep, secondsStep, showSeconds } = state;
    const res = {
        canIncrementHours: true,
        canIncrementMinutes: true,
        canIncrementSeconds: true,
        canDecrementHours: true,
        canDecrementMinutes: true,
        canDecrementSeconds: true,
        canToggleMeridian: true
    };
    if (!value) {
        return res;
    }
    // compare dates
    if (max) {
        const _newHour = changeTime(value, { hour: hourStep });
        res.canIncrementHours = max > _newHour;
        if (!res.canIncrementHours) {
            const _newMinutes = changeTime(value, { minute: minuteStep });
            res.canIncrementMinutes = showSeconds ? max > _newMinutes : max >= _newMinutes;
        }
        if (!res.canIncrementMinutes) {
            const _newSeconds = changeTime(value, { seconds: secondsStep });
            res.canIncrementSeconds = max >= _newSeconds;
        }
        if (value.getHours() < hoursPerDayHalf) {
            res.canToggleMeridian = changeTime(value, { hour: hoursPerDayHalf }) < max;
        }
    }
    if (min) {
        const _newHour = changeTime(value, { hour: -hourStep });
        res.canDecrementHours = min < _newHour;
        if (!res.canDecrementHours) {
            const _newMinutes = changeTime(value, { minute: -minuteStep });
            res.canDecrementMinutes = showSeconds ? min < _newMinutes : min <= _newMinutes;
        }
        if (!res.canDecrementMinutes) {
            const _newSeconds = changeTime(value, { seconds: -secondsStep });
            res.canDecrementSeconds = min <= _newSeconds;
        }
        if (value.getHours() >= hoursPerDayHalf) {
            res.canToggleMeridian = changeTime(value, { hour: -hoursPerDayHalf }) > min;
        }
    }
    return res;
}

class TimePickerConfig {
    constructor() {
        /** hours change step */
        this.hourStep = 1;
        /** hours change step */
        this.minuteStep = 5;
        /** seconds changes step */
        this.secondsStep = 10;
        /** if true works in 12H mode and displays AM/PM. If false works in 24H mode and hides AM/PM */
        this.showMeridian = true;
        /** meridian labels based on locale */
        this.meridians = ['AM', 'PM'];
        /** if true hours and minutes fields will be readonly */
        this.readonlyInput = false;
        /** if true hours and minutes fields will be disabled */
        this.disabled = false;
        /** if true scroll inside hours and minutes inputs will change time */
        this.mousewheel = true;
        /** if true the values of hours and minutes can be changed using the up/down arrow keys on the keyboard */
        this.arrowKeys = true;
        /** if true spinner arrows above and below the inputs will be shown */
        this.showSpinners = true;
        /** show seconds in timePicker */
        this.showSeconds = false;
        /** show minutes in timePicker */
        this.showMinutes = true;
        /** placeholder for hours field in timePicker */
        this.hoursPlaceholder = 'HH';
        /** placeholder for minutes field in timePicker */
        this.minutesPlaceholder = 'MM';
        /** placeholder for seconds field in timePicker */
        this.secondsPlaceholder = 'SS';
    }
}
TimePickerConfig.ɵfac = function TimePickerConfig_Factory(t) { return new (t || TimePickerConfig)(); };
TimePickerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TimePickerConfig, factory: TimePickerConfig.ɵfac });

const initialState = {
    value: null,
    config: new TimePickerConfig(),
    controls: {
        canIncrementHours: true,
        canIncrementMinutes: true,
        canIncrementSeconds: true,
        canDecrementHours: true,
        canDecrementMinutes: true,
        canDecrementSeconds: true,
        canToggleMeridian: true
    }
};
class ThyTimePickerStore extends Store {
    constructor() {
        super(initialState);
    }
    writeValue(value) {
        this.setState({ value: value });
    }
    changeHours(event) {
        const state = this.snapshot;
        if (!canChangeValue(state.config, event) || !canChangeHours(event, state.controls)) {
            return state;
        }
        const _newTime = changeTime(state.value, { hour: event.step });
        if ((state.config.max || state.config.min) && !isValidLimit(state.config, _newTime)) {
            return state;
        }
        this.setState({ value: _newTime });
    }
    changeMinutes(event) {
        const state = this.snapshot;
        if (!canChangeValue(state.config, event) || !canChangeMinutes(event, state.controls)) {
            return state;
        }
        const _newTime = changeTime(state.value, { minute: event.step });
        if ((state.config.max || state.config.min) && !isValidLimit(state.config, _newTime)) {
            return state;
        }
        this.setState({ value: _newTime });
    }
    changeSeconds(event) {
        const state = this.snapshot;
        if (!canChangeValue(state.config, event) || !canChangeSeconds(event, state.controls)) {
            return state;
        }
        const _newTime = changeTime(state.value, {
            seconds: event.step
        });
        if ((state.config.max || state.config.min) && !isValidLimit(state.config, _newTime)) {
            return state;
        }
        this.setState({ value: _newTime });
    }
    setTime(value) {
        const state = this.snapshot;
        if (!canChangeValue(state.config)) {
            return state;
        }
        const _newTime = setTime(state.value, value);
        this.setState({ value: _newTime });
    }
    updateControls(value) {
        const state = this.snapshot;
        const _newControlsState = timePickerControls(state.value, value);
        const _newState = {
            value: state.value,
            config: value,
            controls: _newControlsState
        };
        if (state.config.showMeridian !== _newState.config.showMeridian) {
            if (state.value) {
                _newState.value = new Date(state.value);
            }
        }
        this.setState(_newState);
    }
}
ThyTimePickerStore.ɵfac = function ThyTimePickerStore_Factory(t) { return new (t || ThyTimePickerStore)(); };
ThyTimePickerStore.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ThyTimePickerStore, factory: ThyTimePickerStore.ɵfac });
ThyTimePickerStore.ctorParameters = () => [];
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Date]),
    __metadata("design:returntype", void 0)
], ThyTimePickerStore.prototype, "writeValue", null);
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ThyTimePickerStore.prototype, "changeHours", null);
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ThyTimePickerStore.prototype, "changeMinutes", null);
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ThyTimePickerStore.prototype, "changeSeconds", null);
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ThyTimePickerStore.prototype, "setTime", null);
__decorate([
    Action(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ThyTimePickerStore.prototype, "updateControls", null);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimePickerConfig, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTimePickerStore, [{
        type: Injectable
    }], function () { return []; }, null); })();

const TIMEPICKER_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    /* tslint:disable-next-line: no-use-before-declare */
    useExisting: forwardRef(() => ThyTimePickerComponent),
    multi: true
};
class ThyTimePickerComponent {
    constructor(_config, _cd, _store) {
        this._cd = _cd;
        this._store = _store;
        /** emits true if value is a valid date */
        this.isValid = new EventEmitter();
        // min/max validation for input fields
        this.invalidHours = false;
        this.invalidMinutes = false;
        this.invalidSeconds = false;
        // control value accessor methods
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
        Object.assign(this, _config);
        this.timePickerSub = _store
            .select(state => state.value)
            .subscribe((value) => {
            // update UI values if date changed
            this._renderTime(value);
            this.onChange(value);
            this._store.updateControls(getControlsValue(this));
        });
        _store
            .select(state => state.controls)
            .subscribe((controlsState) => {
            this.isValid.emit(isInputValid(this.hours, this.minutes, this.seconds, this.isPM()));
            Object.assign(this, controlsState);
            _cd.markForCheck();
        });
    }
    get isEditable() {
        return !(this.readonlyInput || this.disabled);
    }
    resetValidation() {
        this.invalidHours = false;
        this.invalidMinutes = false;
        this.invalidSeconds = false;
    }
    isPM() {
        return this.showMeridian && this.meridian === this.meridians[1];
    }
    prevDef($event) {
        $event.preventDefault();
    }
    wheelSign($event) {
        return Math.sign($event.deltaY) * -1;
    }
    ngOnChanges(changes) {
        this._store.updateControls(getControlsValue(this));
    }
    changeHours(step, source = '') {
        this.resetValidation();
        this._store.changeHours({ step, source });
    }
    changeMinutes(step, source = '') {
        this.resetValidation();
        this._store.changeMinutes({ step, source });
    }
    changeSeconds(step, source = '') {
        this.resetValidation();
        this._store.changeSeconds({ step, source });
    }
    updateHours(hours) {
        this.resetValidation();
        this.hours = hours;
        const isValid = isHourInputValid(this.hours, this.isPM()) && this.isValidLimit();
        if (!isValid) {
            this.invalidHours = true;
            this.isValid.emit(false);
            this.onChange(null);
            return;
        }
        this._updateTime();
    }
    updateMinutes(minutes) {
        this.resetValidation();
        this.minutes = minutes;
        const isValid = isMinuteInputValid(this.minutes) && this.isValidLimit();
        if (!isValid) {
            this.invalidMinutes = true;
            this.isValid.emit(false);
            this.onChange(null);
            return;
        }
        this._updateTime();
    }
    updateSeconds(seconds) {
        this.resetValidation();
        this.seconds = seconds;
        const isValid = isSecondInputValid(this.seconds) && this.isValidLimit();
        if (!isValid) {
            this.invalidSeconds = true;
            this.isValid.emit(false);
            this.onChange(null);
            return;
        }
        this._updateTime();
    }
    isValidLimit() {
        return isInputLimitValid({
            hour: this.hours,
            minute: this.minutes,
            seconds: this.seconds,
            isPM: this.isPM()
        }, this.max, this.min);
    }
    _updateTime() {
        const _seconds = this.showSeconds ? this.seconds : void 0;
        const _minutes = this.showMinutes ? this.minutes : void 0;
        if (!isInputValid(this.hours, _minutes, _seconds, this.isPM())) {
            this.isValid.emit(false);
            this.onChange(null);
            return;
        }
        this._store.setTime({
            hour: this.hours,
            minute: this.minutes,
            seconds: this.seconds,
            isPM: this.isPM()
        });
    }
    toggleMeridian() {
        if (!this.showMeridian || !this.isEditable) {
            return;
        }
        const _hoursPerDayHalf = 12;
        this._store.changeHours({
            step: _hoursPerDayHalf,
            source: ''
        });
    }
    writeValue(obj) {
        if (isValidDate(obj)) {
            this._store.writeValue(parseTime(obj));
        }
        else if (obj == null) {
            this._store.writeValue(null);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cd.markForCheck();
    }
    ngOnDestroy() {
        this.timePickerSub.unsubscribe();
    }
    _renderTime(value) {
        if (!isValidDate(value)) {
            this.hours = '';
            this.minutes = '';
            this.seconds = '';
            this.meridian = this.meridians[0];
            return;
        }
        const _value = parseTime(value);
        const _hoursPerDayHalf = 12;
        let _hours = _value.getHours();
        if (this.showMeridian) {
            this.meridian = this.meridians[_hours >= _hoursPerDayHalf ? 1 : 0];
            _hours = _hours % _hoursPerDayHalf;
            // should be 12 PM, not 00 PM
            if (_hours === 0) {
                _hours = _hoursPerDayHalf;
            }
        }
        this.hours = padNumber(_hours);
        this.minutes = padNumber(_value.getMinutes());
        this.seconds = padNumber(_value.getUTCSeconds());
    }
}
ThyTimePickerComponent.ɵfac = function ThyTimePickerComponent_Factory(t) { return new (t || ThyTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(TimePickerConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ThyTimePickerStore)); };
ThyTimePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyTimePickerComponent, selectors: [["thy-time-picker"]], inputs: { disabled: "disabled", hourStep: "hourStep", minuteStep: "minuteStep", secondsStep: "secondsStep", readonlyInput: "readonlyInput", mousewheel: "mousewheel", arrowKeys: "arrowKeys", showSpinners: "showSpinners", showMeridian: "showMeridian", showMinutes: "showMinutes", showSeconds: "showSeconds", meridians: "meridians", min: "min", max: "max", hoursPlaceholder: "hoursPlaceholder", minutesPlaceholder: "minutesPlaceholder", secondsPlaceholder: "secondsPlaceholder" }, outputs: { isValid: "isValid" }, features: [ɵngcc0.ɵɵProvidersFeature([TIMEPICKER_CONTROL_VALUE_ACCESSOR, ThyTimePickerStore]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 31, vars: 32, consts: [[1, "text-center", 3, "hidden"], [1, "btn", "btn-link", 3, "click"], [1, "thy-chevron", "thy-chevron-up"], [4, "ngIf"], [1, "form-group"], ["type", "text", "maxlength", "2", 1, "form-control", "text-center", "thy-time-picker-field", 3, "placeholder", "readonly", "disabled", "value", "wheel", "keydown.ArrowUp", "keydown.ArrowDown", "change"], ["class", "form-group", 3, "has-error", 4, "ngIf"], [1, "thy-chevron", "thy-chevron-down"], ["type", "button", 1, "btn", "btn-default", "text-center", 3, "disabled", "click"]], template: function ThyTimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table");
        ɵngcc0.ɵɵelementStart(1, "tbody");
        ɵngcc0.ɵɵelementStart(2, "tr", 0);
        ɵngcc0.ɵɵelementStart(3, "td");
        ɵngcc0.ɵɵelementStart(4, "a", 1);
        ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_Template_a_click_4_listener() { return ctx.changeHours(ctx.hourStep); });
        ɵngcc0.ɵɵelement(5, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ThyTimePickerComponent_td_6_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(7, ThyTimePickerComponent_td_7_Template, 3, 2, "td", 3);
        ɵngcc0.ɵɵtemplate(8, ThyTimePickerComponent_td_8_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(9, ThyTimePickerComponent_td_9_Template, 3, 2, "td", 3);
        ɵngcc0.ɵɵtemplate(10, ThyTimePickerComponent_td_10_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(11, ThyTimePickerComponent_td_11_Template, 1, 0, "td", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "tr");
        ɵngcc0.ɵɵelementStart(13, "td", 4);
        ɵngcc0.ɵɵelementStart(14, "input", 5);
        ɵngcc0.ɵɵlistener("wheel", function ThyTimePickerComponent_Template_input_wheel_14_listener($event) { ctx.prevDef($event); return ctx.changeHours(ctx.hourStep * ctx.wheelSign($event), "wheel"); })("keydown.ArrowUp", function ThyTimePickerComponent_Template_input_keydown_ArrowUp_14_listener() { return ctx.changeHours(ctx.hourStep, "key"); })("keydown.ArrowDown", function ThyTimePickerComponent_Template_input_keydown_ArrowDown_14_listener() { return ctx.changeHours(-ctx.hourStep, "key"); })("change", function ThyTimePickerComponent_Template_input_change_14_listener($event) { return ctx.updateHours($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(15, ThyTimePickerComponent_td_15_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(16, ThyTimePickerComponent_td_16_Template, 2, 8, "td", 6);
        ɵngcc0.ɵɵtemplate(17, ThyTimePickerComponent_td_17_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(18, ThyTimePickerComponent_td_18_Template, 2, 8, "td", 6);
        ɵngcc0.ɵɵtemplate(19, ThyTimePickerComponent_td_19_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(20, ThyTimePickerComponent_td_20_Template, 3, 4, "td", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(21, "tr", 0);
        ɵngcc0.ɵɵelementStart(22, "td");
        ɵngcc0.ɵɵelementStart(23, "a", 1);
        ɵngcc0.ɵɵlistener("click", function ThyTimePickerComponent_Template_a_click_23_listener() { return ctx.changeHours(-ctx.hourStep); });
        ɵngcc0.ɵɵelement(24, "span", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(25, ThyTimePickerComponent_td_25_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(26, ThyTimePickerComponent_td_26_Template, 3, 2, "td", 3);
        ɵngcc0.ɵɵtemplate(27, ThyTimePickerComponent_td_27_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(28, ThyTimePickerComponent_td_28_Template, 3, 2, "td", 3);
        ɵngcc0.ɵɵtemplate(29, ThyTimePickerComponent_td_29_Template, 2, 0, "td", 3);
        ɵngcc0.ɵɵtemplate(30, ThyTimePickerComponent_td_30_Template, 1, 0, "td", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("hidden", !ctx.showSpinners);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("disabled", !ctx.canIncrementHours || !ctx.isEditable);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeconds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeconds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMeridian);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMeridian);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("has-error", ctx.invalidHours);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("is-invalid", ctx.invalidHours);
        ɵngcc0.ɵɵproperty("placeholder", ctx.hoursPlaceholder)("readonly", ctx.readonlyInput)("disabled", ctx.disabled)("value", ctx.hours);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeconds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeconds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMeridian);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMeridian);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", !ctx.showSpinners);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("disabled", !ctx.canDecrementHours || !ctx.isEditable);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeconds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeconds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMeridian);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMeridian);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
ThyTimePickerComponent.ctorParameters = () => [
    { type: TimePickerConfig },
    { type: ChangeDetectorRef },
    { type: ThyTimePickerStore }
];
ThyTimePickerComponent.propDecorators = {
    hourStep: [{ type: Input }],
    minuteStep: [{ type: Input }],
    secondsStep: [{ type: Input }],
    readonlyInput: [{ type: Input }],
    disabled: [{ type: Input }],
    mousewheel: [{ type: Input }],
    arrowKeys: [{ type: Input }],
    showSpinners: [{ type: Input }],
    showMeridian: [{ type: Input }],
    showMinutes: [{ type: Input }],
    showSeconds: [{ type: Input }],
    meridians: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    hoursPlaceholder: [{ type: Input }],
    minutesPlaceholder: [{ type: Input }],
    secondsPlaceholder: [{ type: Input }],
    isValid: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTimePickerComponent, [{
        type: Component,
        args: [{
                selector: 'thy-time-picker',
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [TIMEPICKER_CONTROL_VALUE_ACCESSOR, ThyTimePickerStore],
                template: "<table>\n  <tbody>\n    <tr class=\"text-center\" [hidden]=\"!showSpinners\">\n      <!-- increment hours button-->\n      <td>\n        <a class=\"btn btn-link\" [class.disabled]=\"!canIncrementHours || !isEditable\" (click)=\"changeHours(hourStep)\"\n          ><span class=\"thy-chevron thy-chevron-up\"></span\n        ></a>\n      </td>\n      <!-- divider -->\n      <td *ngIf=\"showMinutes\">&nbsp;&nbsp;&nbsp;</td>\n      <!-- increment minutes button -->\n      <td *ngIf=\"showMinutes\">\n        <a\n          class=\"btn btn-link\"\n          [class.disabled]=\"!canIncrementMinutes || !isEditable\"\n          (click)=\"changeMinutes(minuteStep)\"\n          ><span class=\"thy-chevron thy-chevron-up\"></span\n        ></a>\n      </td>\n      <!-- divider -->\n      <td *ngIf=\"showSeconds\">&nbsp;</td>\n      <!-- increment seconds button -->\n      <td *ngIf=\"showSeconds\">\n        <a\n          class=\"btn btn-link\"\n          [class.disabled]=\"!canIncrementSeconds || !isEditable\"\n          (click)=\"changeSeconds(secondsStep)\"\n        >\n          <span class=\"thy-chevron thy-chevron-up\"></span>\n        </a>\n      </td>\n      <!-- space between -->\n      <td *ngIf=\"showMeridian\">&nbsp;&nbsp;&nbsp;</td>\n      <!-- meridian placeholder-->\n      <td *ngIf=\"showMeridian\"></td>\n    </tr>\n    <tr>\n      <!-- hours -->\n      <td class=\"form-group\" [class.has-error]=\"invalidHours\">\n        <input\n          type=\"text\"\n          [class.is-invalid]=\"invalidHours\"\n          class=\"form-control text-center thy-time-picker-field\"\n          [placeholder]=\"hoursPlaceholder\"\n          maxlength=\"2\"\n          [readonly]=\"readonlyInput\"\n          [disabled]=\"disabled\"\n          [value]=\"hours\"\n          (wheel)=\"prevDef($event); changeHours(hourStep * wheelSign($event), 'wheel')\"\n          (keydown.ArrowUp)=\"changeHours(hourStep, 'key')\"\n          (keydown.ArrowDown)=\"changeHours(-hourStep, 'key')\"\n          (change)=\"updateHours($event.target.value)\"\n        />\n      </td>\n\n      <!-- divider -->\n      <td *ngIf=\"showMinutes\">&nbsp;:&nbsp;</td>\n      <!-- minutes -->\n      <td class=\"form-group\" *ngIf=\"showMinutes\" [class.has-error]=\"invalidMinutes\">\n        <input\n          type=\"text\"\n          [class.is-invalid]=\"invalidMinutes\"\n          class=\"form-control text-center thy-time-picker-field\"\n          [placeholder]=\"minutesPlaceholder\"\n          maxlength=\"2\"\n          [readonly]=\"readonlyInput\"\n          [disabled]=\"disabled\"\n          [value]=\"minutes\"\n          (wheel)=\"prevDef($event); changeMinutes(minuteStep * wheelSign($event), 'wheel')\"\n          (keydown.ArrowUp)=\"changeMinutes(minuteStep, 'key')\"\n          (keydown.ArrowDown)=\"changeMinutes(-minuteStep, 'key')\"\n          (change)=\"updateMinutes($event.target.value)\"\n        />\n      </td>\n      <!-- divider -->\n      <td *ngIf=\"showSeconds\">&nbsp;:&nbsp;</td>\n      <!-- seconds -->\n      <td class=\"form-group\" *ngIf=\"showSeconds\" [class.has-error]=\"invalidSeconds\">\n        <input\n          type=\"text\"\n          [class.is-invalid]=\"invalidSeconds\"\n          class=\"form-control text-center thy-time-picker-field\"\n          [placeholder]=\"secondsPlaceholder\"\n          maxlength=\"2\"\n          [readonly]=\"readonlyInput\"\n          [disabled]=\"disabled\"\n          [value]=\"seconds\"\n          (wheel)=\"prevDef($event); changeSeconds(secondsStep * wheelSign($event), 'wheel')\"\n          (keydown.ArrowUp)=\"changeSeconds(secondsStep, 'key')\"\n          (keydown.ArrowDown)=\"changeSeconds(-secondsStep, 'key')\"\n          (change)=\"updateSeconds($event.target.value)\"\n        />\n      </td>\n      <!-- space between -->\n      <td *ngIf=\"showMeridian\">&nbsp;&nbsp;&nbsp;</td>\n      <!-- meridian -->\n      <td *ngIf=\"showMeridian\">\n        <button\n          type=\"button\"\n          class=\"btn btn-default text-center\"\n          [disabled]=\"!isEditable || !canToggleMeridian\"\n          [class.disabled]=\"!isEditable || !canToggleMeridian\"\n          (click)=\"toggleMeridian()\"\n        >\n          {{ meridian }}\n        </button>\n      </td>\n    </tr>\n    <tr class=\"text-center\" [hidden]=\"!showSpinners\">\n      <!-- decrement hours button-->\n      <td>\n        <a class=\"btn btn-link\" [class.disabled]=\"!canDecrementHours || !isEditable\" (click)=\"changeHours(-hourStep)\">\n          <span class=\"thy-chevron thy-chevron-down\"></span>\n        </a>\n      </td>\n      <!-- divider -->\n      <td *ngIf=\"showMinutes\">&nbsp;&nbsp;&nbsp;</td>\n      <!-- decrement minutes button-->\n      <td *ngIf=\"showMinutes\">\n        <a\n          class=\"btn btn-link\"\n          [class.disabled]=\"!canDecrementMinutes || !isEditable\"\n          (click)=\"changeMinutes(-minuteStep)\"\n        >\n          <span class=\"thy-chevron thy-chevron-down\"></span>\n        </a>\n      </td>\n      <!-- divider -->\n      <td *ngIf=\"showSeconds\">&nbsp;</td>\n      <!-- decrement seconds button-->\n      <td *ngIf=\"showSeconds\">\n        <a\n          class=\"btn btn-link\"\n          [class.disabled]=\"!canDecrementSeconds || !isEditable\"\n          (click)=\"changeSeconds(-secondsStep)\"\n        >\n          <span class=\"thy-chevron thy-chevron-down\"></span>\n        </a>\n      </td>\n      <!-- space between -->\n      <td *ngIf=\"showMeridian\">&nbsp;&nbsp;&nbsp;</td>\n      <!-- meridian placeholder-->\n      <td *ngIf=\"showMeridian\"></td>\n    </tr>\n  </tbody>\n</table>\n"
            }]
    }], function () { return [{ type: TimePickerConfig }, { type: ɵngcc0.ChangeDetectorRef }, { type: ThyTimePickerStore }]; }, { isValid: [{
            type: Output
        }], disabled: [{
            type: Input
        }], hourStep: [{
            type: Input
        }], minuteStep: [{
            type: Input
        }], secondsStep: [{
            type: Input
        }], readonlyInput: [{
            type: Input
        }], mousewheel: [{
            type: Input
        }], arrowKeys: [{
            type: Input
        }], showSpinners: [{
            type: Input
        }], showMeridian: [{
            type: Input
        }], showMinutes: [{
            type: Input
        }], showSeconds: [{
            type: Input
        }], meridians: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], hoursPlaceholder: [{
            type: Input
        }], minutesPlaceholder: [{
            type: Input
        }], secondsPlaceholder: [{
            type: Input
        }] }); })();

class ThyTimePickerModule {
}
ThyTimePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyTimePickerModule });
ThyTimePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyTimePickerModule_Factory(t) { return new (t || ThyTimePickerModule)(); }, providers: [TimePickerConfig, ThyTimePickerStore], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyTimePickerModule, { declarations: function () { return [ThyTimePickerComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ThyTimePickerComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTimePickerModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [ThyTimePickerComponent],
                exports: [ThyTimePickerComponent],
                providers: [TimePickerConfig, ThyTimePickerStore]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TIMEPICKER_CONTROL_VALUE_ACCESSOR, ThyTimePickerComponent, ThyTimePickerModule, ThyTimePickerStore, TimePickerConfig, changeTime, createDate, initialState, isHourInputValid, isInputLimitValid, isInputValid, isMinuteInputValid, isSecondInputValid, isValidDate, isValidLimit, padNumber, parseHours, parseMinutes, parseSeconds, parseTime, setTime };

//# sourceMappingURL=ngx-tethys-time-picker.js.map