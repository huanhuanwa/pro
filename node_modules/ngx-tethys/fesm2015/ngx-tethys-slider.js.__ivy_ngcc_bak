import { __decorate, __metadata } from 'tslib';
import { EventEmitter, Component, forwardRef, ChangeDetectorRef, NgZone, ElementRef, HostBinding, Input, ViewChild, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { fromEvent } from 'rxjs';
import { clamp } from 'ngx-tethys/util';
import { tap, pluck, map, distinctUntilChanged, takeUntil } from 'rxjs/operators';
import { UpdateHostClassService, InputBoolean } from 'ngx-tethys/core';
import { CommonModule } from '@angular/common';

class ThySliderComponent {
    constructor(cdr, ngZone, ref, updateHostClassService) {
        this.cdr = cdr;
        this.ngZone = ngZone;
        this.ref = ref;
        this.updateHostClassService = updateHostClassService;
        this.thyVertical = false;
        this.thyDisabled = false;
        this._thySlider = true;
        this._pointer = true;
        this.thyMax = 100;
        this.thyMin = 0;
        this.thyStep = 1;
        this.thyAfterChange = new EventEmitter();
        this.onChangeCallback = (v) => { };
        this.onTouchedCallback = (v) => { };
        updateHostClassService.initializeElement(ref.nativeElement);
    }
    set thyType(type) {
        this.updateHostClassService.updateClass(type ? [`thy-slider-${type}`] : []);
    }
    ngOnInit() {
        this.verificationValues();
        this.verificationStepValue();
        this.toggleDisabled();
        if (this.value === null || this.value === undefined) {
            this.setValue(this.ensureValueInRange(null));
        }
    }
    ngAfterViewInit() {
        this.registerMouseEventsListeners();
        this.toggleDisabled();
    }
    writeValue(newValue) {
        this.setValue(this.ensureValueInRange(newValue));
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('thyMin') || changes.hasOwnProperty('thyMax') || changes.hasOwnProperty('thyStep')) {
            this.verificationValues();
            this.verificationStepValue();
        }
    }
    ngOnDestroy() {
        this.unsubscribeMouseListeners();
    }
    verificationValues() {
        if (this.thyMin >= this.thyMax) {
            throw new Error('min value must less than max value.');
        }
    }
    verificationStepValue() {
        if (this.thyStep <= 0 || !!!this.thyStep) {
            throw new Error('step value must be greater than 0.');
        }
        else if (Number.isInteger(this.thyStep) && (this.thyMax - this.thyMin) % this.thyStep) {
            throw new Error('(max - min) must be divisible by step.');
        }
    }
    toggleDisabled() {
        if (this.thyDisabled) {
            this.unsubscribeMouseListeners();
        }
        else {
            this.subscribeMouseListeners(['start']);
        }
    }
    setValue(value) {
        if (this.value !== value) {
            this.value = value;
            this.updateTrackAndPointer();
        }
        this.onChangeCallback(this.value);
    }
    ensureValueInRange(value) {
        if (!this.valueMustBeValid(value)) {
            return this.thyMin;
        }
        return clamp(value, this.thyMin, this.thyMax);
    }
    valueMustBeValid(value) {
        return !isNaN(typeof value !== 'number' ? parseFloat(value) : value);
    }
    updateTrackAndPointer() {
        const offset = this.valueToOffset(this.value);
        this.updateStyle(offset / 100);
        this.cdr.markForCheck();
    }
    valueToOffset(value) {
        return ((value - this.thyMin) * 100) / (this.thyMax - this.thyMin);
    }
    updateStyle(offsetPercentage) {
        const percentage = Math.min(1, Math.max(0, offsetPercentage));
        const orientFields = this.thyVertical ? ['height', 'bottom'] : ['width', 'left'];
        this.sliderTrack.nativeElement.style[orientFields[0]] = `${percentage * 100}%`;
        this.sliderPointer.nativeElement.style[orientFields[1]] = `${percentage * 100}%`;
    }
    unsubscribeMouseListeners(actions = ['start', 'move', 'end']) {
        if (actions.includes('start') && this.dragStartHandler) {
            this.dragStartHandler.unsubscribe();
            this.dragStartHandler = null;
        }
        if (actions.includes('move') && this.dragMoveHandler) {
            this.dragMoveHandler.unsubscribe();
            this.dragMoveHandler = null;
        }
        if (actions.includes('end') && this.dragEndHandler) {
            this.dragEndHandler.unsubscribe();
            this.dragEndHandler = null;
        }
    }
    subscribeMouseListeners(actions = ['start', 'move', 'end']) {
        if (actions.includes('start') && this.dragStartListener && !this.dragStartHandler) {
            this.dragStartHandler = this.dragStartListener.subscribe(this.mouseStartMoving.bind(this));
        }
        if (actions.includes('move') && this.dragMoveListener && !this.dragMoveHandler) {
            this.dragMoveHandler = this.dragMoveListener.subscribe(this.mouseMoving.bind(this));
        }
        if (actions.includes('end') && this.dragEndListener && !this.dragEndHandler) {
            this.dragEndHandler = this.dragEndListener.subscribe(this.mouseStopMoving.bind(this));
        }
    }
    mouseStartMoving(value) {
        this.pointerController(true);
        this.setValue(value);
    }
    mouseMoving(value) {
        this.setValue(this.ensureValueInRange(value));
        this.cdr.markForCheck();
    }
    mouseStopMoving() {
        this.pointerController(false);
        this.cdr.markForCheck();
        this.thyAfterChange.emit({ value: this.value });
    }
    pointerController(movable) {
        if (movable) {
            this.subscribeMouseListeners(['move', 'end']);
        }
        else {
            this.unsubscribeMouseListeners(['move', 'end']);
        }
    }
    registerMouseEventsListeners() {
        const orientField = this.thyVertical ? 'pageY' : 'pageX';
        this.dragStartListener = this.ngZone.runOutsideAngular(() => {
            return fromEvent(this.ref.nativeElement, 'mousedown').pipe(tap((e) => {
                e.stopPropagation();
                e.preventDefault();
            }), pluck(orientField), map((position) => this.mousePositionToAdaptiveValue(position)));
        });
        this.dragEndListener = this.ngZone.runOutsideAngular(() => {
            return fromEvent(document, 'mouseup');
        });
        this.dragMoveListener = this.ngZone.runOutsideAngular(() => {
            return fromEvent(document, 'mousemove').pipe(tap((e) => {
                e.stopPropagation();
                e.preventDefault();
            }), pluck(orientField), distinctUntilChanged(), map((position) => this.mousePositionToAdaptiveValue(position)), distinctUntilChanged(), takeUntil(this.dragEndListener));
        });
    }
    mousePositionToAdaptiveValue(position) {
        const sliderStartPosition = this.getSliderPagePosition();
        const sliderLength = this.getRailLength();
        const ratio = this.convertPointerPositionToRatio(position, sliderStartPosition, sliderLength);
        const value = this.ratioToValue(ratio);
        return parseFloat(value.toFixed(this.getDecimals(this.thyStep)));
    }
    getSliderPagePosition() {
        const rect = this.ref.nativeElement.getBoundingClientRect();
        const window = this.ref.nativeElement.ownerDocument.defaultView;
        const orientFields = this.thyVertical ? ['bottom', 'pageYOffset'] : ['left', 'pageXOffset'];
        return rect[orientFields[0]] + window[orientFields[1]];
    }
    getRailLength() {
        const orientFiled = this.thyVertical ? 'clientHeight' : 'clientWidth';
        return this.sliderRail.nativeElement[orientFiled];
    }
    convertPointerPositionToRatio(pointerPosition, startPosition, totalLength) {
        if (this.thyVertical) {
            return clamp((startPosition - pointerPosition) / totalLength, 0, 1);
        }
        return clamp((pointerPosition - startPosition) / totalLength, 0, 1);
    }
    ratioToValue(ratio) {
        let value = (this.thyMax - this.thyMin) * ratio + this.thyMin;
        const step = this.thyStep;
        if (ratio === 0) {
            value = this.thyMin;
        }
        else if (ratio === 1) {
            value = this.thyMax;
        }
        else {
            value = Math.round(value / step) * step;
        }
        return clamp(value, this.thyMin, this.thyMax);
    }
    getDecimals(value) {
        const valueString = value.toString();
        const integerLength = valueString.indexOf('.') + 1;
        return integerLength >= 0 ? valueString.length - integerLength : 0;
    }
}
ThySliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slider',
                template: "<div class=\"thy-slider-rail\" #sliderRail>\n  <div class=\"thy-slider-track\" #sliderTrack [ngStyle]=\"{ 'background-color': thyColor }\"></div>\n  <div class=\"thy-slider-pointer\" #sliderPointer [ngStyle]=\"{ 'border-color': thyColor }\"></div>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ThySliderComponent),
                        multi: true
                    },
                    UpdateHostClassService
                ]
            },] }
];
ThySliderComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: ElementRef },
    { type: UpdateHostClassService }
];
ThySliderComponent.propDecorators = {
    thyVertical: [{ type: HostBinding, args: ['class.slider-vertical',] }, { type: Input }],
    thyDisabled: [{ type: HostBinding, args: ['class.slider-disabled',] }, { type: Input }],
    _thySlider: [{ type: HostBinding, args: ['class.thy-slider',] }],
    _pointer: [{ type: HostBinding, args: ['class.cursor-pointer',] }],
    sliderRail: [{ type: ViewChild, args: ['sliderRail', { static: true },] }],
    sliderTrack: [{ type: ViewChild, args: ['sliderTrack', { static: true },] }],
    sliderPointer: [{ type: ViewChild, args: ['sliderPointer', { static: true },] }],
    thyMax: [{ type: Input }],
    thyMin: [{ type: Input }],
    thyStep: [{ type: Input }],
    thyType: [{ type: Input }],
    thyColor: [{ type: Input }],
    thyAfterChange: [{ type: Output }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], ThySliderComponent.prototype, "thyVertical", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], ThySliderComponent.prototype, "thyDisabled", void 0);

class ThySliderModule {
}
ThySliderModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: [ThySliderComponent],
                declarations: [ThySliderComponent],
                providers: []
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ThySliderComponent, ThySliderModule };
//# sourceMappingURL=ngx-tethys-slider.js.map
