import { coerceBooleanProperty, coerceCssPixelValue, coerceNumberValue, dom, ESCAPE, concatArray } from 'ngx-tethys/util';
import { Subject, fromEvent, Observable } from 'rxjs';
import * as i0 from '@angular/core';
import { Injectable, NgZone, Inject, EventEmitter, TemplateRef, ElementRef, Renderer2 } from '@angular/core';
import * as i1 from '@angular/common';
import { DOCUMENT } from '@angular/common';
import { auditTime, take, takeUntil, filter } from 'rxjs/operators';
import { trigger, transition, style, animate } from '@angular/animations';
import { GlobalPositionStrategy, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal, ComponentPortal } from '@angular/cdk/portal';

import * as ɵngcc0 from '@angular/core';
class AnonymousClass {
}
class MixinBase {
}

/** Mixin to augment a directive with a `disable` property. */
function mixinDisabled(base) {
    return class extends base {
        constructor(...args) {
            super(...args);
            this._thyDisabled = false;
        }
        get thyDisabled() {
            return this._thyDisabled;
        }
        set thyDisabled(value) {
            this._thyDisabled = coerceBooleanProperty(value);
        }
    };
}

/** Mixin to augment a directive with a `disableRipple` property. */
function mixinUnsubscribe(base) {
    return class Mixin extends base {
        constructor(...args) {
            super(...args);
            this.ngUnsubscribe$ = new Subject();
        }
        ngUnsubscribeReinitialize() {
            this.ngUnsubscribe$.next();
            this.ngUnsubscribe$.complete();
            this.ngUnsubscribe$ = new Subject();
        }
        ngOnDestroy() {
            this.ngUnsubscribe$.next();
            this.ngUnsubscribe$.complete();
        }
    };
}

function mixinLoadingDone(base) {
    return class Mixin extends base {
        constructor(...args) {
            super(...args);
            this.loadingDone = false;
        }
        setLoadingDone(value) {
            this.loadingDone = value;
        }
    };
}

function InputBoolean() {
    return propDecoratorFactory('InputBoolean', coerceBooleanProperty);
}
function InputCssPixel() {
    return propDecoratorFactory('InputCssPixel', coerceCssPixelValue);
}
function InputNumber() {
    return propDecoratorFactory('InputNumber', coerceNumberValue);
}
function propDecoratorFactory(name, fallback) {
    function propDecorator(target, propName, originalDescriptor) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${name} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        return {
            get() {
                return originalDescriptor && originalDescriptor.get ? originalDescriptor.get.bind(this)() : this[privatePropName];
            },
            set(value) {
                if (originalDescriptor && originalDescriptor.set) {
                    originalDescriptor.set.bind(this)(fallback(value));
                }
                this[privatePropName] = fallback(value);
            }
        };
    }
    return propDecorator;
}

class ScrollToService {
    static _customScrollToElement(targetElement, containerElement) {
        const containerOffset = dom.getElementOffset(containerElement);
        const targetOffset = dom.getElementOffset(targetElement);
        // 选择项在顶部隐藏的偏移量 > 0 表示被顶部遮住隐藏
        const topOffset = containerOffset.top - targetOffset.top;
        // 选择项在底部隐藏的偏移量 > 0 表示被底部遮住隐藏
        const bottomOffset = targetOffset.top + targetOffset.height - (containerOffset.top + containerOffset.height);
        // 隐藏后滚动展示 targetElement 的偏移量，避免紧挨着头部或者底部
        const viewOffset = targetOffset.height;
        if (topOffset > 0) {
            containerElement.scrollTop = containerElement.scrollTop - topOffset - viewOffset;
        }
        else if (bottomOffset > 0) {
            containerElement.scrollTop = containerElement.scrollTop + bottomOffset + viewOffset;
        }
    }
    static scrollToElement(targetElement, containerElement) {
        if (targetElement) {
            this._customScrollToElement(targetElement, containerElement);
            // if (targetElement.scrollIntoView) {
            //     targetElement.scrollIntoView({
            //         behavior: 'smooth',
            //         block: 'center'
            //     });
            // } else {
            //     this._customScrollToElement(targetElement, containerElement);
            // }
        }
    }
}

const DEFAULT_EVENT_TIME = 100;
class ThyEventDispatcher {
    constructor(document, ngZone, eventName) {
        this.document = document;
        this.ngZone = ngZone;
        this.eventName = eventName;
        this._globalSubscription = null;
        this._event$ = new Subject();
        this._subscriptionCount = 0;
    }
    _addGlobalListener() {
        this._globalSubscription = this.ngZone.runOutsideAngular(() => {
            return fromEvent(this.document, this.eventName).subscribe((event) => {
                this._event$.next(event);
            });
        });
    }
    _removeGlobalListener() {
        if (this._globalSubscription) {
            this._globalSubscription.unsubscribe();
            this._globalSubscription = null;
        }
    }
    get globalSubscription() {
        return this._globalSubscription;
    }
    subscribe(auditTimeInMs = DEFAULT_EVENT_TIME) {
        return new Observable(observer => {
            if (!this._globalSubscription) {
                this._addGlobalListener();
            }
            // In the case of a 0ms delay, use an observable without auditTime
            // since it does add a perceptible delay in processing overhead.
            const subscription = auditTimeInMs > 0 ? this._event$.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._event$.subscribe(observer);
            this._subscriptionCount++;
            return () => {
                subscription.unsubscribe();
                this._subscriptionCount--;
                if (!this._subscriptionCount) {
                    this._removeGlobalListener();
                }
            };
        });
    }
    ngOnDestroy() {
        this._removeGlobalListener();
        this._event$.complete();
    }
}
ThyEventDispatcher.ɵfac = function ThyEventDispatcher_Factory(t) { return new (t || ThyEventDispatcher)(ɵngcc0.ɵɵinject(undefined), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(String)); };
ThyEventDispatcher.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ThyEventDispatcher, factory: ThyEventDispatcher.ɵfac });
ThyEventDispatcher.ctorParameters = () => [
    { type: undefined },
    { type: NgZone },
    { type: String }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyEventDispatcher, [{
        type: Injectable
    }], function () { return [{ type: undefined }, { type: ɵngcc0.NgZone }, { type: String }]; }, null); })();

const DEFAULT_CLICKED_TIME = 100;
class ThyClickDispatcher extends ThyEventDispatcher {
    constructor(document, ngZone) {
        super(document, ngZone, 'click');
    }
    clicked(auditTimeInMs = DEFAULT_CLICKED_TIME) {
        return this.subscribe(auditTimeInMs);
    }
}
ThyClickDispatcher.ɵfac = function ThyClickDispatcher_Factory(t) { return new (t || ThyClickDispatcher)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ThyClickDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyClickDispatcher_Factory() { return new ThyClickDispatcher(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i0.NgZone)); }, token: ThyClickDispatcher, providedIn: "root" });
ThyClickDispatcher.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyClickDispatcher, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const DEFAULT_KEYDOWN_TIME = 100;
class ThyKeyboardDispatcher extends ThyEventDispatcher {
    constructor(document, ngZone) {
        super(document, ngZone, 'keydown');
    }
    keydown(auditTimeInMs = DEFAULT_KEYDOWN_TIME) {
        return this.subscribe(auditTimeInMs);
    }
}
ThyKeyboardDispatcher.ɵfac = function ThyKeyboardDispatcher_Factory(t) { return new (t || ThyKeyboardDispatcher)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ThyKeyboardDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyKeyboardDispatcher_Factory() { return new ThyKeyboardDispatcher(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i0.NgZone)); }, token: ThyKeyboardDispatcher, providedIn: "root" });
ThyKeyboardDispatcher.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyKeyboardDispatcher, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();

class ThyClickPositioner {
    constructor(clickDispatcher) {
        this.clickDispatcher = clickDispatcher;
        this.lastPosition = null;
        this.initialized = false;
    }
    get lastClickPosition() {
        return this.lastPosition;
    }
    runTaskUseLastPosition(task) {
        setTimeout(() => {
            task(this.lastClickPosition);
        });
    }
    initialize() {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.clickDispatcher.clicked(0).subscribe((event) => {
            this.lastPosition = { x: event.clientX, y: event.clientY };
        });
    }
}
ThyClickPositioner.ɵfac = function ThyClickPositioner_Factory(t) { return new (t || ThyClickPositioner)(ɵngcc0.ɵɵinject(ThyClickDispatcher)); };
ThyClickPositioner.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyClickPositioner_Factory() { return new ThyClickPositioner(i0.ɵɵinject(ThyClickDispatcher)); }, token: ThyClickPositioner, providedIn: "root" });
ThyClickPositioner.ctorParameters = () => [
    { type: ThyClickDispatcher }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyClickPositioner, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ThyClickDispatcher }]; }, null); })();

const availablePrefixes = ['moz', 'ms', 'webkit'];
function requestAnimationFramePolyfill() {
    let lastTime = 0;
    return function (callback) {
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = setTimeout(() => {
            callback(currTime + timeToCall);
        }, timeToCall); // setTimeout type warn
        lastTime = currTime + timeToCall;
        return id;
    };
}
function getRequestAnimationFrame() {
    if (typeof window === 'undefined') {
        return () => 0;
    }
    if (window.requestAnimationFrame) {
        // https://github.com/vuejs/vue/issues/4465
        return window.requestAnimationFrame.bind(window);
    }
    const prefix = availablePrefixes.filter(key => `${key}RequestAnimationFrame` in window)[0];
    return prefix ? window[`${prefix}RequestAnimationFrame`] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(id) {
    if (typeof window === 'undefined') {
        return null;
    }
    if (window.cancelAnimationFrame) {
        return window.cancelAnimationFrame(id);
    }
    const prefix = availablePrefixes.filter(key => `${key}CancelAnimationFrame` in window || `${key}CancelRequestAnimationFrame` in window)[0];
    return prefix
        ? (window[`${prefix}CancelAnimationFrame`] || window[`${prefix}CancelRequestAnimationFrame`])
            // @ts-ignore
            .call(this, id)
        : clearTimeout(id);
}
const reqAnimFrame = getRequestAnimationFrame();

function easeInOutCubic(t, b, c, d) {
    const cc = c - b;
    let tt = t / (d / 2);
    if (tt < 1) {
        return (cc / 2) * tt * tt * tt + b;
    }
    else {
        return (cc / 2) * ((tt -= 2) * tt * tt + 2) + b;
    }
}
class ThyScrollService {
    constructor(document) {
        this.document = document;
    }
    /** Set the position of the scroll bar of `element`. */
    setScrollTop(element, topValue = 0) {
        if (element === window) {
            this.document.body.scrollTop = topValue;
            this.document.documentElement.scrollTop = topValue;
        }
        else {
            element.scrollTop = topValue;
        }
    }
    /** Get the position of the scoll bar of `element`. */
    getScroll(element, top = true) {
        const target = element ? element : window;
        const prop = top ? 'pageYOffset' : 'pageXOffset';
        const method = top ? 'scrollTop' : 'scrollLeft';
        const isWindow = target === window;
        let ret = isWindow ? target[prop] : target[method];
        if (isWindow && typeof ret !== 'number') {
            ret = this.document.documentElement[method];
        }
        return ret;
    }
    /**
     * Scroll `element` to some position with animation.
     *
     * @param container container, `window` by default
     * @param topValue Scroll to `top`, 0 by default
     * @param easing Transition curve, `easeInOutCubic` by default
     * @param callback callback invoked when transition is done
     */
    scrollTo(container, topValue = 0, easing, callback) {
        const target = container ? container : window;
        const scrollTop = this.getScroll(target);
        const startTime = Date.now();
        const frameFunc = () => {
            const timestamp = Date.now();
            const time = timestamp - startTime;
            this.setScrollTop(target, (easing || easeInOutCubic)(time, scrollTop, topValue, 450));
            if (time < 450) {
                reqAnimFrame(frameFunc);
            }
            else {
                if (callback) {
                    callback();
                }
            }
        };
        reqAnimFrame(frameFunc);
    }
}
ThyScrollService.ɵfac = function ThyScrollService_Factory(t) { return new (t || ThyScrollService)(ɵngcc0.ɵɵinject(DOCUMENT)); };
ThyScrollService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyScrollService_Factory() { return new ThyScrollService(i0.ɵɵinject(i1.DOCUMENT)); }, token: ThyScrollService, providedIn: "root" });
ThyScrollService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyScrollService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();

class AnimationDuration {
}
AnimationDuration.SLOW = '0.3s'; // Modal
AnimationDuration.BASE = '0.2s';
AnimationDuration.FAST = '0.1s'; // Tooltip
class AnimationCurves {
}
AnimationCurves.EASE_BASE_OUT = 'cubic-bezier(0.7, 0.3, 0.1, 1)';
AnimationCurves.EASE_BASE_IN = 'cubic-bezier(0.9, 0, 0.3, 0.7)';
AnimationCurves.EASE_OUT = 'cubic-bezier(0.215, 0.61, 0.355, 1)';
AnimationCurves.EASE_IN = 'cubic-bezier(0.55, 0.055, 0.675, 0.19)';
AnimationCurves.EASE_IN_OUT = 'cubic-bezier(0.645, 0.045, 0.355, 1)';
AnimationCurves.EASE_OUT_BACK = 'cubic-bezier(0.12, 0.4, 0.29, 1.46)';
AnimationCurves.EASE_IN_BACK = 'cubic-bezier(0.71, -0.46, 0.88, 0.6)';
AnimationCurves.EASE_IN_OUT_BACK = 'cubic-bezier(0.71, -0.46, 0.29, 1.46)';
AnimationCurves.EASE_OUT_CIRC = 'cubic-bezier(0.08, 0.82, 0.17, 1)';
AnimationCurves.EASE_IN_CIRC = 'cubic-bezier(0.6, 0.04, 0.98, 0.34)';
AnimationCurves.EASE_IN_OUT_CIRC = 'cubic-bezier(0.78, 0.14, 0.15, 0.86)';
AnimationCurves.EASE_OUT_QUINT = 'cubic-bezier(0.23, 1, 0.32, 1)';
AnimationCurves.EASE_IN_QUINT = 'cubic-bezier(0.755, 0.05, 0.855, 0.06)';
AnimationCurves.EASE_IN_OUT_QUINT = 'cubic-bezier(0.86, 0, 0.07, 1)';

const fadeMotion = trigger('fadeMotion', [
    transition(':enter', [style({ opacity: 0 }), animate(`${AnimationDuration.BASE}`, style({ opacity: 1 }))]),
    transition(':leave', [style({ opacity: 1 }), animate(`${AnimationDuration.BASE}`, style({ opacity: 0 }))])
]);

const POSITION_MAP = {
    top: {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom'
    },
    topCenter: {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom'
    },
    topLeft: {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom'
    },
    topRight: {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom'
    },
    right: {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center'
    },
    rightTop: {
        originX: 'end',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'top'
    },
    rightBottom: {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'bottom'
    },
    bottom: {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top'
    },
    bottomCenter: {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top'
    },
    bottomLeft: {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top'
    },
    bottomRight: {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top'
    },
    left: {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center'
    },
    leftTop: {
        originX: 'start',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'top'
    },
    leftBottom: {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'bottom'
    }
};
const EXPANDED_DROPDOWN_POSITIONS = [
    POSITION_MAP.bottomLeft,
    POSITION_MAP.bottomRight,
    POSITION_MAP.topLeft,
    POSITION_MAP.topRight
];

const connectionFallbackPositionsMap = {
    top: ['topLeft', 'topRight', 'bottom', 'bottomLeft', 'bottomRight'],
    topLeft: ['top', 'topRight', 'bottomLeft', 'bottom', 'bottomRight'],
    topRight: ['top', 'topLeft', 'bottomRight', 'bottom', 'bottomLeft'],
    bottom: ['bottomLeft', 'bottomRight', 'top', 'topLeft', 'topRight'],
    bottomLeft: ['bottom', 'bottomRight', 'topLeft', 'top', 'topRight'],
    bottomRight: ['bottom', 'bottomLeft', 'topRight', 'top', 'topLeft'],
    left: ['leftTop', 'leftBottom', 'right', 'rightTop', 'rightBottom'],
    leftTop: ['left', 'leftBottom', 'rightTop', 'right', 'rightBottom'],
    leftBottom: ['left', 'leftTop', 'rightBottom', 'right', 'rightTop'],
    right: ['rightTop', 'rightBottom', 'left', 'leftTop', 'leftBottom'],
    rightTop: ['right', 'rightBottom', 'leftTop', 'left', 'leftBottom'],
    rightBottom: ['right', 'rightTop', 'leftBottom', 'left', 'leftTop']
};
function buildConnectedPositionOffset(placement, offset) {
    const connectedPositionOffset = {};
    if (placement.startsWith('top')) {
        connectedPositionOffset.offsetY = -offset;
    }
    else if (placement.startsWith('bottom')) {
        connectedPositionOffset.offsetY = offset;
    }
    else if (placement.startsWith('left')) {
        connectedPositionOffset.offsetX = -offset;
    }
    else if (placement.startsWith('right')) {
        connectedPositionOffset.offsetX = offset;
    }
    else {
        // do nothings
    }
    return connectedPositionOffset;
}
function buildConnectedPositionPair(placement, offset, panelClassPrefix) {
    const position = Object.assign(Object.assign({}, POSITION_MAP[placement]), (offset ? buildConnectedPositionOffset(placement, offset) : null));
    if (panelClassPrefix) {
        position.panelClass = `${panelClassPrefix}-${placement}`;
    }
    return position;
}
function getFallbackPlacements(placement) {
    return connectionFallbackPositionsMap[placement] || [];
}
/**
 * get flexible positions by placement, return placement position and it's fallback connection position
 * @example
 * getFlexiblePositions('top', 10, 'thy-overlay')
 * [{topPosition}, {topLeftPosition}, {topRightPosition}, {bottomPosition}, {bottomLeftPosition}, {bottomRightPosition},]
 * @returns [ConnectionPositionPair]
 */
function getFlexiblePositions(placement, offset, panelClassPrefix) {
    const fallbackPlacements = getFallbackPlacements(placement);
    return [placement, ...fallbackPlacements].map(placementName => {
        return buildConnectedPositionPair(placementName, offset, panelClassPrefix);
    });
}
function getPlacementByPosition(position) {
    const keyList = ['originX', 'originY', 'overlayX', 'overlayY'];
    for (const placement in POSITION_MAP) {
        if (keyList.every(key => position[key] === POSITION_MAP[placement][key])) {
            return placement;
        }
    }
}

class ThyOverlayDirectiveBase {
    constructor(elementRef, platform, focusMonitor, ngZone) {
        this.initialized = false;
        /** Trigger Overlay */
        this._trigger = 'click';
        this.manualListeners = new Map();
        this.ngUnsubscribe$ = new Subject();
        this.showDelay = 0;
        this.hideDelay = 0;
        this.touchendHideDelay = 0;
        this.disabled = false;
        this.elementRef = elementRef;
        this.platform = platform;
        this.focusMonitor = focusMonitor;
        this.ngZone = ngZone;
    }
    get trigger() {
        return this._trigger;
    }
    set trigger(value) {
        this._trigger = value;
        // Trigger reinitialize when trigger changed which can't contain first
        if (this.initialized) {
            this.clearEventListeners();
            this.initialize();
        }
    }
    clearEventListeners() {
        this.manualListeners.forEach((listener, event) => {
            this.elementRef.nativeElement.removeEventListener(event, listener);
        });
        this.manualListeners.clear();
        this.focusMonitor.stopMonitoring(this.elementRef);
    }
    clearTimer() {
        if (this.showTimeoutId) {
            clearTimeout(this.showTimeoutId);
        }
        if (this.hideTimeoutId) {
            clearTimeout(this.hideTimeoutId);
        }
    }
    initialize() {
        this.initialized = true;
        const element = this.elementRef.nativeElement;
        if (!this.platform.IOS && !this.platform.ANDROID) {
            if (this.trigger === 'hover') {
                this.manualListeners
                    .set('mouseenter', () => {
                    this.show();
                })
                    .set('mouseleave', (event) => {
                    // element which mouse moved to
                    const overlayElement = this.overlayRef && this.overlayRef.overlayElement;
                    const toElement = event['toElement'] || event.relatedTarget;
                    // if element which moved to is in overlayElement, don't hide tooltip
                    if (overlayElement && overlayElement.contains && overlayElement.contains(toElement) && this.tooltipPin) {
                        fromEvent(overlayElement, 'mouseleave')
                            .pipe(take(1))
                            .subscribe(() => {
                            this.hide();
                        });
                    }
                    else {
                        this.hide();
                    }
                    // if showDelay is too long and mouseleave immediately, overlayRef is not exist, we should clearTimeout
                    if (!this.overlayRef) {
                        this.clearTimer();
                    }
                });
            }
            else if (this.trigger === 'focus') {
                this.focusMonitor
                    .monitor(this.elementRef)
                    .pipe(takeUntil(this.ngUnsubscribe$))
                    .subscribe(origin => {
                    // Note that the focus monitor runs outside the Angular zone.
                    if (!origin) {
                        this.ngZone.run(() => this.hide(0));
                    }
                    else {
                        this.ngZone.run(() => this.show());
                    }
                });
                // this.manualListeners.set('focus', () => this.show());
                // this.manualListeners.set('blur', () => this.hide());
            }
            else if (this.trigger === 'click') {
                this.manualListeners.set('click', () => this.show());
            }
            else {
                throw new Error(`${this.trigger} is not support, only support hover | focus | click`);
            }
        }
        else {
            const touchendListener = () => {
                // this.hide(this.touchendHideDelay);
                setTimeout(() => {
                    this.hide();
                }, this.touchendHideDelay);
            };
            // Reserve extensions for mobile in the future
            this.manualListeners
                .set('touchend', touchendListener)
                .set('touchcancel', touchendListener)
                .set('touchstart', () => {
                this.show();
            });
        }
        this.manualListeners.forEach((listener, event) => element.addEventListener(event, listener));
    }
    dispose() {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
        if (this.overlayRef) {
            this.overlayRef.dispose();
        }
        this.clearEventListeners();
        this.clearTimer();
    }
}

class ThyAbstractOverlayRef {
}
// Counter for unique overlay ids.
const uniqueIdMap = {};
function getUniqueId(name) {
    if (uniqueIdMap[name] !== undefined) {
        uniqueIdMap[name] = uniqueIdMap[name] + 1;
    }
    else {
        uniqueIdMap[name] = 0;
    }
    return uniqueIdMap[name];
}
class ThyAbstractInternalOverlayRef extends ThyAbstractOverlayRef {
    constructor(options, overlayRef, containerInstance, config) {
        super();
        this.options = options;
        this.overlayRef = overlayRef;
        this.config = config;
        /** Whether the user is allowed to close the dialog. */
        this.backdropClosable = this.config.backdropClosable;
        /** Subject for notifying the user that the dialog has finished opening. */
        this._afterOpened = new Subject();
        /** Subject for notifying the user that the dialog has finished closing. */
        this._afterClosed = new Subject();
        /** Subject for notifying the user that the dialog has started closing. */
        this._beforeClosed = new Subject();
        this.containerInstance = containerInstance;
        // Pass the id along to the container.
        this.id = containerInstance.id = config.id ? config.id : `thy-${this.options.name}-${getUniqueId(this.options.name)}`;
        // Emit when opening animation completes
        containerInstance.animationOpeningDone.pipe(take(1)).subscribe(() => {
            this._afterOpened.next();
            if (this.options.disposeWhenClose) {
                this._afterOpened.complete();
            }
        });
        // Dispose overlay when closing animation is complete
        containerInstance.animationClosingDone.pipe(take(1)).subscribe(() => {
            if (this.options.disposeWhenClose) {
                this.overlayRef.dispose();
            }
        });
        // Dispose overlay when container after destroy
        containerInstance.containerDestroy.pipe(take(1)).subscribe(() => {
            if (this.options.disposeWhenClose) {
                // component element has not been deleted when the component destroy, so use promise wait for component element destroyed
                Promise.resolve().then(() => {
                    this.overlayRef.dispose();
                });
            }
        });
        overlayRef.detachments().subscribe(() => {
            this._beforeClosed.next(this._result);
            this._beforeClosed.complete();
            this._afterClosed.next(this._result);
            this._afterClosed.complete();
            this.componentInstance = null;
            this.overlayRef.dispose();
        });
        // ESC close
        overlayRef
            .keydownEvents()
            .pipe(filter(event => event.keyCode === ESCAPE && this.backdropClosable))
            .subscribe(() => this.close());
    }
    /** Fetches the position strategy object from the overlay ref. */
    getPositionStrategy() {
        return this.overlayRef.getConfig().positionStrategy;
    }
    /**
     * Close the overlay.
     * @param overlayResult Optional result to return to the dialog opener.
     */
    close(overlayResult) {
        this._result = overlayResult;
        // Transition the backdrop in parallel to the overlay.
        this._beforeClosed.next(overlayResult);
        if (this.options.disposeWhenClose) {
            this._beforeClosed.complete();
        }
        this.overlayRef.detachBackdrop();
        this.containerInstance.startExitAnimation();
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    afterOpened() {
        return this._afterOpened.asObservable();
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    afterClosed() {
        return this._afterClosed.asObservable();
    }
    /**
     * Gets an observable that is notified when the dialog has started closing.
     */
    beforeClosed() {
        return this._beforeClosed.asObservable();
    }
    /**
     * Gets an observable that emits when the overlay's backdrop has been clicked.
     */
    backdropClick() {
        return this.overlayRef.backdropClick();
    }
    /**
     * Gets an observable that emits when keydown events are targeted on the overlay.
     */
    keydownEvents() {
        return this.overlayRef.keydownEvents();
    }
    /** Get overlay ref */
    getOverlayRef() {
        return this.overlayRef;
    }
    /**
     * Updates the overlay's position when is GlobalPositionStrategy
     * @param position New overlay position.
     */
    updateGlobalPosition(position) {
        const strategy = this.getPositionStrategy();
        if (!(strategy instanceof GlobalPositionStrategy)) {
            throw new Error(`current strategy is not GlobalPositionStrategy`);
        }
        if (position && (position.left || position.right)) {
            position.left ? strategy.left(position.left) : strategy.right(position.right);
        }
        else {
            strategy.centerHorizontally();
        }
        if (position && (position.top || position.bottom)) {
            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
        }
        else {
            strategy.centerVertically();
        }
        this.overlayRef.updatePosition();
        return this;
    }
}

class ThyAbstractOverlayConfig {
    constructor() {
        /** Custom class for the overlay pane. */
        this.panelClass = '';
        /** Whether the dialog has a backdrop. */
        this.hasBackdrop = true;
        /** Custom class for the backdrop, */
        this.backdropClass = '';
        /** Whether the user can use escape or clicking on the backdrop to close the overlay. */
        this.backdropClosable = true;
        /** Width of the dialog. */
        this.width = '';
        /** Height of the dialog. */
        this.height = '';
        /** Data being injected into the child component. */
        this.initialState = null;
        /** ID of the element that describes the dialog. */
        this.ariaDescribedBy = null;
        /** Aria label to assign to the dialog element */
        this.ariaLabel = null;
        /** Whether the dialog should focus the first focusable element on open. */
        this.autoFocus = true;
        /**
         * Whether the dialog should restore focus to the
         * previously-focused element, after it's closed.
         */
        this.restoreFocus = true;
        /**
         * Whether the dialog should close when the user goes backwards/forwards in history.
         * Note that this usually doesn't include clicking on links (unless the user is using
         * the `HashLocationStrategy`).
         */
        this.closeOnNavigation = true;
    }
}

function throwPopoverContentAlreadyAttachedError(name) {
    throw Error(`Attempting to attach ${name} content after content is already attached`);
}
class ThyAbstractOverlayContainer {
    constructor(options, changeDetectorRef) {
        this.options = options;
        this.changeDetectorRef = changeDetectorRef;
        this.animationStateChanged = new EventEmitter();
        this.containerDestroy = new Subject();
    }
    /** Before detach content*/
    beforeDetachPortal() { }
    /**
     * Attach a TemplatePortal as content to this overlay container.
     * @param portal Portal to be attached as the overlay content.
     */
    attachTemplatePortal(portal) {
        if (this.portalOutlet.hasAttached()) {
            throwPopoverContentAlreadyAttachedError(this.options.name);
        }
        this.beforeAttachPortal();
        return this.portalOutlet.attachTemplatePortal(portal);
    }
    /**
     * Attach a ComponentPortal as content to this overlay container.
     * @param portal Portal to be attached as the overlay content.
     */
    attachComponentPortal(portal) {
        if (this.portalOutlet.hasAttached()) {
            throwPopoverContentAlreadyAttachedError(this.options.name);
        }
        this.beforeAttachPortal();
        return this.portalOutlet.attachComponentPortal(portal);
    }
    startExitAnimation() {
        if (this.options.animationEnabled) {
            this.animationState = 'exit';
        }
        else {
            // this.animationClosingDone.
        }
        this.beforeDetachPortal();
        // Mark the container for check so it can react if the
        // view container is using OnPush change detection.
        this.changeDetectorRef.markForCheck();
    }
    destroy() {
        this.containerDestroy.next();
    }
}

class ThyAbstractOverlayService {
    constructor(options, // component name, e.g: dialog | popover | slide
    overlay, injector, defaultConfig, scrollStrategy) {
        this.options = options;
        this.overlay = overlay;
        this.injector = injector;
        this.defaultConfig = defaultConfig;
        this.scrollStrategy = scrollStrategy;
        this.openedOverlays = [];
        this._afterAllClosed = new Subject();
        this._afterOpened = new Subject();
    }
    /** Attach component or template ref to overlay container */
    attachUpperOverlayContent(componentOrTemplateRef, containerInstance, overlayRef, config) {
        // Create a reference to the dialog we're creating in order to give the user a handle
        // to modify and close it.
        const upperOverlayRef = this.createUpperOverlayRef(overlayRef, containerInstance, config);
        // When the backdrop is clicked, we want to close it.
        if (config.hasBackdrop) {
            overlayRef.backdropClick().subscribe(() => {
                if (upperOverlayRef.backdropClosable) {
                    upperOverlayRef.close();
                }
            });
        }
        if (componentOrTemplateRef instanceof TemplateRef) {
            containerInstance.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, {
                $implicit: config.initialState,
                [`${this.options.name}Ref`]: upperOverlayRef
            }));
        }
        else {
            const injector = this.createInjector(config, upperOverlayRef, containerInstance);
            const contentRef = containerInstance.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, undefined, injector));
            if (config.initialState) {
                Object.assign(contentRef.instance, config.initialState);
            }
            upperOverlayRef.componentInstance = contentRef.instance;
        }
        return upperOverlayRef;
    }
    removeOpenedOverlay(upperOverlayRef) {
        const index = this.openedOverlays.indexOf(upperOverlayRef);
        if (index > -1) {
            this.openedOverlays.splice(index, 1);
            if (!this.openedOverlays.length) {
                this._afterAllClosed.next();
            }
        }
    }
    getUpperOverlayById(id) {
        return this.openedOverlays.find(overlay => overlay.id === id);
    }
    buildBaseOverlayConfig(config, defaultPanelClass) {
        const overlayConfig = new OverlayConfig({
            positionStrategy: this.overlay.position().global(),
            hasBackdrop: config.hasBackdrop,
            direction: config.direction,
            width: config.width,
            height: config.height,
            minWidth: config.minWidth,
            minHeight: config.minHeight,
            maxWidth: config.maxWidth,
            maxHeight: config.maxHeight,
            disposeOnNavigation: config.closeOnNavigation
        });
        if (config.backdropClass) {
            overlayConfig.backdropClass = config.backdropClass;
        }
        overlayConfig.panelClass = concatArray(config.panelClass, defaultPanelClass);
        return overlayConfig;
    }
    openUpperOverlay(componentOrTemplateRef, config) {
        config = Object.assign(Object.assign({}, this.defaultConfig), config);
        if (config.id && this.getUpperOverlayById(config.id)) {
            throw Error(`${this.options.name} with id ${config.id} exists already. The ${this.options.name} id must be unique.`);
        }
        const overlayConfig = this.buildOverlayConfig(config);
        const overlayRef = this.overlay.create(overlayConfig);
        const overlayContainer = this.attachUpperOverlayContainer(overlayRef, config);
        const upperOverlayRef = this.attachUpperOverlayContent(componentOrTemplateRef, overlayContainer, overlayRef, config);
        this.openedOverlays.push(upperOverlayRef);
        upperOverlayRef.afterClosed().subscribe(() => {
            this.removeOpenedOverlay(upperOverlayRef);
        });
        this._afterOpened.next(upperOverlayRef);
        return upperOverlayRef;
    }
    afterAllClosed() {
        return this._afterAllClosed;
    }
    afterOpened() {
        return this._afterOpened;
    }
    close(result) {
        if (this.openedOverlays.length > 0) {
            const lastOverlayRef = this.openedOverlays[this.openedOverlays.length - 1];
            if (lastOverlayRef) {
                lastOverlayRef.close(result);
            }
        }
    }
    closeAll() {
        let i = this.openedOverlays.length;
        while (i--) {
            // 不需要操作 openedOverlays, 因为 close 会触发 afterClosed 的订阅
            // 触发订阅后会自动从 openedOverlays 中移除
            this.openedOverlays[i].close();
        }
    }
    dispose() {
        this.closeAll();
        this._afterAllClosed.complete();
        this._afterOpened.complete();
    }
}

class UpdateHostClassService {
    constructor(renderer) {
        this.renderer = renderer;
        this._classNames = [];
    }
    initializeElement(element) {
        if (element instanceof ElementRef) {
            this._hostElement = element.nativeElement;
        }
        else {
            this._hostElement = element;
        }
        return this;
    }
    updateClass(classNames) {
        if (this._classNames) {
            this._classNames.forEach(className => {
                if (classNames.indexOf(className) < 0) {
                    this.removeClass(className);
                }
            });
        }
        const newClasses = [];
        classNames.forEach(className => {
            if (className) {
                newClasses.push(className);
                if (this._classNames.indexOf(className) < 0) {
                    this.addClass(className);
                }
            }
        });
        this._classNames = newClasses;
        return this;
    }
    updateClassByMap(classMap) {
        const newClasses = [];
        for (const key in classMap) {
            if (classMap.hasOwnProperty(key) && classMap[key]) {
                newClasses.push(key);
            }
        }
        this.updateClass(newClasses);
    }
    addClass(className) {
        this.renderer.addClass(this._hostElement, className);
        return this;
    }
    removeClass(className) {
        this.renderer.removeClass(this._hostElement, className);
        return this;
    }
}
UpdateHostClassService.ɵfac = function UpdateHostClassService_Factory(t) { return new (t || UpdateHostClassService)(ɵngcc0.ɵɵinject(ɵngcc0.Renderer2)); };
UpdateHostClassService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UpdateHostClassService, factory: UpdateHostClassService.ɵfac });
UpdateHostClassService.ctorParameters = () => [
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UpdateHostClassService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();

class ThyTranslate {
    instant(key, interpolateParams) {
        return key;
    }
    get(key, interpolateParams) {
        return new Observable((observer) => {
            observer.next(key);
        });
    }
}
ThyTranslate.ɵfac = function ThyTranslate_Factory(t) { return new (t || ThyTranslate)(); };
ThyTranslate.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyTranslate_Factory() { return new ThyTranslate(); }, token: ThyTranslate, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTranslate, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AnimationCurves, AnimationDuration, AnonymousClass, EXPANDED_DROPDOWN_POSITIONS, InputBoolean, InputCssPixel, InputNumber, MixinBase, POSITION_MAP, ScrollToService, ThyAbstractInternalOverlayRef, ThyAbstractOverlayConfig, ThyAbstractOverlayContainer, ThyAbstractOverlayRef, ThyAbstractOverlayService, ThyClickDispatcher, ThyClickPositioner, ThyEventDispatcher, ThyKeyboardDispatcher, ThyOverlayDirectiveBase, ThyScrollService, ThyTranslate, UpdateHostClassService, buildConnectedPositionOffset, buildConnectedPositionPair, cancelRequestAnimationFrame, fadeMotion, getFallbackPlacements, getFlexiblePositions, getPlacementByPosition, mixinDisabled, mixinLoadingDone, mixinUnsubscribe, reqAnimFrame, throwPopoverContentAlreadyAttachedError };

//# sourceMappingURL=ngx-tethys-core.js.map