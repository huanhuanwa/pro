import * as i0 from '@angular/core';
import { SecurityContext, Injectable, Inject, Component, ChangeDetectionStrategy, ViewEncapsulation, Renderer2, ElementRef, HostBinding, Input, NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import * as i3 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { UpdateHostClassService } from 'ngx-tethys/core';
import * as i1 from '@angular/platform-browser';
import { DomSanitizer } from '@angular/platform-browser';
import { of, forkJoin, throwError } from 'rxjs';
import * as i2 from '@angular/common/http';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { finalize, share, map, tap, catchError, take } from 'rxjs/operators';
import { coerceBooleanProperty } from 'ngx-tethys/util';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';
import * as ɵngcc2 from '@angular/common/http';
import * as ɵngcc3 from 'ngx-tethys/core';

const _c0 = ["*"];
class SvgIconConfig {
    constructor(data) {
        // Note that we can't use `instanceof SVGElement` here,
        // because it'll break during server-side rendering.
        if (!!data.nodeName) {
            this.svgElement = data;
        }
        else {
            this.url = data;
        }
    }
}
class ThyIconRegistry {
    constructor(sanitizer, httpClient, document) {
        this.sanitizer = sanitizer;
        this.httpClient = httpClient;
        this.document = document;
        this.defaultFontSetClass = 'wt-icon';
        this.internalIconMode = 'svg';
        this.svgIconConfigs = new Map();
        this.svgIconSetConfigs = new Map();
        this.inProgressUrlFetches = new Map();
    }
    get iconMode() {
        return this.internalIconMode;
    }
    getIconNameNotFoundError(iconName) {
        return Error(`Unable to find icon with the name "${iconName}"`);
    }
    getIconFailedToSanitizeLiteralError(literal) {
        return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by ` +
            `Angular's DomSanitizer. Attempted literal was "${literal}".`);
    }
    internalAddSvgIconSet(namespace, config) {
        const configNamespace = this.svgIconSetConfigs.get(namespace);
        if (configNamespace) {
            configNamespace.push(config);
        }
        else {
            this.svgIconSetConfigs.set(namespace, [config]);
        }
        return this;
    }
    cloneSvg(svg) {
        return svg.cloneNode(true);
    }
    fetchUrl(safeUrl) {
        if (safeUrl == null) {
            throw Error(`Cannot fetch icon from URL "${safeUrl}".`);
        }
        const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
        if (!url) {
            throw new Error(`The URL provided to ThyIconRegistry was not trusted as a resource URL ` +
                `via Angular's DomSanitizer. Attempted URL was "${url}".`);
        }
        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
        // already a request in progress for that URL. It's necessary to call share() on the
        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
        const inProgressFetch = this.inProgressUrlFetches.get(url);
        if (inProgressFetch) {
            return inProgressFetch;
        }
        else {
            // TODO(jelbourn): for some reason, the `finalize` operator "loses" the generic type on the
            // Observable. Figure out why and fix it.
            const req = this.httpClient.get(url, { responseType: 'text' }).pipe(finalize(() => this.inProgressUrlFetches.delete(url)), share());
            this.inProgressUrlFetches.set(url, req);
            return req;
        }
    }
    toSvgElement(element) {
        const svg = this.svgElementFromString('<svg></svg>');
        for (let i = 0; i < element.childNodes.length; i++) {
            if (element.childNodes[i].nodeType === this.document.ELEMENT_NODE) {
                svg.appendChild(element.childNodes[i].cloneNode(true));
            }
        }
        return svg;
    }
    extractSvgIconFromIconSet(iconSet, iconName) {
        // Use the `id="iconName"` syntax in order to escape special
        // characters in the ID (versus using the #iconName syntax).
        const iconSource = iconSet.querySelector(`[id="${iconName}"]`);
        if (!iconSource) {
            return null;
        }
        // Clone the element and remove the ID to prevent multiple elements from being added
        // to the page with the same ID.
        const iconElement = iconSource.cloneNode(true);
        iconElement.removeAttribute('id');
        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
        // the content of a new <svg> node.
        if (iconElement.nodeName.toLowerCase() === 'svg') {
            return this.setSvgAttributes(iconElement);
        }
        // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note
        // that the same could be achieved by referring to it via <use href="#id">, however the <use>
        // tag is problematic on Firefox, because it needs to include the current page path.
        if (iconElement.nodeName.toLowerCase() === 'symbol') {
            return this.setSvgAttributes(this.toSvgElement(iconElement));
        }
        // createElement('SVG') doesn't work as expected; the DOM ends up with
        // the correct nodes, but the SVG content doesn't render. Instead we
        // have to create an empty SVG node using innerHTML and append its content.
        // Elements created using DOMParser.parseFromString have the same problem.
        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
        const svg = this.svgElementFromString('<svg></svg>');
        // Clone the node so we don't remove it from the parent icon set element.
        svg.appendChild(iconElement);
        return this.setSvgAttributes(svg);
    }
    extractIconWithNameFromIconSetConfigs(iconName, iconSetConfigs) {
        // Iterate backwards, so icon sets added later have precedence.
        for (let i = iconSetConfigs.length - 1; i >= 0; i--) {
            const config = iconSetConfigs[i];
            if (config.svgElement) {
                const foundIcon = this.extractSvgIconFromIconSet(config.svgElement, iconName);
                if (foundIcon) {
                    return foundIcon;
                }
            }
        }
        return null;
    }
    svgElementFromString(str) {
        const div = this.document.createElement('DIV');
        div.innerHTML = str;
        const svg = div.querySelector('svg');
        if (!svg) {
            throw Error('<svg> tag not found');
        }
        return svg;
    }
    setSvgAttributes(svg) {
        svg.setAttribute('fit', '');
        svg.setAttribute('height', '1em');
        svg.setAttribute('width', '1em');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
        return svg;
    }
    createSvgElementForSingleIcon(responseText) {
        const svg = this.svgElementFromString(responseText);
        this.setSvgAttributes(svg);
        return svg;
    }
    loadSvgIconFromConfig(config) {
        return this.fetchUrl(config.url).pipe(map(svgText => this.createSvgElementForSingleIcon(svgText)));
    }
    loadSvgIconSetFromConfig(config) {
        // If the SVG for this icon set has already been parsed, do nothing.
        if (config.svgElement) {
            return of(config.svgElement);
        }
        return this.fetchUrl(config.url).pipe(map(svgText => {
            // It is possible that the icon set was parsed and cached by an earlier request, so parsing
            // only needs to occur if the cache is yet unset.
            if (!config.svgElement) {
                config.svgElement = this.svgElementFromString(svgText);
            }
            return config.svgElement;
        }));
    }
    getSvgFromConfig(config) {
        if (config.svgElement) {
            // We already have the SVG element for this icon, return a copy.
            return of(this.cloneSvg(config.svgElement));
        }
        else {
            // Fetch the icon from the config's URL, cache it, and return a copy.
            return this.loadSvgIconFromConfig(config).pipe(tap(svg => (config.svgElement = svg)), map(svg => this.cloneSvg(svg)));
        }
    }
    getSvgFromIconSetConfigs(name, iconSetConfigs) {
        // For all the icon set SVG elements we've fetched, see if any contain an icon with the
        // requested name.
        const namedIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
        if (namedIcon) {
            // We could cache namedIcon in svgIconConfigs, but since we have to make a copy every
            // time anyway, there's probably not much advantage compared to just always extracting
            // it from the icon set.
            return of(namedIcon);
        }
        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
        // fetched, fetch them now and look for iconName in the results.
        const iconSetFetchRequests = iconSetConfigs
            .filter(iconSetConfig => !iconSetConfig.svgElement)
            .map(iconSetConfig => {
            return this.loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError((err) => {
                const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);
                // Swallow errors fetching individual URLs so the
                // combined Observable won't necessarily fail.
                console.error(`Loading icon set URL: ${url} failed: ${err.message}`);
                return of(null);
            }));
        });
        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
        // cached SVG element (unless the request failed), and we can check again for the icon.
        return forkJoin(iconSetFetchRequests).pipe(map(() => {
            const foundIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
            if (!foundIcon) {
                throw this.getIconNameNotFoundError(name);
            }
            return foundIcon;
        }));
    }
    internalAddSvgIconConfig(namespace, iconName, config) {
        this.svgIconConfigs.set(this.buildIconKey(namespace, iconName), config);
        return this;
    }
    buildIconKey(namespace, name) {
        return namespace + ':' + name;
    }
    splitIconName(iconName) {
        if (!iconName) {
            return ['', ''];
        }
        const parts = iconName.split(':');
        switch (parts.length) {
            case 1:
                return ['', parts[0]]; // Use default namespace.
            case 2:
                return parts;
            default:
                throw Error(`Invalid icon name: "${iconName}"`);
        }
    }
    addSvgIconSetInNamespace(namespace, url) {
        return this.internalAddSvgIconSet(namespace, new SvgIconConfig(url));
    }
    addSvgIconSet(url) {
        return this.addSvgIconSetInNamespace('', url);
    }
    addSvgIconSetLiteralInNamespace(namespace, literal) {
        const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);
        if (!sanitizedLiteral) {
            throw this.getIconFailedToSanitizeLiteralError(literal);
        }
        const svgElement = this.svgElementFromString(sanitizedLiteral);
        return this.internalAddSvgIconSet(namespace, new SvgIconConfig(svgElement));
    }
    addSvgIconSetLiteral(literal) {
        return this.addSvgIconSetLiteralInNamespace('', literal);
    }
    /**
     * Registers an icon by URL in the specified namespace.
     * @param namespace Namespace in which the icon should be registered.
     * @param iconName Name under which the icon should be registered.
     * @param url
     */
    addSvgIconInNamespace(namespace, iconName, url) {
        return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
    }
    /**
     * Registers an icon by URL in the default namespace.
     * @param iconName Name under which the icon should be registered.
     * @param url
     */
    addSvgIcon(iconName, url) {
        return this.addSvgIconInNamespace('', iconName, url);
    }
    /**
     * Registers an icon using an HTML string in the default namespace.
     * @param iconName Name under which the icon should be registered.
     * @param literal SVG source of the icon.
     */
    addSvgIconLiteral(iconName, literal) {
        return this.addSvgIconLiteralInNamespace('', iconName, literal);
    }
    /**
     * Registers an icon using an HTML string in the specified namespace.
     * @param namespace Namespace in which the icon should be registered.
     * @param iconName Name under which the icon should be registered.
     * @param literal SVG source of the icon.
     */
    addSvgIconLiteralInNamespace(namespace, iconName, literal) {
        const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);
        if (!sanitizedLiteral) {
            throw this.getIconFailedToSanitizeLiteralError(literal);
        }
        const svgElement = this.createSvgElementForSingleIcon(sanitizedLiteral);
        return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
    }
    getDefaultFontSetClass() {
        return this.defaultFontSetClass;
    }
    getFontSetClassByAlias(fontSet) {
        return fontSet;
    }
    getSvgIcon(name, namespace = '') {
        // Return (copy of) cached icon if possible.
        const key = this.buildIconKey(namespace, name);
        const config = this.svgIconConfigs.get(key);
        if (config) {
            return this.getSvgFromConfig(config);
        }
        // See if we have any icon sets registered for the namespace.
        const iconSetConfigs = this.svgIconSetConfigs.get(namespace);
        if (iconSetConfigs) {
            return this.getSvgFromIconSetConfigs(name, iconSetConfigs);
        }
        return throwError(this.getIconNameNotFoundError(key));
    }
    setIconMode(mode) {
        this.internalIconMode = mode;
    }
}
ThyIconRegistry.ɵfac = function ThyIconRegistry_Factory(t) { return new (t || ThyIconRegistry)(ɵngcc0.ɵɵinject(ɵngcc1.DomSanitizer), ɵngcc0.ɵɵinject(ɵngcc2.HttpClient), ɵngcc0.ɵɵinject(DOCUMENT)); };
ThyIconRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyIconRegistry_Factory() { return new ThyIconRegistry(i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(i3.DOCUMENT)); }, token: ThyIconRegistry, providedIn: "root" });
ThyIconRegistry.ctorParameters = () => [
    { type: DomSanitizer },
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyIconRegistry, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.DomSanitizer }, { type: ɵngcc2.HttpClient }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();

let printErrorWhenNotFound = true;
function setPrintErrorWhenIconNotFound(value) {
    printErrorWhenNotFound = value;
}
function getWhetherPrintErrorWhenIconNotFound() {
    return printErrorWhenNotFound;
}

const iconSuffixMap = {
    fill: 'fill',
    twotone: 'tt'
};
class ThyIconComponent {
    constructor(updateHostClassService, render, elementRef, iconRegistry) {
        this.updateHostClassService = updateHostClassService;
        this.render = render;
        this.elementRef = elementRef;
        this.iconRegistry = iconRegistry;
        this.className = true;
        this.isInitialized = false;
        this.iconType = 'outline';
        updateHostClassService.initializeElement(elementRef.nativeElement);
    }
    ngOnInit() {
        this.updateClasses();
        this.isInitialized = true;
    }
    ngOnChanges(changes) {
        if (this.isInitialized) {
            if (changes['iconName'] || changes['iconSet'] || changes['iconTwotoneColor'] || changes['iconType']) {
                this.updateClasses();
            }
            else if (changes['iconRotate']) {
                this.setStyleRotate();
            }
        }
        if (changes['iconLegging']) {
            if (coerceBooleanProperty(this.iconLegging)) {
                this.updateHostClassService.addClass('thy-icon-legging');
            }
            else {
                this.updateHostClassService.removeClass('thy-icon-legging');
            }
        }
    }
    updateClasses() {
        const [namespace, iconName] = this.iconRegistry.splitIconName(this.iconName);
        if (iconName) {
            if (this.iconRegistry.iconMode === 'svg') {
                this.iconRegistry
                    .getSvgIcon(this.buildIconNameByType(iconName), namespace)
                    .pipe(take(1))
                    .subscribe(svg => this.setSvgElement(svg), (error) => {
                    if (getWhetherPrintErrorWhenIconNotFound()) {
                        console.error(`Error retrieving icon: ${error.message}`);
                    }
                });
                this.updateHostClassService.updateClass([
                    `thy-icon${namespace ? `-${namespace}` : ``}-${this.buildIconNameByType(iconName)}`
                ]);
            }
            else {
                const fontSetClass = this.iconSet
                    ? this.iconRegistry.getFontSetClassByAlias(this.iconSet)
                    : this.iconRegistry.getDefaultFontSetClass();
                this.updateHostClassService.updateClass([fontSetClass, `${fontSetClass}-${this.iconName}`]);
            }
        }
    }
    setStyleRotate() {
        if (this.iconRotate !== undefined) {
            this.render.setStyle(this.elementRef.nativeElement.querySelector('svg'), 'transform', `rotate(${this.iconRotate}deg)`);
        }
    }
    //#region svg element
    setSvgElement(svg) {
        this.clearSvgElement();
        // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.
        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
        // Do this before inserting the element into the DOM, in order to avoid a style recalculation.
        const styleTags = svg.querySelectorAll('style');
        for (let i = 0; i < styleTags.length; i++) {
            styleTags[i].textContent += ' ';
        }
        if (this.iconType === 'twotone') {
            const allPaths = svg.querySelectorAll('path');
            if (allPaths.length > 1) {
                allPaths.forEach((child, index) => {
                    if (child.getAttribute('id').includes('secondary-color')) {
                        child.setAttribute('fill', this.iconTwotoneColor);
                    }
                });
            }
        }
        // Note: we do this fix here, rather than the icon registry, because the
        // references have to point to the URL at the time that the icon was created.
        // if (this._location) {
        //     const path = this._location.getPathname();
        //     this._previousPath = path;
        //     this._cacheChildrenWithExternalReferences(svg);
        //     this._prependPathToReferences(path);
        // }
        if (this.iconLinearGradient) {
            this.setBaseUrl(svg);
            this.clearTitleElement(svg);
        }
        this.elementRef.nativeElement.appendChild(svg);
        this.setStyleRotate();
    }
    clearSvgElement() {
        const layoutElement = this.elementRef.nativeElement;
        let childCount = layoutElement.childNodes.length;
        // if (this._elementsWithExternalReferences) {
        //     this._elementsWithExternalReferences.clear();
        // }
        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that
        // we can't use innerHTML, because IE will throw if the element has a data binding.
        while (childCount--) {
            const child = layoutElement.childNodes[childCount];
            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid
            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.
            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {
                layoutElement.removeChild(child);
            }
        }
    }
    //#endregion
    buildIconNameByType(iconName) {
        if (this.iconType && ['fill', 'twotone'].indexOf(this.iconType) >= 0) {
            const suffix = iconSuffixMap[this.iconType];
            return iconName.includes(`-${suffix}`) ? iconName : `${iconName}-${suffix}`;
        }
        else {
            return iconName;
        }
    }
    /**
     * Support Safari SVG LinearGradient.
     *
     *
     * @param svg
     */
    setBaseUrl(svg) {
        const styleElements = svg.querySelectorAll('[style]');
        styleElements.forEach((n) => {
            if (n.style.cssText.includes('url')) {
                n.style.fill = n.style.fill.replace('url("', 'url("' + location.pathname);
            }
            if (n.style.cssText.includes('clip-path')) {
                n.style.clipPath = n.style.clipPath.replace('url("', 'url("' + location.pathname);
            }
        });
    }
    clearTitleElement(svg) {
        svg.querySelector('title').remove();
    }
}
ThyIconComponent.ɵfac = function ThyIconComponent_Factory(t) { return new (t || ThyIconComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.UpdateHostClassService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ThyIconRegistry)); };
ThyIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyIconComponent, selectors: [["thy-icon"]], hostVars: 2, hostBindings: function ThyIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-icon", ctx.className);
    } }, inputs: { iconType: ["thyIconType", "iconType"], iconTwotoneColor: ["thyTwotoneColor", "iconTwotoneColor"], iconName: ["thyIconName", "iconName"], iconRotate: ["thyIconRotate", "iconRotate"], iconSet: ["thyIconSet", "iconSet"], iconLegging: ["thyIconLegging", "iconLegging"], iconLinearGradient: ["thyIconLinearGradient", "iconLinearGradient"] }, features: [ɵngcc0.ɵɵProvidersFeature([UpdateHostClassService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ThyIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
ThyIconComponent.ctorParameters = () => [
    { type: UpdateHostClassService },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ThyIconRegistry }
];
ThyIconComponent.propDecorators = {
    className: [{ type: HostBinding, args: ['class.thy-icon',] }],
    iconType: [{ type: Input, args: ['thyIconType',] }],
    iconTwotoneColor: [{ type: Input, args: ['thyTwotoneColor',] }],
    iconName: [{ type: Input, args: ['thyIconName',] }],
    iconRotate: [{ type: Input, args: ['thyIconRotate',] }],
    iconSet: [{ type: Input, args: ['thyIconSet',] }],
    iconLegging: [{ type: Input, args: ['thyIconLegging',] }],
    iconLinearGradient: [{ type: Input, args: ['thyIconLinearGradient',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyIconComponent, [{
        type: Component,
        args: [{
                selector: 'thy-icon',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                providers: [UpdateHostClassService]
            }]
    }], function () { return [{ type: ɵngcc3.UpdateHostClassService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ThyIconRegistry }]; }, { className: [{
            type: HostBinding,
            args: ['class.thy-icon']
        }], iconType: [{
            type: Input,
            args: ['thyIconType']
        }], iconTwotoneColor: [{
            type: Input,
            args: ['thyTwotoneColor']
        }], iconName: [{
            type: Input,
            args: ['thyIconName']
        }], iconRotate: [{
            type: Input,
            args: ['thyIconRotate']
        }], iconSet: [{
            type: Input,
            args: ['thyIconSet']
        }], iconLegging: [{
            type: Input,
            args: ['thyIconLegging']
        }], iconLinearGradient: [{
            type: Input,
            args: ['thyIconLinearGradient']
        }] }); })();

class ThyIconModule {
}
ThyIconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyIconModule });
ThyIconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyIconModule_Factory(t) { return new (t || ThyIconModule)(); }, imports: [[CommonModule, FormsModule, HttpClientModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyIconModule, { declarations: function () { return [ThyIconComponent]; }, imports: function () { return [CommonModule, FormsModule, HttpClientModule]; }, exports: function () { return [ThyIconComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyIconModule, [{
        type: NgModule,
        args: [{
                declarations: [ThyIconComponent],
                imports: [CommonModule, FormsModule, HttpClientModule],
                exports: [ThyIconComponent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ThyIconComponent, ThyIconModule, ThyIconRegistry, getWhetherPrintErrorWhenIconNotFound, setPrintErrorWhenIconNotFound };

//# sourceMappingURL=ngx-tethys-icon.js.map