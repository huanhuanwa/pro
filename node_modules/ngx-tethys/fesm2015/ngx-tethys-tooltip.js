import { Overlay, ScrollDispatcher, OverlayModule } from '@angular/cdk/overlay';
import { FocusMonitor, A11yModule } from '@angular/cdk/a11y';
import { CommonModule } from '@angular/common';
import { TemplateRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, HostBinding, InjectionToken, Directive, ViewContainerRef, NgZone, Inject, Input, NgModule, Injectable } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { takeUntil, take } from 'rxjs/operators';
import { coerceArray, isString, coerceBooleanProperty } from 'ngx-tethys/util';
import { ComponentPortal } from '@angular/cdk/portal';
import { Subject } from 'rxjs';
import { trigger, state, style, transition, animate, keyframes } from '@angular/animations';
import { UpdateHostClassService, ThyOverlayDirectiveBase, getFlexiblePositions } from 'ngx-tethys/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngx-tethys/core';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/cdk/overlay';
import * as ɵngcc4 from '@angular/cdk/platform';
import * as ɵngcc5 from '@angular/cdk/a11y';

function ThyTooltipComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c0 = function (a0) { return { $implicit: a0 }; };
function ThyTooltipComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ThyTooltipComponent_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.content)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r0.data));
} }
function ThyTooltipComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.content, " ");
} }
const DEFAULT_TOOLTIP_OPTIONS = {
    showDelay: 200,
    hideDelay: 100,
    touchendHideDelay: 1500
};

// 'cubic-bezier(0, 0, 0.2, 1)';
// cubic-bezier(.17, .86, .73, .14)
const CUBIC_BEZIER = 'cubic-bezier(0.08, 0.82, 0.17, 1)';
/**
 * Animations used by ThyTooltip.
 * @docs-private
 */
const thyTooltipAnimations = {
    /** Animation that transitions a tooltip in and out. */
    tooltipState: trigger('state', [
        state('initial, void, hidden', style({ opacity: 0, transform: 'scale(0)' })),
        state('visible', style({ transform: 'scale(1)' })),
        transition('* => visible', animate(`200ms ${CUBIC_BEZIER}`, keyframes([
            style({ opacity: 0, transform: 'scale(0)', offset: 0 }),
            style({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),
            style({ opacity: 1, transform: 'scale(1)', offset: 1 })
        ]))),
        transition('* => hidden', animate(`100ms ${CUBIC_BEZIER}`, style({ opacity: 0 })))
    ])
};

class ThyTooltipComponent {
    constructor(changeDetectorRef, updateHostClassService, elementRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.updateHostClassService = updateHostClassService;
        this.addTooltipContainerClass = true;
        this.onHide = new Subject();
        this.closeOnInteraction = false;
        this.visibility = 'initial';
        this.tooltipClasses = [];
        this.isTemplateRef = false;
        this.updateHostClassService.initializeElement(elementRef);
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this._content = value;
        this.isTemplateRef = value instanceof TemplateRef;
    }
    updateClasses() {
        let classes = [];
        if (this.tooltipClasses) {
            classes = classes.concat(this.tooltipClasses);
        }
        this.updateHostClassService.updateClass(classes);
    }
    ngOnInit() { }
    markForCheck() {
        this.changeDetectorRef.markForCheck();
    }
    isVisible() {
        return this.visibility === 'visible';
    }
    show(delay) {
        // Cancel the delayed hide if it is scheduled
        if (this.hideTimeoutId) {
            clearTimeout(this.hideTimeoutId);
            this.hideTimeoutId = null;
        }
        // Body interactions should cancel the tooltip if there is a delay in showing.
        this.closeOnInteraction = true;
        this.showTimeoutId = setTimeout(() => {
            this.visibility = 'visible';
            this.showTimeoutId = null;
            this.markForCheck();
        }, delay);
    }
    hide(delay) {
        // Cancel the delayed show if it is scheduled
        if (this.showTimeoutId) {
            clearTimeout(this.showTimeoutId);
            this.showTimeoutId = null;
        }
        this.hideTimeoutId = setTimeout(() => {
            this.visibility = 'hidden';
            this.hideTimeoutId = null;
            this.markForCheck();
        }, delay);
    }
    animationStart() {
        this.closeOnInteraction = false;
    }
    animationDone(event) {
        const toState = event.toState;
        if (toState === 'hidden' && !this.isVisible()) {
            this.onHide.next();
        }
        if (toState === 'visible' || toState === 'hidden') {
            this.closeOnInteraction = true;
        }
    }
    afterHidden() {
        return this.onHide.asObservable();
    }
    setTooltipClass(classes) {
        this.tooltipClasses = coerceArray(classes);
        this.updateClasses();
        // this.markForCheck();
    }
}
ThyTooltipComponent.ɵfac = function ThyTooltipComponent_Factory(t) { return new (t || ThyTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.UpdateHostClassService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ThyTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyTooltipComponent, selectors: [["thy-tooltip"]], hostVars: 3, hostBindings: function ThyTooltipComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@state.start", function ThyTooltipComponent_animation_state_start_HostBindingHandler() { return ctx.animationStart(); })("@state.done", function ThyTooltipComponent_animation_state_done_HostBindingHandler($event) { return ctx.animationDone($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@state", ctx.visibility);
        ɵngcc0.ɵɵclassProp("thy-tooltip", ctx.addTooltipContainerClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([UpdateHostClassService])], decls: 5, vars: 2, consts: [[1, "thy-tooltip-arrow"], [1, "thy-tooltip-content"], [4, "ngIf", "ngIfElse"], ["text", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function ThyTooltipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, ThyTooltipComponent_ng_container_2_Template, 2, 4, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(3, ThyTooltipComponent_ng_template_3_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTemplateRef)("ngIfElse", _r1);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, data: { animation: [thyTooltipAnimations.tooltipState] }, changeDetection: 0 });
ThyTooltipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: UpdateHostClassService },
    { type: ElementRef }
];
ThyTooltipComponent.propDecorators = {
    addTooltipContainerClass: [{ type: HostBinding, args: [`class.thy-tooltip`,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTooltipComponent, [{
        type: Component,
        args: [{
                selector: 'thy-tooltip',
                template: "<div class=\"thy-tooltip-arrow\"></div>\n<div class=\"thy-tooltip-content\">\n  <ng-container *ngIf=\"isTemplateRef; else text\">\n    <ng-container *ngTemplateOutlet=\"content; context: { $implicit: data }\"></ng-container>\n  </ng-container>\n  <ng-template #text>\n    {{ content }}\n  </ng-template>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [thyTooltipAnimations.tooltipState],
                host: {
                    '[@state]': 'visibility',
                    '(@state.start)': 'animationStart()',
                    '(@state.done)': 'animationDone($event)'
                },
                providers: [UpdateHostClassService]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.UpdateHostClassService }, { type: ɵngcc0.ElementRef }]; }, { addTooltipContainerClass: [{
            type: HostBinding,
            args: [`class.thy-tooltip`]
        }] }); })();

class ThyTooltipConfig {
}
const THY_TOOLTIP_DEFAULT_CONFIG_TOKEN = new InjectionToken('thy-tooltip-default-config');
const thyTooltipDefaultConfig = {
    offset: 4,
    tooltipPin: false,
    scrollThrottleSeconds: 20,
    tooltipPanelClass: 'thy-tooltip-panel'
};
const THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER = {
    provide: THY_TOOLTIP_DEFAULT_CONFIG_TOKEN,
    useValue: thyTooltipDefaultConfig
};

class ThyTooltipDirective extends ThyOverlayDirectiveBase {
    constructor(overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, focusMonitor, thyTooltipConfig) {
        super(elementRef, platform, focusMonitor, ngZone);
        this.overlay = overlay;
        this.scrollDispatcher = scrollDispatcher;
        this.viewContainerRef = viewContainerRef;
        this.thyTooltipConfig = thyTooltipConfig;
        this.options = DEFAULT_TOOLTIP_OPTIONS;
        this.panelClassPrefix = 'thy-tooltip';
        this.touchendHideDelay = this.options.touchendHideDelay;
        // tslint:disable-next-line:no-input-rename
        this.placement = 'top';
        // tslint:disable-next-line:no-input-rename
        this.showDelay = this.options.showDelay;
        // tslint:disable-next-line:no-input-rename
        this.hideDelay = this.options.hideDelay;
        this._trigger = 'hover';
        this.tooltipPin = this.thyTooltipConfig.tooltipPin;
        this.options = DEFAULT_TOOLTIP_OPTIONS;
        this.scrollStrategy = overlay.scrollStrategies.reposition({
            scrollThrottle: this.thyTooltipConfig.scrollThrottleSeconds
        });
    }
    get content() {
        return this._content;
    }
    set content(value) {
        // If the content is not a string (e.g. number), convert it to a string and trim it.
        this._content = value && isString(value) ? `${value}`.trim() : value;
        if (!this._content && this.isTooltipVisible()) {
            this.hide(0);
        }
        else {
            this.updateTooltipContent();
        }
    }
    set thyTooltipClass(value) {
        this.tooltipClass = value;
        if (this.tooltipInstance) {
            this.setTooltipClass(this.tooltipClass);
        }
    }
    // tslint:disable-next-line:no-input-rename
    set thyTooltipTrigger(value) {
        this.trigger = value;
    }
    /** Disables the display of the tooltip. */
    set thyTooltipDisabled(value) {
        this.disabled = coerceBooleanProperty(value);
        // If tooltip is disabled, hide immediately.
        if (this.disabled) {
            this.hide(0);
        }
    }
    detach() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            this.overlayRef.detach();
        }
        this.tooltipInstance = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        const scrollableAncestors = this.scrollDispatcher.getAncestorScrollContainers(this.elementRef);
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay
            .position()
            .flexibleConnectedTo(this.elementRef)
            .withTransformOriginOn('.thy-tooltip-content')
            .withFlexibleDimensions(false)
            .withViewportMargin(8);
        strategy.withScrollableContainers(scrollableAncestors);
        strategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {
            if (this.tooltipInstance) {
                if (change.scrollableViewProperties.isOverlayClipped && this.tooltipInstance.isVisible()) {
                    // After position changes occur and the overlay is clipped by
                    // a parent scrollable then close the tooltip.
                    this.ngZone.run(() => this.hide(0));
                }
            }
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            panelClass: this.thyTooltipConfig.tooltipPanelClass,
            scrollStrategy: this.scrollStrategy,
            hasBackdrop: this.trigger === 'click',
            backdropClass: 'thy-tooltip-backdrop'
        });
        this.updatePosition();
        this.overlayRef
            .detachments()
            .pipe(takeUntil(this.ngUnsubscribe$))
            .subscribe(() => this.detach());
        this.overlayRef.backdropClick().subscribe(() => {
            this.overlayRef.detachBackdrop();
            this.hide();
        });
        return this.overlayRef;
    }
    updateTooltipContent() {
        // Must wait for the message to be painted to the tooltip so that the overlay can properly
        // calculate the correct positioning based on the size of the text.
        if (this.tooltipInstance) {
            this.tooltipInstance.content = this.content;
            this.tooltipInstance.data = this.data;
            this.tooltipInstance.markForCheck();
            this.ngZone.onMicrotaskEmpty
                .asObservable()
                .pipe(take(1), takeUntil(this.ngUnsubscribe$))
                .subscribe(() => {
                if (this.tooltipInstance) {
                    this.overlayRef.updatePosition();
                }
            });
        }
    }
    /** Returns true if the tooltip is currently visible to the user */
    isTooltipVisible() {
        return !!this.tooltipInstance && this.tooltipInstance.isVisible();
    }
    /** Updates the position of the current tooltip. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        const connectionPositions = getFlexiblePositions(this.placement, this.tooltipOffset || this.thyTooltipConfig.offset, this.panelClassPrefix);
        position.withPositions(connectionPositions);
    }
    setTooltipClass(tooltipClass) {
        if (this.tooltipInstance) {
            this.tooltipInstance.setTooltipClass(tooltipClass);
        }
    }
    ngOnInit() {
        this.initialize();
    }
    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show 200ms */
    show(delay = this.showDelay) {
        if (this.disabled ||
            !this.content ||
            (this.isTooltipVisible() && !this.tooltipInstance.showTimeoutId && !this.tooltipInstance.hideTimeoutId)) {
            return;
        }
        const overlayRef = this.createOverlay();
        this.detach();
        this.portal = this.portal || new ComponentPortal(ThyTooltipComponent, this.viewContainerRef);
        this.tooltipInstance = overlayRef.attach(this.portal).instance;
        this.tooltipInstance
            .afterHidden()
            .pipe(takeUntil(this.ngUnsubscribe$))
            .subscribe(() => this.detach());
        this.setTooltipClass(this.tooltipClass);
        this.updateTooltipContent();
        this.tooltipInstance.show(delay);
    }
    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide 100ms */
    hide(delay = this.hideDelay) {
        if (this.tooltipInstance) {
            this.tooltipInstance.hide(delay);
        }
    }
    ngOnDestroy() {
        this.hide(0);
        this.dispose();
        if (this.overlayRef) {
            this.tooltipInstance = null;
        }
    }
}
ThyTooltipDirective.ɵfac = function ThyTooltipDirective_Factory(t) { return new (t || ThyTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(THY_TOOLTIP_DEFAULT_CONFIG_TOKEN)); };
ThyTooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyTooltipDirective, selectors: [["", "thyTooltip", ""], ["", "thy-tooltip", ""]], inputs: { placement: ["thyTooltipPlacement", "placement"], showDelay: ["thyTooltipShowDelay", "showDelay"], hideDelay: ["thyTooltipHideDelay", "hideDelay"], tooltipPin: ["thyTooltipPin", "tooltipPin"], content: ["thyTooltip", "content"], thyTooltipClass: "thyTooltipClass", thyTooltipTrigger: "thyTooltipTrigger", thyTooltipDisabled: "thyTooltipDisabled", data: ["thyTooltipTemplateContext", "data"], tooltipOffset: ["thyTooltipOffset", "tooltipOffset"] }, exportAs: ["thyTooltip"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
ThyTooltipDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ScrollDispatcher },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Platform },
    { type: FocusMonitor },
    { type: ThyTooltipConfig, decorators: [{ type: Inject, args: [THY_TOOLTIP_DEFAULT_CONFIG_TOKEN,] }] }
];
ThyTooltipDirective.propDecorators = {
    content: [{ type: Input, args: ['thyTooltip',] }],
    placement: [{ type: Input, args: ['thyTooltipPlacement',] }],
    thyTooltipClass: [{ type: Input, args: ['thyTooltipClass',] }],
    showDelay: [{ type: Input, args: ['thyTooltipShowDelay',] }],
    hideDelay: [{ type: Input, args: ['thyTooltipHideDelay',] }],
    thyTooltipTrigger: [{ type: Input, args: ['thyTooltipTrigger',] }],
    thyTooltipDisabled: [{ type: Input, args: ['thyTooltipDisabled',] }],
    data: [{ type: Input, args: ['thyTooltipTemplateContext',] }],
    tooltipOffset: [{ type: Input, args: ['thyTooltipOffset',] }],
    tooltipPin: [{ type: Input, args: ['thyTooltipPin',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTooltipDirective, [{
        type: Directive,
        args: [{
                selector: '[thyTooltip],[thy-tooltip]',
                exportAs: 'thyTooltip'
            }]
    }], function () { return [{ type: ɵngcc3.Overlay }, { type: ɵngcc0.ElementRef }, { type: ɵngcc3.ScrollDispatcher }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc4.Platform }, { type: ɵngcc5.FocusMonitor }, { type: ThyTooltipConfig, decorators: [{
                type: Inject,
                args: [THY_TOOLTIP_DEFAULT_CONFIG_TOKEN]
            }] }]; }, { placement: [{
            type: Input,
            args: ['thyTooltipPlacement']
        }], showDelay: [{
            type: Input,
            args: ['thyTooltipShowDelay']
        }], hideDelay: [{
            type: Input,
            args: ['thyTooltipHideDelay']
        }], tooltipPin: [{
            type: Input,
            args: ['thyTooltipPin']
        }], content: [{
            type: Input,
            args: ['thyTooltip']
        }], thyTooltipClass: [{
            type: Input,
            args: ['thyTooltipClass']
        }], thyTooltipTrigger: [{
            type: Input,
            args: ['thyTooltipTrigger']
        }], thyTooltipDisabled: [{
            type: Input,
            args: ['thyTooltipDisabled']
        }], data: [{
            type: Input,
            args: ['thyTooltipTemplateContext']
        }], tooltipOffset: [{
            type: Input,
            args: ['thyTooltipOffset']
        }] }); })();

class ThyTooltipModule {
}
ThyTooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyTooltipModule });
ThyTooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyTooltipModule_Factory(t) { return new (t || ThyTooltipModule)(); }, providers: [THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER], imports: [[A11yModule, CommonModule, OverlayModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyTooltipModule, { declarations: function () { return [ThyTooltipDirective, ThyTooltipComponent]; }, imports: function () { return [A11yModule, CommonModule, OverlayModule]; }, exports: function () { return [ThyTooltipDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyTooltipModule, [{
        type: NgModule,
        args: [{
                imports: [A11yModule, CommonModule, OverlayModule],
                exports: [ThyTooltipDirective],
                declarations: [ThyTooltipDirective, ThyTooltipComponent],
                entryComponents: [ThyTooltipComponent],
                providers: [THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER]
            }]
    }], null, null); })();

class TooltipService {
    constructor(overlay, scrollDispatcher, ngZone, platform, focusMonitor, thyTooltipConfig) {
        this.overlay = overlay;
        this.scrollDispatcher = scrollDispatcher;
        this.ngZone = ngZone;
        this.platform = platform;
        this.focusMonitor = focusMonitor;
        this.thyTooltipConfig = thyTooltipConfig;
    }
    attach(elementRef, viewContainerRef, trigger) {
        this.thyTooltipDirective = new ThyTooltipDirective(this.overlay, elementRef, this.scrollDispatcher, viewContainerRef, this.ngZone, this.platform, this.focusMonitor, this.thyTooltipConfig);
        if (trigger) {
            this.thyTooltipDirective.trigger = trigger;
        }
        this.thyTooltipDirective.ngOnInit();
    }
    detach() {
        this.thyTooltipDirective.ngOnDestroy();
    }
}
TooltipService.ɵfac = function TooltipService_Factory(t) { return new (t || TooltipService)(ɵngcc0.ɵɵinject(ɵngcc3.Overlay), ɵngcc0.ɵɵinject(ɵngcc3.ScrollDispatcher), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc4.Platform), ɵngcc0.ɵɵinject(ɵngcc5.FocusMonitor), ɵngcc0.ɵɵinject(THY_TOOLTIP_DEFAULT_CONFIG_TOKEN)); };
TooltipService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipService, factory: TooltipService.ɵfac });
TooltipService.ctorParameters = () => [
    { type: Overlay },
    { type: ScrollDispatcher },
    { type: NgZone },
    { type: Platform },
    { type: FocusMonitor },
    { type: ThyTooltipConfig, decorators: [{ type: Inject, args: [THY_TOOLTIP_DEFAULT_CONFIG_TOKEN,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc3.Overlay }, { type: ɵngcc3.ScrollDispatcher }, { type: ɵngcc0.NgZone }, { type: ɵngcc4.Platform }, { type: ɵngcc5.FocusMonitor }, { type: ThyTooltipConfig, decorators: [{
                type: Inject,
                args: [THY_TOOLTIP_DEFAULT_CONFIG_TOKEN]
            }] }]; }, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_TOOLTIP_OPTIONS, THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER, THY_TOOLTIP_DEFAULT_CONFIG_TOKEN, ThyTooltipComponent, ThyTooltipConfig, ThyTooltipDirective, ThyTooltipModule, TooltipService, thyTooltipAnimations, thyTooltipDefaultConfig };

//# sourceMappingURL=ngx-tethys-tooltip.js.map