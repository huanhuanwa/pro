import * as i0 from '@angular/core';
import { InjectionToken, EventEmitter, Component, ElementRef, Inject, ChangeDetectorRef, NgZone, ViewChild, Injector, Injectable, ChangeDetectionStrategy, ContentChildren, Input, Output, Directive, ViewContainerRef, Optional, HostBinding, NgModule } from '@angular/core';
import * as i4 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import * as i1 from '@angular/cdk/overlay';
import { FlexibleConnectedPositionStrategy, Overlay, ScrollDispatcher, OverlayContainer, OverlayModule } from '@angular/cdk/overlay';
import { coerceElement, coerceArray, coerceBooleanProperty } from '@angular/cdk/coercion';
import { CdkPortalOutlet, ComponentPortal, PortalModule } from '@angular/cdk/portal';
import { ThyAbstractOverlayConfig, ThyAbstractOverlayContainer, ThyClickDispatcher, ThyAbstractOverlayRef, ThyAbstractInternalOverlayRef, ThyAbstractOverlayService, getFlexiblePositions, mixinUnsubscribe, MixinBase, ScrollToService } from 'ngx-tethys/core';
import { state, style, trigger } from '@angular/animations';
import { filter, takeUntil, take, switchMap, startWith, map, delay } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';
import { Subject, of, defer, merge, timer, fromEvent } from 'rxjs';
import * as i3 from '@angular/cdk/scrolling';
import { ViewportRuler } from '@angular/cdk/scrolling';
import * as i5 from '@angular/cdk/platform';
import { Platform } from '@angular/cdk/platform';
import { SelectionModel } from '@angular/cdk/collections';
import { ThyOptionSelectionChangeEvent, THY_OPTION_PARENT_COMPONENT, ThyOptionComponent, ThySharedModule, ThyOptionModule } from 'ngx-tethys/shared';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { warnDeprecation, ESCAPE, ENTER, UP_ARROW, DOWN_ARROW, TAB } from 'ngx-tethys/util';
import { ThyInputModule } from 'ngx-tethys/input';
import { ThyLabelModule } from 'ngx-tethys/label';
import { ThyLoadingModule } from 'ngx-tethys/loading';
import { ThyIconModule } from 'ngx-tethys/icon';
import { ThyEmptyModule } from 'ngx-tethys/empty';

class ThyAutocompleteConfig extends ThyAbstractOverlayConfig {
}
const THY_AUTOCOMPLETE_DEFAULT_CONFIG = new InjectionToken('thy-autocomplete-default-config');
const ɵ0 = {
    hasBackdrop: false,
    panelClass: '',
    closeOnNavigation: true,
    insideClosable: true,
    manualClosure: false,
    outsideClosable: true,
    originActiveClass: 'thy-autocomplete-origin-active'
};
const THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER = {
    provide: THY_AUTOCOMPLETE_DEFAULT_CONFIG,
    useValue: ɵ0
};

const animationBody = [
    state('void, exit', style({ opacity: 0, transform: 'scale(0.1)' })),
    state('enter', style({ transform: 'none' }))
];
/**
 * Animations used by ThyAutocomplete.
 * @docs-private
 */
const thyAutocompleteAnimations = {
    autocompleteContainer: trigger('autocompleteContainer', animationBody)
};

const autocompleteUpperOverlayOptions = {
    name: 'autocomplete',
    animationEnabled: true,
    disposeWhenClose: true
};

class ThyAutocompleteContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, thyClickDispatcher, ngZone) {
        super(autocompleteUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.thyClickDispatcher = thyClickDispatcher;
        this.ngZone = ngZone;
        /** State of the autocomplete animation. */
        this.animationState = 'enter';
        /** Emits when an animation state changes. */
        this.animationStateChanged = new EventEmitter();
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'enter';
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
    }
    beforeAttachPortal() { }
    ngAfterViewInit() { }
    /** Callback, invoked whenever an animation on the host completes. */
    onAnimationDone(event) {
        this.animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    startExitAnimation() {
        this.animationState = 'exit';
        this.changeDetectorRef.markForCheck();
    }
}
ThyAutocompleteContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-autocomplete-container',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                animations: [thyAutocompleteAnimations.autocompleteContainer],
                host: {
                    class: 'thy-autocomplete-container',
                    tabindex: '-1',
                    '[attr.role]': `'autocomplete'`,
                    '[@autocompleteContainer]': 'animationState',
                    '(@autocompleteContainer.start)': 'onAnimationStart($event)',
                    '(@autocompleteContainer.done)': 'onAnimationDone($event)'
                }
            },] }
];
ThyAutocompleteContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThyAutocompleteConfig },
    { type: ChangeDetectorRef },
    { type: ThyClickDispatcher },
    { type: NgZone }
];
ThyAutocompleteContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
};

class ThyAutocompleteRef extends ThyAbstractOverlayRef {
}
class ThyInternalAutocompleteRef extends ThyAbstractInternalOverlayRef {
    constructor(overlayRef, containerInstance, config) {
        super(autocompleteUpperOverlayOptions, overlayRef, containerInstance, config);
    }
    /**
     * Updates the autocomplete's position.
     * @param position New autocomplete position.
     */
    updatePosition() {
        this.overlayRef.updatePosition();
        return this;
    }
}

class ThyAutocompleteService extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig, scrollDispatcher, ngZone, _viewportRuler, _document, _platform, _overlayContainer) {
        super(autocompleteUpperOverlayOptions, overlay, injector, defaultConfig);
        this.scrollDispatcher = scrollDispatcher;
        this.ngZone = ngZone;
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        this.ngUnsubscribe$ = new Subject();
        this.originInstancesMap = new Map();
    }
    buildPositionStrategy(config) {
        const positionStrategy = new FlexibleConnectedPositionStrategy(config.origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        const positions = getFlexiblePositions(config.placement, config.offset, 'thy-autocomplete');
        positionStrategy.withPositions(positions);
        positionStrategy.withGrowAfterOpen(true);
        positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {
            if (change.scrollableViewProperties.isOverlayClipped) {
                // After position changes occur and the overlay is clipped by
                // a parent scrollable then close the tooltip.
                this.ngZone.run(() => this.close());
            }
        });
        return positionStrategy;
    }
    buildOverlayConfig(config) {
        const strategy = this.buildPositionStrategy(config);
        const overlayConfig = this.buildBaseOverlayConfig(config);
        overlayConfig.positionStrategy = strategy;
        overlayConfig.scrollStrategy = config.scrollStrategy || this.overlay.scrollStrategies.block();
        overlayConfig.width = config.width;
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThyAutocompleteConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThyAutocompleteContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalAutocompleteRef(overlayRef, containerInstance, config);
    }
    createInjector(config, autocompleteRef, autocompleteContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            {
                provide: ThyAutocompleteContainerComponent,
                useValue: autocompleteContainer
            },
            {
                provide: ThyAutocompleteRef,
                useValue: autocompleteRef
            }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    originElementAddActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.add(...coerceArray(config.originActiveClass));
        }
    }
    originElementRemoveActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.remove(...coerceArray(config.originActiveClass));
        }
    }
    open(componentOrTemplateRef, config) {
        const originElement = coerceElement(config.origin);
        const autocompleteRef = this.openUpperOverlay(componentOrTemplateRef, config);
        config = autocompleteRef.containerInstance.config;
        autocompleteRef.afterClosed().subscribe(() => {
            this.originElementRemoveActiveClass(config);
            this.originInstancesMap.delete(originElement);
        });
        this.originElementAddActiveClass(config);
        this.originInstancesMap.set(originElement, {
            config,
            autocompleteRef
        });
        return autocompleteRef;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyAutocompleteService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyAutocompleteService_Factory() { return new ThyAutocompleteService(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(THY_AUTOCOMPLETE_DEFAULT_CONFIG), i0.ɵɵinject(i3.ScrollDispatcher), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.ViewportRuler), i0.ɵɵinject(i4.DOCUMENT), i0.ɵɵinject(i5.Platform), i0.ɵɵinject(i1.OverlayContainer)); }, token: ThyAutocompleteService, providedIn: "root" });
ThyAutocompleteService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ThyAutocompleteService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThyAutocompleteConfig, decorators: [{ type: Inject, args: [THY_AUTOCOMPLETE_DEFAULT_CONFIG,] }] },
    { type: ScrollDispatcher },
    { type: NgZone },
    { type: ViewportRuler },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Platform },
    { type: OverlayContainer }
];

const _MixinBase = mixinUnsubscribe(MixinBase);
class ThyAutocompleteComponent extends _MixinBase {
    constructor(ngZone, changeDetectorRef) {
        super();
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.isMultiple = false;
        this.mode = '';
        this.isEmptyOptions = false;
        this.isOpened = false;
        this.optionSelectionChanges = defer(() => {
            if (this.options) {
                return merge(...this.options.map(option => option.selectionChange));
            }
            return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionSelectionChanges));
        });
        this.thyEmptyText = '没有任何数据';
        this.thyOptionSelected = new EventEmitter();
        this.thyOpened = new EventEmitter();
        this.thyClosed = new EventEmitter();
        /** Emits whenever an option is activated using the keyboard. */
        this.thyOptionActivated = new EventEmitter();
    }
    get thyAutoActiveFirstOption() {
        return this._autoActiveFirstOption;
    }
    set thyAutoActiveFirstOption(value) {
        this._autoActiveFirstOption = coerceBooleanProperty(value);
    }
    ngOnInit() {
        this.setDropDownClass();
        this.instanceSelectionModel();
    }
    ngAfterContentInit() {
        this.options.changes.pipe(startWith(null), takeUntil(this.ngUnsubscribe$)).subscribe(() => {
            this.resetOptions();
            timer().subscribe(() => {
                this.isEmptyOptions = this.options.length <= 0;
                this.changeDetectorRef.detectChanges();
            });
            this.initKeyManager();
        });
    }
    initKeyManager() {
        const changedOrDestroyed$ = merge(this.options.changes, this.ngUnsubscribe$);
        this.keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        this.keyManager.change.pipe(takeUntil(changedOrDestroyed$)).subscribe(index => {
            this.thyOptionActivated.emit({ source: this, option: this.options.toArray()[index] || null });
        });
    }
    open() {
        this.isOpened = true;
        this.changeDetectorRef.markForCheck();
        this.thyOpened.emit();
    }
    close() {
        this.isOpened = false;
        this.thyClosed.emit();
    }
    resetOptions() {
        const changedOrDestroyed$ = merge(this.options.changes, this.ngUnsubscribe$);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed$)).subscribe((event) => {
            this.onSelect(event.option, event.isUserInput);
        });
    }
    instanceSelectionModel() {
        if (this.selectionModel) {
            this.selectionModel.clear();
        }
        this.selectionModel = new SelectionModel(this.isMultiple);
        this.selectionModel.changed.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            event.added.forEach(option => option.select());
            event.removed.forEach(option => option.deselect());
        });
    }
    onSelect(option, isUserInput) {
        const wasSelected = this.selectionModel.isSelected(option);
        if (option.thyValue == null && !this.isMultiple) {
            option.deselect();
            this.selectionModel.clear();
        }
        else {
            if (wasSelected !== option.selected) {
                option.selected ? this.selectionModel.select(option) : this.selectionModel.deselect(option);
            }
            if (isUserInput) {
                this.keyManager.setActiveItem(option);
            }
            // if (this.isMultiple) {
            //     this.sortValues();
            //     if (isUserInput) {
            //         this.focus();
            //     }
            // }
        }
        if (wasSelected !== this.selectionModel.isSelected(option)) {
            this.thyOptionSelected.emit(new ThyOptionSelectionChangeEvent(option, false));
        }
        this.changeDetectorRef.markForCheck();
    }
    setDropDownClass() {
        let modeClass = '';
        if (this.isMultiple) {
            modeClass = `thy-select-dropdown-${this.mode}`;
        }
        else {
            modeClass = `thy-select-dropdown-single`;
        }
        this.dropDownClass = {
            [`thy-select-dropdown`]: true,
            [modeClass]: true
        };
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
ThyAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-autocomplete',
                template: "<ng-template #contentTemplate>\n  <div thyStopPropagation [ngClass]=\"dropDownClass\">\n    <div #panel class=\"thy-select-dropdown-options\">\n      <ng-content></ng-content>\n      <thy-empty *ngIf=\"isEmptyOptions\" [thyMessage]=\"thyEmptyText\"></thy-empty>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: THY_OPTION_PARENT_COMPONENT,
                        useExisting: ThyAutocompleteComponent
                    }
                ]
            },] }
];
ThyAutocompleteComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef }
];
ThyAutocompleteComponent.propDecorators = {
    contentTemplateRef: [{ type: ViewChild, args: ['contentTemplate', { static: true },] }],
    optionsContainer: [{ type: ViewChild, args: ['panel',] }],
    options: [{ type: ContentChildren, args: [ThyOptionComponent, { descendants: true },] }],
    thyEmptyText: [{ type: Input }],
    thyAutoActiveFirstOption: [{ type: Input }],
    thyOptionSelected: [{ type: Output }],
    thyOpened: [{ type: Output }],
    thyClosed: [{ type: Output }],
    thyOptionActivated: [{ type: Output }]
};

class ThyAutocompleteTriggerDirective {
    constructor(elementRef, ngZone, overlay, autocompleteService, viewContainerRef, document, cdr) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.overlay = overlay;
        this.autocompleteService = autocompleteService;
        this.viewContainerRef = viewContainerRef;
        this.document = document;
        this.cdr = cdr;
        this.closeKeyEventStream = new Subject();
        this.panelOpened = false;
        this.thyOffset = 4;
        this.thyPlacement = 'bottomLeft';
    }
    set autocompleteComponent(data) {
        this._autocompleteComponent = data;
    }
    set autocomplete(data) {
        warnDeprecation(`The property thyAutocomplete will be deprecated, please use thyAutocompleteComponent instead.`);
        this._autocompleteComponent = data;
    }
    get autocompleteComponent() {
        return this._autocompleteComponent;
    }
    get activeOption() {
        if (this.autocompleteComponent && this.autocompleteComponent.keyManager) {
            return this.autocompleteComponent.keyManager.activeItem;
        }
        return null;
    }
    get panelClosingActions() {
        return merge(this.autocompleteComponent.thyOptionSelected, this.autocompleteComponent.keyManager.tabOut.pipe(filter(() => this.panelOpened)), this.closeKeyEventStream, this.getOutsideClickStream(), this.overlayRef ? this.overlayRef.detachments().pipe(filter(() => this.panelOpened)) : of()).pipe(
        // Normalize the output so we return a consistent type.
        map(event => (event instanceof ThyOptionSelectionChangeEvent ? event : null)));
    }
    ngOnInit() { }
    onFocus() {
        if (this.canOpen()) {
            this.openPanel();
        }
    }
    onKeydown(event) {
        const keyCode = event.keyCode;
        // Prevent the default action on all escape key presses. This is here primarily to bring IE
        // in line with other browsers. By default, pressing escape on IE will cause it to revert
        // the input value to the one that it had on focus, however it won't dispatch any events
        // which means that the model value will be out of sync with the view.
        if (keyCode === ESCAPE) {
            event.preventDefault();
        }
        if (this.activeOption && keyCode === ENTER && this.panelOpened) {
            this.activeOption.selectViaInteraction();
            this.resetActiveItem();
            event.preventDefault();
        }
        else if (this.autocompleteComponent) {
            const prevActiveItem = this.autocompleteComponent.keyManager.activeItem;
            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
            if (this.panelOpened || keyCode === TAB) {
                this.autocompleteComponent.keyManager.onKeydown(event);
            }
            else if (isArrowKey && this.canOpen()) {
                this.openPanel();
            }
            if ((isArrowKey || this.autocompleteComponent.keyManager.activeItem !== prevActiveItem) &&
                this.autocompleteComponent.keyManager.activeItem) {
                ScrollToService.scrollToElement(this.autocompleteComponent.keyManager.activeItem.element.nativeElement, this.autocompleteComponent.optionsContainer.nativeElement);
            }
        }
    }
    handleInput(event) {
        if (this.canOpen() && document.activeElement === event.target) {
            this.openPanel();
        }
    }
    openPanel() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            return;
        }
        const overlayRef = this.createOverlay();
        this.overlayRef = overlayRef;
        overlayRef.keydownEvents().subscribe(event => {
            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
            if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {
                this.resetActiveItem();
                this.closeKeyEventStream.next();
                // We need to stop propagation, otherwise the event will eventually
                // reach the input itself and cause the overlay to be reopened.
                event.stopPropagation();
                event.preventDefault();
            }
        });
        this.panelOpened = true;
        this.autocompleteComponent.open();
    }
    closePanel() {
        if (this.autocompleteRef) {
            this.autocompleteRef.close();
            this.cdr.detectChanges();
            this.closingActionsSubscription.unsubscribe();
        }
    }
    createOverlay() {
        const config = Object.assign({
            origin: this.elementRef.nativeElement,
            viewContainerRef: this.viewContainerRef,
            placement: this.thyPlacement,
            offset: this.thyOffset,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
            width: this.thyAutocompleteWidth || this.elementRef.nativeElement.clientWidth
        });
        this.autocompleteRef = this.autocompleteService.open(this.autocompleteComponent.contentTemplateRef, config);
        this.autocompleteRef.afterClosed().subscribe(() => {
            this.panelOpened = false;
            this.autocompleteComponent.close();
        });
        // delay 200ms to prevent emit document click rightnow
        this.autocompleteRef
            .afterOpened()
            .pipe(delay(200))
            .subscribe(() => {
            this.closingActionsSubscription = this.subscribeToClosingActions();
        });
        return this.autocompleteRef.getOverlayRef();
    }
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     */
    subscribeToClosingActions() {
        const firstStable = this.ngZone.onStable.asObservable().pipe(take(1));
        const optionChanges = this.autocompleteComponent.options.changes.pipe(
        // Defer emitting to the stream until the next tick, because changing
        // bindings in here will cause "changed after checked" errors.
        delay(0));
        // When the zone is stable initially, and when the option list changes...
        return (merge(firstStable, optionChanges)
            .pipe(
        // create a new stream of panelClosingActions, replacing any previous streams
        // that were created, and flatten it so our stream only emits closing events...
        switchMap(() => {
            this.resetActiveItem();
            if (this.panelOpened) {
                this.overlayRef.updatePosition();
            }
            return this.panelClosingActions;
        }), 
        // when the first closing event occurs...
        take(1))
            // set the value, close the panel, and complete.
            .subscribe(event => this.setValueAndClose(event)));
    }
    setValueAndClose(event) {
        if (event && event.option) {
            this.setValue(event.option.thyLabelText);
        }
        this.closePanel();
    }
    /** Stream of clicks outside of the autocomplete panel. */
    getOutsideClickStream() {
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter(event => {
            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
            // fall back to check the first element in the path of the click event.
            const clickTarget = event.target;
            const formField = null;
            return (this.panelOpened &&
                clickTarget !== this.elementRef.nativeElement &&
                (!formField || !formField.contains(clickTarget)) &&
                !!this.overlayRef &&
                !this.overlayRef.overlayElement.contains(clickTarget));
        }));
    }
    setValue(value) {
        this.elementRef.nativeElement.value = value;
        this.elementRef.nativeElement.focus();
    }
    canOpen() {
        const element = this.elementRef.nativeElement;
        return !element.readOnly && !element.disabled;
    }
    resetActiveItem() {
        this.autocompleteComponent.keyManager.setActiveItem(this.autocompleteComponent.thyAutoActiveFirstOption ? 0 : -1);
    }
    destroyPanel() {
        if (this.overlayRef) {
            this.closePanel();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
    }
    ngOnDestroy() {
        this.closeKeyEventStream.complete();
        this.destroyPanel();
    }
}
ThyAutocompleteTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[thyAutocompleteTrigger], textarea[thyAutocompleteTrigger]',
                exportAs: 'thyAutocompleteTrigger',
                host: {
                    '(input)': 'handleInput($event)',
                    '(focusin)': 'onFocus()',
                    '(keydown)': 'onKeydown($event)'
                }
            },] }
];
ThyAutocompleteTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Overlay },
    { type: ThyAutocompleteService },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef }
];
ThyAutocompleteTriggerDirective.propDecorators = {
    panelOpened: [{ type: HostBinding, args: [`class.thy-autocomplete-opened`,] }],
    autocompleteComponent: [{ type: Input, args: ['thyAutocompleteComponent',] }],
    autocomplete: [{ type: Input, args: ['thyAutocomplete',] }],
    thyOffset: [{ type: Input }],
    thyAutocompleteWidth: [{ type: Input }],
    thyPlacement: [{ type: Input }]
};

class ThyAutocompleteModule {
}
ThyAutocompleteModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ThyInputModule,
                    ThyLabelModule,
                    OverlayModule,
                    PortalModule,
                    ThyLoadingModule,
                    ThySharedModule,
                    ThyIconModule,
                    ThyEmptyModule,
                    ThyOptionModule
                ],
                declarations: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent],
                entryComponents: [ThyAutocompleteContainerComponent],
                exports: [ThyAutocompleteTriggerDirective, ThyAutocompleteComponent, ThyAutocompleteContainerComponent, ThyOptionModule],
                providers: [THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { THY_AUTOCOMPLETE_DEFAULT_CONFIG, THY_AUTOCOMPLETE_DEFAULT_CONFIG_PROVIDER, ThyAutocompleteComponent, ThyAutocompleteConfig, ThyAutocompleteContainerComponent, ThyAutocompleteModule, ThyAutocompleteService, ThyAutocompleteTriggerDirective, thyAutocompleteAnimations, ɵ0 };
//# sourceMappingURL=ngx-tethys-autocomplete.js.map
