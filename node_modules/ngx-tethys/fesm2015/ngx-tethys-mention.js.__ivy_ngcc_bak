import { Component, ElementRef, NgZone, HostBinding, EventEmitter, Directive, Optional, Self, Input, Output, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgControl, FormsModule } from '@angular/forms';
import { ThyPopoverRef, ThyPopover, ThyPopoverModule } from 'ngx-tethys/popover';
import { Subject, Observable, of } from 'rxjs';
import { switchMap, debounceTime, catchError, take } from 'rxjs/operators';
import { getElementOffset, isInputOrTextarea } from 'ngx-tethys/util';
import { ThyListModule } from 'ngx-tethys/list';
import { ThyLoadingModule } from 'ngx-tethys/loading';

class ThyMentionSuggestionsComponent {
    constructor(elementRef, ngZone, popoverRef) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.popoverRef = popoverRef;
        this.suggestionSelect$ = new Subject();
        this.debounce = 150;
        this.loadingDone = true;
        this.search$ = new Subject();
        this.suggestionsClass = true;
        this.search$
            .pipe(switchMap(query => {
            const data = this.mention.search(query.term, this.mention.data);
            if (data instanceof Observable) {
                this.loadingDone = false;
                return data.pipe(debounceTime(this.debounce));
            }
            else {
                return of(data);
            }
        }), catchError(() => {
            this.loadingDone = false;
            return [];
        }))
            .subscribe(data => {
            this.loadingDone = true;
            this.data = data || [];
            if (this.popoverRef) {
                if (this.mention.autoClose && this.data.length === 0) {
                    this.popoverRef.close();
                }
                this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                    this.popoverRef.updatePosition();
                });
            }
        });
    }
    ngOnInit() {
        if (this.mention.popoverClass) {
            this.elementRef.nativeElement.classList.add(this.mention.popoverClass);
        }
    }
    search(query) {
        this.search$.next(query);
    }
    select(item, event) {
        this.suggestionSelect$.next({
            event,
            item
        });
    }
    selectionChange(event) {
        this.select(event.value, event.event);
    }
    ngOnDestroy() {
        this.search$.next();
        this.search$.complete();
    }
}
ThyMentionSuggestionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-mention-suggestions',
                template: "<thy-loading [thyDone]=\"loadingDone\"></thy-loading>\n<ng-container *ngIf=\"loadingDone\">\n  <thy-selection-list\n    *ngIf=\"data?.length > 0; else empty\"\n    thyBindKeyEventContainer=\"body\"\n    thyMultiple=\"false\"\n    thyAutoActiveFirstItem=\"true\"\n    thySpaceKeyEnabled=\"false\"\n    [thyScrollContainer]=\"elementRef\"\n    (thySelectionChange)=\"selectionChange($event)\"\n  >\n    <thy-list-option *ngFor=\"let item of data\" [thyValue]=\"item\">\n      <ng-container *ngIf=\"mention?.displayTemplateRef; else default\">\n        <ng-template *ngTemplateOutlet=\"mention?.displayTemplateRef; context: { $implicit: item }\"></ng-template>\n      </ng-container>\n      <ng-template #default>\n        {{ item['name'] || '' }}\n      </ng-template>\n    </thy-list-option>\n  </thy-selection-list>\n</ng-container>\n<ng-template #empty>\n  <div class=\"text-desc p-3\">\n    {{ mention?.emptyText }}\n  </div>\n</ng-template>\n"
            },] }
];
ThyMentionSuggestionsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ThyPopoverRef }
];
ThyMentionSuggestionsComponent.propDecorators = {
    suggestionsClass: [{ type: HostBinding, args: ['class.thy-mention-suggestions',] }]
};

// We'll copy the properties below into the mirror div.
// Note that some browsers, such as Firefox, do not concatenate properties
// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),
// so we have to list every single property explicitly.
const properties = [
    'direction',
    'boxSizing',
    'width',
    'height',
    'overflowX',
    'overflowY',
    'borderTopWidth',
    'borderRightWidth',
    'borderBottomWidth',
    'borderLeftWidth',
    'borderStyle',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/font
    'fontStyle',
    'fontVariant',
    'fontWeight',
    'fontStretch',
    'fontSize',
    'fontSizeAdjust',
    'lineHeight',
    'fontFamily',
    'textAlign',
    'textTransform',
    'textIndent',
    'textDecoration',
    'letterSpacing',
    'wordSpacing',
    'tabSize',
    'MozTabSize'
];
const isBrowser = typeof window !== 'undefined';
const isFirefox = isBrowser && window['mozInnerScreenX'] != null;
class CaretPositioner {
    // get caret coordinates in input or textarea
    // copy from repo: https://github.com/component/textarea-caret-position
    static getTextareaCaretCoordinates(element, position, options) {
        if (!isBrowser) {
            throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');
        }
        const debug = (options && options.debug) || false;
        if (debug) {
            const el = document.querySelector('#input-textarea-caret-position-mirror-div');
            if (el) {
                el.parentNode.removeChild(el);
            }
        }
        // The mirror div will replicate the textarea's style
        const div = document.createElement('div');
        div.id = 'input-textarea-caret-position-mirror-div';
        document.body.appendChild(div);
        const style = div.style;
        const computed = window.getComputedStyle ? window.getComputedStyle(element) : element['currentStyle']; // currentStyle for IE < 9
        const isInput = element.nodeName === 'INPUT';
        // Default textarea styles
        style.whiteSpace = 'pre-wrap';
        if (!isInput) {
            style.wordWrap = 'break-word'; // only for textarea-s
        }
        // Position off-screen
        style.position = 'absolute'; // required to return coordinates properly
        if (!debug) {
            style.visibility = 'hidden'; // not 'display: none' because we want rendering
        }
        // Transfer the element's properties to the div
        properties.forEach(function (prop) {
            if (isInput && prop === 'lineHeight') {
                // Special case for <input>s because text is rendered centered and line height may be != height
                if (computed.boxSizing === 'border-box') {
                    const height = parseInt(computed.height, 10);
                    const outerHeight = parseInt(computed.paddingTop, 10) +
                        parseInt(computed.paddingBottom, 10) +
                        parseInt(computed.borderTopWidth, 10) +
                        parseInt(computed.borderBottomWidth, 10);
                    const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);
                    if (height > targetHeight) {
                        style.lineHeight = height - outerHeight + 'px';
                    }
                    else if (height === targetHeight) {
                        style.lineHeight = computed.lineHeight;
                    }
                    else {
                        style.lineHeight = '0';
                    }
                }
                else {
                    style.lineHeight = computed.height;
                }
            }
            else {
                style[prop] = computed[prop];
            }
        });
        if (isFirefox) {
            // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275
            if (element.scrollHeight > parseInt(computed.height, 10)) {
                style.overflowY = 'scroll';
            }
        }
        else {
            style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'
        }
        div.textContent = element.value.substring(0, position);
        // The second special handling for input type="text" vs textarea:
        // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037
        if (isInput) {
            div.textContent = div.textContent.replace(/\s/g, '\u00a0');
        }
        const span = document.createElement('span');
        // Wrapping must be replicated *exactly*, including when a long word gets
        // onto the next line, with whitespace at the end of the line before (#7).
        // The  *only* reliable way to do that is to copy the *entire* rest of the
        // textarea's content into the <span> created at the caret position.
        // For inputs, just '.' would be enough, but no need to bother.
        span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all
        div.appendChild(span);
        const coordinates = {
            top: span.offsetTop + parseInt(computed['borderTopWidth'], 10),
            left: span.offsetLeft + parseInt(computed['borderLeftWidth'], 10),
            height: parseInt(computed['lineHeight'], 10)
        };
        if (debug) {
            span.style.backgroundColor = '#aaa';
        }
        else {
            document.body.removeChild(div);
        }
        return coordinates;
    }
    static getEditableCaretCoordinates(element) {
        if (window.getSelection().rangeCount) {
            const range = window.getSelection().getRangeAt(0);
            const rect = range.getBoundingClientRect();
            // using the start or endcontainer is... uhm yeah... difficult...? :D
            let height = range.startContainer.nodeType === 1
                ? getComputedStyle(range.startContainer).lineHeight
                : getComputedStyle(range.startContainer.parentNode).lineHeight;
            if (isNaN(height)) {
                let node = range.startContainer;
                if (range.startContainer.nodeType !== 1) {
                    node = node.parentNode;
                }
                const current = node.style.lineHeight;
                node.style.lineHeight = '1em';
                height = parseInt(getComputedStyle(node).lineHeight, 10);
                node.style.lineHeight = current != null ? current : '';
                if (!node.getAttribute('style').length) {
                    // clean up if empty
                    node.removeAttribute('style');
                }
            }
            const editableRect = element.getBoundingClientRect();
            return {
                top: rect.top - editableRect.top,
                left: rect.left - editableRect.left,
                height: height
            };
        }
        else {
            return {
                top: 0,
                left: 0,
                height: 0
            };
        }
    }
    static getCaretCoordinates(element, position, options) {
        const isInput = ['INPUT', 'TEXTAREA'].indexOf(element.nodeName) >= 0;
        if (isInput) {
            return this.getTextareaCaretCoordinates(element, position, options);
        }
        else {
            return this.getEditableCaretCoordinates(element);
        }
    }
    // get caret position in view window
    static getCaretPosition(element, position, options) {
        const coordinates = CaretPositioner.getCaretCoordinates(element, position, options);
        const elementOffset = getElementOffset(element);
        return {
            top: coordinates.top + elementOffset.top,
            left: coordinates.left + elementOffset.left
        };
    }
}

class MentionAdapter {
    constructor(inputor) {
        this.inputor = inputor;
    }
    lookup(event, mentions) {
        this.matchedMention = null;
        for (const mention of mentions) {
            const query = this.seekQuery(event, mention);
            if (query) {
                this.matchedMention = {
                    query: query,
                    mention: mention
                };
                break;
            }
        }
        return this.matchedMention;
    }
}

class TextareaMentionAdapter extends MentionAdapter {
    constructor(inputor) {
        super(inputor);
    }
    seekQuery(event, mention) {
        const selectionStart = this.inputor.selectionStart;
        const value = this.inputor.value.replace(/[\r\n]/g, ' ');
        // @123 | @456 => 0(start) => @123
        // @123 @456 | => 5(start) => @456
        const start = value.lastIndexOf(mention.trigger, selectionStart);
        const fistSpaceIndexFromStart = value.indexOf(' ', selectionStart);
        const end = fistSpaceIndexFromStart > -1 ? fistSpaceIndexFromStart : value.length;
        const termWithTrigger = value.substring(start, end);
        const startBeforeHasSpace = start > 0 && value[start - 1] === ' ';
        if ((startBeforeHasSpace || start === 0) && !termWithTrigger.includes(' ') && !termWithTrigger.includes(mention.trigger, 1)) {
            return {
                start: start,
                end: end,
                term: termWithTrigger.substring(mention.trigger.length)
            };
        }
        else {
            return null;
        }
    }
    insertMention(item) {
        if (!this.matchedMention) {
            throw new Error(`matchedMention is null`);
        }
        const insertValue = this.getInsertValue(item);
        const value = this.inputor.value;
        const newValue = [
            value.slice(0, this.matchedMention.query.start),
            insertValue,
            value.slice(this.matchedMention.query.end, value.length)
        ].join('');
        this.inputor.value = newValue;
        this.focus(this.matchedMention.query.start + insertValue.length);
        return newValue;
    }
    getInsertValue(item) {
        if (this.matchedMention.mention.insertTransform) {
            return this.matchedMention.mention.insertTransform(item).trim() + ' ';
        }
        else {
            return `${this.matchedMention.mention.trigger}${item['name']}`.trim() + ' ';
        }
    }
    focus(caretPosition) {
        this.inputor.focus();
        this.inputor.setSelectionRange(caretPosition, caretPosition);
    }
    isEditable() {
        return !this.inputor.readOnly && !this.inputor.disabled;
    }
}

class EditableMentionAdapter extends MentionAdapter {
    constructor(inputor) {
        super(inputor);
    }
    seekQuery(event, mention) {
        return null;
    }
    insertMention(item) {
        throw new Error('Method not implemented.');
    }
}

function createMentionAdapter(element) {
    if (isInputOrTextarea(element)) {
        return new TextareaMentionAdapter(element);
    }
    else {
        element.contentEditable = 'true';
        return new EditableMentionAdapter(element);
    }
}

const SUGGESTION_BACKDROP_CLASS = 'thy-mention-suggestions-backdrop';
const POPOVER_DEFAULT_CONFIG = {
    backdropClass: SUGGESTION_BACKDROP_CLASS,
    placement: 'bottomLeft'
};
const ɵ0 = (term, data) => {
    return data.filter(item => {
        return !item.name || item.name.toLowerCase().includes(term.toLowerCase());
    });
};
const DEFAULT_MENTION_CONFIG = {
    autoClose: true,
    emptyText: '无匹配数据，按空格完成输入',
    search: ɵ0
};
class ThyMentionDirective {
    constructor(elementRef, thyPopover, ngControl) {
        this.elementRef = elementRef;
        this.thyPopover = thyPopover;
        this.ngControl = ngControl;
        this.adapter = null;
        this.select = new EventEmitter();
        this.adapter = createMentionAdapter(elementRef.nativeElement);
        this.bindEvents();
    }
    get mentions() {
        return this._mentions;
    }
    set mentions(value) {
        this._mentions = value;
        if (this._mentions) {
            this._mentions = this._mentions.map(mention => {
                if (!mention.trigger) {
                    throw new Error(`mention trigger is required`);
                }
                return Object.assign({}, DEFAULT_MENTION_CONFIG, mention);
            });
        }
    }
    ngOnInit() { }
    bindEvents() {
        this.elementRef.nativeElement.addEventListener('input', (event) => {
            this.onInput(event);
        });
        this.elementRef.nativeElement.addEventListener('click', (event) => {
            this.onClick(event);
        });
    }
    onClick(event) {
        this.lookup(event);
    }
    onInput(event) {
        this.lookup(event);
    }
    lookup(event) {
        const matched = this.adapter.lookup(event, this.mentions);
        if (matched) {
            this.openSuggestions(matched);
        }
        else {
            this.closeSuggestions();
        }
    }
    openSuggestions(matched) {
        if (!this.openedSuggestionsRef) {
            const inputElement = this.elementRef.nativeElement;
            const position = CaretPositioner.getCaretPosition(inputElement, matched.query.start);
            const fontSize = parseInt(getComputedStyle(this.elementRef.nativeElement).fontSize, 10);
            this.openedSuggestionsRef = this.thyPopover.open(ThyMentionSuggestionsComponent, Object.assign({}, POPOVER_DEFAULT_CONFIG, this.popoverConfig, {
                origin: this.elementRef,
                originPosition: {
                    x: position.left,
                    y: position.top,
                    width: fontSize,
                    height: fontSize
                },
                initialState: {
                    mention: matched.mention
                }
            }));
            this.openedSuggestionsRef.afterClosed().subscribe(() => {
                this.openedSuggestionsRef = null;
            });
            this.openedSuggestionsRef.componentInstance.suggestionSelect$.subscribe(event => {
                const newValue = this.adapter.insertMention(event.item);
                if (this.ngControl && this.ngControl.control) {
                    this.ngControl.control.setValue(newValue);
                }
                this.openedSuggestionsRef.close();
                this.select.emit(event);
            });
        }
        if (this.openedSuggestionsRef) {
            this.openedSuggestionsRef.componentInstance.search(matched.query);
        }
    }
    closeSuggestions() {
        if (this.openedSuggestionsRef) {
            this.openedSuggestionsRef.close();
        }
    }
    isEditable() {
        const element = this.elementRef.nativeElement;
        return !element.readOnly && !element.disabled;
    }
}
ThyMentionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyMention]',
                providers: []
            },] }
];
ThyMentionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThyPopover },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }
];
ThyMentionDirective.propDecorators = {
    mentions: [{ type: Input, args: ['thyMention',] }],
    popoverConfig: [{ type: Input, args: ['thyPopoverConfig',] }],
    select: [{ type: Output, args: ['thySelectSuggestion',] }]
};

class ThyMentionModule {
}
ThyMentionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ThyMentionDirective, ThyMentionSuggestionsComponent],
                imports: [CommonModule, FormsModule, ThyPopoverModule, ThyListModule, ThyLoadingModule],
                exports: [ThyMentionDirective],
                providers: [],
                entryComponents: [ThyMentionSuggestionsComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ThyMentionDirective, ThyMentionModule, ThyMentionSuggestionsComponent, ɵ0 };
//# sourceMappingURL=ngx-tethys-mention.js.map
