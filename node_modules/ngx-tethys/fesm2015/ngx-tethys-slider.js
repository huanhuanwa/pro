import { __decorate, __metadata } from 'tslib';
import { EventEmitter, Component, forwardRef, ChangeDetectorRef, NgZone, ElementRef, HostBinding, Input, ViewChild, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { fromEvent } from 'rxjs';
import { clamp } from 'ngx-tethys/util';
import { tap, pluck, map, distinctUntilChanged, takeUntil } from 'rxjs/operators';
import { UpdateHostClassService, InputBoolean } from 'ngx-tethys/core';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngx-tethys/core';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["sliderRail"];
const _c1 = ["sliderTrack"];
const _c2 = ["sliderPointer"];
const _c3 = function (a0) { return { "background-color": a0 }; };
const _c4 = function (a0) { return { "border-color": a0 }; };
class ThySliderComponent {
    constructor(cdr, ngZone, ref, updateHostClassService) {
        this.cdr = cdr;
        this.ngZone = ngZone;
        this.ref = ref;
        this.updateHostClassService = updateHostClassService;
        this.thyVertical = false;
        this.thyDisabled = false;
        this._thySlider = true;
        this._pointer = true;
        this.thyMax = 100;
        this.thyMin = 0;
        this.thyStep = 1;
        this.thyAfterChange = new EventEmitter();
        this.onChangeCallback = (v) => { };
        this.onTouchedCallback = (v) => { };
        updateHostClassService.initializeElement(ref.nativeElement);
    }
    set thyType(type) {
        this.updateHostClassService.updateClass(type ? [`thy-slider-${type}`] : []);
    }
    ngOnInit() {
        this.verificationValues();
        this.verificationStepValue();
        this.toggleDisabled();
        if (this.value === null || this.value === undefined) {
            this.setValue(this.ensureValueInRange(null));
        }
    }
    ngAfterViewInit() {
        this.registerMouseEventsListeners();
        this.toggleDisabled();
    }
    writeValue(newValue) {
        this.setValue(this.ensureValueInRange(newValue));
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('thyMin') || changes.hasOwnProperty('thyMax') || changes.hasOwnProperty('thyStep')) {
            this.verificationValues();
            this.verificationStepValue();
        }
    }
    ngOnDestroy() {
        this.unsubscribeMouseListeners();
    }
    verificationValues() {
        if (this.thyMin >= this.thyMax) {
            throw new Error('min value must less than max value.');
        }
    }
    verificationStepValue() {
        if (this.thyStep <= 0 || !!!this.thyStep) {
            throw new Error('step value must be greater than 0.');
        }
        else if (Number.isInteger(this.thyStep) && (this.thyMax - this.thyMin) % this.thyStep) {
            throw new Error('(max - min) must be divisible by step.');
        }
    }
    toggleDisabled() {
        if (this.thyDisabled) {
            this.unsubscribeMouseListeners();
        }
        else {
            this.subscribeMouseListeners(['start']);
        }
    }
    setValue(value) {
        if (this.value !== value) {
            this.value = value;
            this.updateTrackAndPointer();
        }
        this.onChangeCallback(this.value);
    }
    ensureValueInRange(value) {
        if (!this.valueMustBeValid(value)) {
            return this.thyMin;
        }
        return clamp(value, this.thyMin, this.thyMax);
    }
    valueMustBeValid(value) {
        return !isNaN(typeof value !== 'number' ? parseFloat(value) : value);
    }
    updateTrackAndPointer() {
        const offset = this.valueToOffset(this.value);
        this.updateStyle(offset / 100);
        this.cdr.markForCheck();
    }
    valueToOffset(value) {
        return ((value - this.thyMin) * 100) / (this.thyMax - this.thyMin);
    }
    updateStyle(offsetPercentage) {
        const percentage = Math.min(1, Math.max(0, offsetPercentage));
        const orientFields = this.thyVertical ? ['height', 'bottom'] : ['width', 'left'];
        this.sliderTrack.nativeElement.style[orientFields[0]] = `${percentage * 100}%`;
        this.sliderPointer.nativeElement.style[orientFields[1]] = `${percentage * 100}%`;
    }
    unsubscribeMouseListeners(actions = ['start', 'move', 'end']) {
        if (actions.includes('start') && this.dragStartHandler) {
            this.dragStartHandler.unsubscribe();
            this.dragStartHandler = null;
        }
        if (actions.includes('move') && this.dragMoveHandler) {
            this.dragMoveHandler.unsubscribe();
            this.dragMoveHandler = null;
        }
        if (actions.includes('end') && this.dragEndHandler) {
            this.dragEndHandler.unsubscribe();
            this.dragEndHandler = null;
        }
    }
    subscribeMouseListeners(actions = ['start', 'move', 'end']) {
        if (actions.includes('start') && this.dragStartListener && !this.dragStartHandler) {
            this.dragStartHandler = this.dragStartListener.subscribe(this.mouseStartMoving.bind(this));
        }
        if (actions.includes('move') && this.dragMoveListener && !this.dragMoveHandler) {
            this.dragMoveHandler = this.dragMoveListener.subscribe(this.mouseMoving.bind(this));
        }
        if (actions.includes('end') && this.dragEndListener && !this.dragEndHandler) {
            this.dragEndHandler = this.dragEndListener.subscribe(this.mouseStopMoving.bind(this));
        }
    }
    mouseStartMoving(value) {
        this.pointerController(true);
        this.setValue(value);
    }
    mouseMoving(value) {
        this.setValue(this.ensureValueInRange(value));
        this.cdr.markForCheck();
    }
    mouseStopMoving() {
        this.pointerController(false);
        this.cdr.markForCheck();
        this.thyAfterChange.emit({ value: this.value });
    }
    pointerController(movable) {
        if (movable) {
            this.subscribeMouseListeners(['move', 'end']);
        }
        else {
            this.unsubscribeMouseListeners(['move', 'end']);
        }
    }
    registerMouseEventsListeners() {
        const orientField = this.thyVertical ? 'pageY' : 'pageX';
        this.dragStartListener = this.ngZone.runOutsideAngular(() => {
            return fromEvent(this.ref.nativeElement, 'mousedown').pipe(tap((e) => {
                e.stopPropagation();
                e.preventDefault();
            }), pluck(orientField), map((position) => this.mousePositionToAdaptiveValue(position)));
        });
        this.dragEndListener = this.ngZone.runOutsideAngular(() => {
            return fromEvent(document, 'mouseup');
        });
        this.dragMoveListener = this.ngZone.runOutsideAngular(() => {
            return fromEvent(document, 'mousemove').pipe(tap((e) => {
                e.stopPropagation();
                e.preventDefault();
            }), pluck(orientField), distinctUntilChanged(), map((position) => this.mousePositionToAdaptiveValue(position)), distinctUntilChanged(), takeUntil(this.dragEndListener));
        });
    }
    mousePositionToAdaptiveValue(position) {
        const sliderStartPosition = this.getSliderPagePosition();
        const sliderLength = this.getRailLength();
        const ratio = this.convertPointerPositionToRatio(position, sliderStartPosition, sliderLength);
        const value = this.ratioToValue(ratio);
        return parseFloat(value.toFixed(this.getDecimals(this.thyStep)));
    }
    getSliderPagePosition() {
        const rect = this.ref.nativeElement.getBoundingClientRect();
        const window = this.ref.nativeElement.ownerDocument.defaultView;
        const orientFields = this.thyVertical ? ['bottom', 'pageYOffset'] : ['left', 'pageXOffset'];
        return rect[orientFields[0]] + window[orientFields[1]];
    }
    getRailLength() {
        const orientFiled = this.thyVertical ? 'clientHeight' : 'clientWidth';
        return this.sliderRail.nativeElement[orientFiled];
    }
    convertPointerPositionToRatio(pointerPosition, startPosition, totalLength) {
        if (this.thyVertical) {
            return clamp((startPosition - pointerPosition) / totalLength, 0, 1);
        }
        return clamp((pointerPosition - startPosition) / totalLength, 0, 1);
    }
    ratioToValue(ratio) {
        let value = (this.thyMax - this.thyMin) * ratio + this.thyMin;
        const step = this.thyStep;
        if (ratio === 0) {
            value = this.thyMin;
        }
        else if (ratio === 1) {
            value = this.thyMax;
        }
        else {
            value = Math.round(value / step) * step;
        }
        return clamp(value, this.thyMin, this.thyMax);
    }
    getDecimals(value) {
        const valueString = value.toString();
        const integerLength = valueString.indexOf('.') + 1;
        return integerLength >= 0 ? valueString.length - integerLength : 0;
    }
}
ThySliderComponent.ɵfac = function ThySliderComponent_Factory(t) { return new (t || ThySliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.UpdateHostClassService)); };
ThySliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThySliderComponent, selectors: [["thy-slider"]], viewQuery: function ThySliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sliderRail = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sliderTrack = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sliderPointer = _t.first);
    } }, hostVars: 8, hostBindings: function ThySliderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slider-vertical", ctx.thyVertical)("slider-disabled", ctx.thyDisabled)("thy-slider", ctx._thySlider)("cursor-pointer", ctx._pointer);
    } }, inputs: { thyVertical: "thyVertical", thyDisabled: "thyDisabled", thyMax: "thyMax", thyMin: "thyMin", thyStep: "thyStep", thyType: "thyType", thyColor: "thyColor" }, outputs: { thyAfterChange: "thyAfterChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ThySliderComponent),
                multi: true
            },
            UpdateHostClassService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 6, vars: 6, consts: [[1, "thy-slider-rail"], ["sliderRail", ""], [1, "thy-slider-track", 3, "ngStyle"], ["sliderTrack", ""], [1, "thy-slider-pointer", 3, "ngStyle"], ["sliderPointer", ""]], template: function ThySliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "div", 2, 3);
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx.thyColor));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(4, _c4, ctx.thyColor));
    } }, directives: [ɵngcc2.NgStyle], encapsulation: 2 });
ThySliderComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: ElementRef },
    { type: UpdateHostClassService }
];
ThySliderComponent.propDecorators = {
    thyVertical: [{ type: HostBinding, args: ['class.slider-vertical',] }, { type: Input }],
    thyDisabled: [{ type: HostBinding, args: ['class.slider-disabled',] }, { type: Input }],
    _thySlider: [{ type: HostBinding, args: ['class.thy-slider',] }],
    _pointer: [{ type: HostBinding, args: ['class.cursor-pointer',] }],
    sliderRail: [{ type: ViewChild, args: ['sliderRail', { static: true },] }],
    sliderTrack: [{ type: ViewChild, args: ['sliderTrack', { static: true },] }],
    sliderPointer: [{ type: ViewChild, args: ['sliderPointer', { static: true },] }],
    thyMax: [{ type: Input }],
    thyMin: [{ type: Input }],
    thyStep: [{ type: Input }],
    thyType: [{ type: Input }],
    thyColor: [{ type: Input }],
    thyAfterChange: [{ type: Output }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], ThySliderComponent.prototype, "thyVertical", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], ThySliderComponent.prototype, "thyDisabled", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThySliderComponent, [{
        type: Component,
        args: [{
                selector: 'thy-slider',
                template: "<div class=\"thy-slider-rail\" #sliderRail>\n  <div class=\"thy-slider-track\" #sliderTrack [ngStyle]=\"{ 'background-color': thyColor }\"></div>\n  <div class=\"thy-slider-pointer\" #sliderPointer [ngStyle]=\"{ 'border-color': thyColor }\"></div>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ThySliderComponent),
                        multi: true
                    },
                    UpdateHostClassService
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.UpdateHostClassService }]; }, { thyVertical: [{
            type: HostBinding,
            args: ['class.slider-vertical']
        }, {
            type: Input
        }], thyDisabled: [{
            type: HostBinding,
            args: ['class.slider-disabled']
        }, {
            type: Input
        }], _thySlider: [{
            type: HostBinding,
            args: ['class.thy-slider']
        }], _pointer: [{
            type: HostBinding,
            args: ['class.cursor-pointer']
        }], thyMax: [{
            type: Input
        }], thyMin: [{
            type: Input
        }], thyStep: [{
            type: Input
        }], thyAfterChange: [{
            type: Output
        }], thyType: [{
            type: Input
        }], sliderRail: [{
            type: ViewChild,
            args: ['sliderRail', { static: true }]
        }], sliderTrack: [{
            type: ViewChild,
            args: ['sliderTrack', { static: true }]
        }], sliderPointer: [{
            type: ViewChild,
            args: ['sliderPointer', { static: true }]
        }], thyColor: [{
            type: Input
        }] }); })();

class ThySliderModule {
}
ThySliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThySliderModule });
ThySliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThySliderModule_Factory(t) { return new (t || ThySliderModule)(); }, providers: [], imports: [[CommonModule, FormsModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThySliderModule, { declarations: function () { return [ThySliderComponent]; }, imports: function () { return [CommonModule, FormsModule]; }, exports: function () { return [ThySliderComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThySliderModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule],
                exports: [ThySliderComponent],
                declarations: [ThySliderComponent],
                providers: []
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ThySliderComponent, ThySliderModule };

//# sourceMappingURL=ngx-tethys-slider.js.map