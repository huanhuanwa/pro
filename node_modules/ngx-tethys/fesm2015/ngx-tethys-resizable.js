import { Injectable, NgZone, Inject, EventEmitter, Directive, ElementRef, Renderer2, Input, Output, Component, ChangeDetectionStrategy, ChangeDetectorRef, NgModule } from '@angular/core';
import { __decorate, __metadata } from 'tslib';
import { mixinUnsubscribe, MixinBase, InputBoolean } from 'ngx-tethys/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { isTouchEvent } from 'ngx-tethys/util';
import { Subject } from 'rxjs';
import { Platform } from '@angular/cdk/platform';
import { takeUntil } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/platform';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["*"];
function ThyResizeHandlesComponent_thy_resize_handle_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "thy-resize-handle", 1);
} if (rf & 2) {
    const dir_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("thyDirection", dir_r1);
} }
class ThyResizableService {
    constructor(ngZone, document) {
        this.ngZone = ngZone;
        this.listeners = new Map();
        this.handleMouseDown$ = new Subject();
        this.documentMouseUp$ = new Subject();
        this.documentMouseMove$ = new Subject();
        this.mouseEntered$ = new Subject();
        this.document = document;
    }
    startResizing(event) {
        const _isTouchEvent = isTouchEvent(event);
        this.clearListeners();
        const moveEvent = _isTouchEvent ? 'touchmove' : 'mousemove';
        const upEvent = _isTouchEvent ? 'touchend' : 'mouseup';
        const moveEventHandler = (e) => {
            this.documentMouseMove$.next(e);
        };
        const upEventHandler = (e) => {
            this.documentMouseUp$.next(e);
            this.clearListeners();
        };
        this.listeners.set(moveEvent, moveEventHandler);
        this.listeners.set(upEvent, upEventHandler);
        this.ngZone.runOutsideAngular(() => {
            this.listeners.forEach((handler, name) => {
                this.document.addEventListener(name, handler);
            });
        });
    }
    clearListeners() {
        this.listeners.forEach((handler, name) => {
            this.document.removeEventListener(name, handler);
        });
        this.listeners.clear();
    }
    ngOnDestroy() {
        this.handleMouseDown$.complete();
        this.documentMouseUp$.complete();
        this.documentMouseMove$.complete();
        this.mouseEntered$.complete();
        this.clearListeners();
    }
}
ThyResizableService.ɵfac = function ThyResizableService_Factory(t) { return new (t || ThyResizableService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT)); };
ThyResizableService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ThyResizableService, factory: ThyResizableService.ɵfac });
ThyResizableService.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

function getEventWithPoint(event) {
    return isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
}
function ensureInBounds(value, boundValue) {
    return value ? (value < boundValue ? value : boundValue) : boundValue;
}

const _MixinBase$1 = mixinUnsubscribe(MixinBase);
class ThyResizableDirective extends _MixinBase$1 {
    constructor(elementRef, renderer, platform, ngZone, thyResizableService) {
        super();
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.platform = platform;
        this.ngZone = ngZone;
        this.thyResizableService = thyResizableService;
        this.thyBounds = 'parent';
        this.thyMinHeight = 40;
        this.thyMinWidth = 40;
        this.thyGridColumnCount = -1;
        this.thyMaxColumn = -1;
        this.thyMinColumn = -1;
        this.thyLockAspectRatio = false;
        this.thyPreview = false;
        this.thyDisabled = false;
        this.thyResize = new EventEmitter();
        this.thyResizeEnd = new EventEmitter();
        this.thyResizeStart = new EventEmitter();
        this.resizing = false;
        this.sizeCache = null;
        this.ghostElement = null;
        this.currentHandleEvent = null;
        this.thyResizableService.handleMouseDown$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            if (this.thyDisabled) {
                return;
            }
            this.resizing = true;
            this.thyResizableService.startResizing(event.mouseEvent);
            this.currentHandleEvent = event;
            this.setCursor();
            this.thyResizeStart.emit({
                mouseEvent: event.mouseEvent
            });
            this.nativeElementRect = this.nativeElement.getBoundingClientRect();
        });
        this.thyResizableService.documentMouseUp$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            if (this.resizing) {
                this.resizing = false;
                this.thyResizableService.documentMouseUp$.next();
                this.endResize(event);
            }
        });
        this.thyResizableService.documentMouseMove$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            if (this.resizing) {
                this.resize(event);
            }
        });
    }
    ngAfterViewInit() {
        if (this.platform.isBrowser) {
            this.nativeElement = this.elementRef.nativeElement;
            this.setPosition();
        }
    }
    setCursor() {
        switch (this.currentHandleEvent.direction) {
            case 'left':
            case 'right':
                this.renderer.setStyle(document.body, 'cursor', 'ew-resize');
                break;
            case 'top':
            case 'bottom':
                this.renderer.setStyle(document.body, 'cursor', 'ns-resize');
                break;
            case 'topLeft':
            case 'bottomRight':
                this.renderer.setStyle(document.body, 'cursor', 'nwse-resize');
                break;
            case 'topRight':
            case 'bottomLeft':
                this.renderer.setStyle(document.body, 'cursor', 'nesw-resize');
                break;
        }
        this.renderer.setStyle(document.body, 'user-select', 'none');
    }
    setPosition() {
        const position = getComputedStyle(this.nativeElement).position;
        if (position === 'static' || !position) {
            this.renderer.setStyle(this.nativeElement, 'position', 'relative');
        }
    }
    onMouseenter() {
        this.thyResizableService.mouseEntered$.next(true);
    }
    onMouseleave() {
        this.thyResizableService.mouseEntered$.next(false);
    }
    endResize(event) {
        this.renderer.setStyle(document.body, 'cursor', '');
        this.renderer.setStyle(document.body, 'user-select', '');
        this.removeGhostElement();
        const size = this.sizeCache
            ? Object.assign({}, this.sizeCache) : {
            width: this.nativeElementRect.width,
            height: this.nativeElementRect.height
        };
        this.ngZone.run(() => {
            this.thyResizeEnd.emit(Object.assign(Object.assign({}, size), { mouseEvent: event }));
        });
        this.sizeCache = null;
        this.currentHandleEvent = null;
    }
    resize(event) {
        const nativeElementRect = this.nativeElementRect;
        const resizeEvent = getEventWithPoint(event);
        const handleEvent = getEventWithPoint(this.currentHandleEvent.mouseEvent);
        let width = nativeElementRect.width;
        let height = nativeElementRect.height;
        const ratio = this.thyLockAspectRatio ? width / height : -1;
        switch (this.currentHandleEvent.direction) {
            case 'bottomRight':
                width = resizeEvent.clientX - nativeElementRect.left;
                height = resizeEvent.clientY - nativeElementRect.top;
                break;
            case 'bottomLeft':
                width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
                height = resizeEvent.clientY - nativeElementRect.top;
                break;
            case 'topRight':
                width = resizeEvent.clientX - nativeElementRect.left;
                height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
                break;
            case 'topLeft':
                width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
                height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
                break;
            case 'top':
                height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
                break;
            case 'right':
                width = resizeEvent.clientX - nativeElementRect.left;
                break;
            case 'bottom':
                height = resizeEvent.clientY - nativeElementRect.top;
                break;
            case 'left':
                width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
        }
        const size = this.calcSize(width, height, ratio);
        this.sizeCache = Object.assign({}, size);
        if (this.thyPreview) {
            this.previewResize(size);
        }
        this.ngZone.run(() => {
            this.thyResize.emit(Object.assign(Object.assign({}, size), { mouseEvent: event }));
        });
    }
    calcSize(width, height, ratio) {
        let newWidth;
        let newHeight;
        let maxWidth;
        let maxHeight;
        let col = 0;
        let spanWidth = 0;
        let minWidth = this.thyMinWidth;
        let boundWidth = Infinity;
        let boundHeight = Infinity;
        if (this.thyBounds === 'parent') {
            const parent = this.renderer.parentNode(this.nativeElement);
            if (parent instanceof HTMLElement) {
                const parentRect = parent.getBoundingClientRect();
                boundWidth = parentRect.width;
                boundHeight = parentRect.height;
            }
        }
        else if (this.thyBounds === 'window') {
            if (typeof window !== 'undefined') {
                boundWidth = window.innerWidth;
                boundHeight = window.innerHeight;
            }
        }
        else if (this.thyBounds && this.thyBounds.nativeElement && this.thyBounds.nativeElement instanceof HTMLElement) {
            const boundsRect = this.thyBounds.nativeElement.getBoundingClientRect();
            boundWidth = boundsRect.width;
            boundHeight = boundsRect.height;
        }
        maxWidth = ensureInBounds(this.thyMaxWidth, boundWidth);
        maxHeight = ensureInBounds(this.thyMaxHeight, boundHeight);
        if (this.thyGridColumnCount !== -1) {
            spanWidth = maxWidth / this.thyGridColumnCount;
            minWidth = this.thyMinColumn !== -1 ? spanWidth * this.thyMinColumn : minWidth;
            maxWidth = this.thyMaxColumn !== -1 ? spanWidth * this.thyMaxColumn : maxWidth;
        }
        if (ratio !== -1) {
            if (/(left|right)/i.test(this.currentHandleEvent.direction)) {
                newWidth = Math.min(Math.max(width, minWidth), maxWidth);
                newHeight = Math.min(Math.max(newWidth / ratio, this.thyMinHeight), maxHeight);
                if (newHeight >= maxHeight || newHeight <= this.thyMinHeight) {
                    newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
                }
            }
            else {
                newHeight = Math.min(Math.max(height, this.thyMinHeight), maxHeight);
                newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
                if (newWidth >= maxWidth || newWidth <= minWidth) {
                    newHeight = Math.min(Math.max(newWidth / ratio, this.thyMinHeight), maxHeight);
                }
            }
        }
        else {
            newWidth = Math.min(Math.max(width, minWidth), maxWidth);
            newHeight = Math.min(Math.max(height, this.thyMinHeight), maxHeight);
        }
        if (this.thyGridColumnCount !== -1) {
            col = Math.round(newWidth / spanWidth);
            newWidth = col * spanWidth;
        }
        return {
            col,
            width: newWidth,
            height: newHeight
        };
    }
    previewResize({ width, height }) {
        this.createGhostElement();
        this.renderer.setStyle(this.ghostElement, 'width', `${width}px`);
        this.renderer.setStyle(this.ghostElement, 'height', `${height}px`);
    }
    createGhostElement() {
        if (!this.ghostElement) {
            this.ghostElement = this.renderer.createElement('div');
            this.renderer.setAttribute(this.ghostElement, 'class', 'thy-resizable-preview');
        }
        this.renderer.appendChild(this.nativeElement, this.ghostElement);
    }
    removeGhostElement() {
        if (this.ghostElement) {
            this.renderer.removeChild(this.nativeElement, this.ghostElement);
        }
    }
    ngOnDestroy() {
        this.ghostElement = null;
        this.sizeCache = null;
        super.ngOnDestroy();
    }
}
ThyResizableDirective.ɵfac = function ThyResizableDirective_Factory(t) { return new (t || ThyResizableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ThyResizableService)); };
ThyResizableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyResizableDirective, selectors: [["", "thyResizable", ""]], hostAttrs: [1, "thy-resizable"], hostVars: 4, hostBindings: function ThyResizableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function ThyResizableDirective_mouseenter_HostBindingHandler() { return ctx.onMouseenter(); })("mouseleave", function ThyResizableDirective_mouseleave_HostBindingHandler() { return ctx.onMouseleave(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-resizable-resizing", ctx.resizing)("thy-resizable-disabled", ctx.thyDisabled);
    } }, inputs: { thyBounds: "thyBounds", thyMinHeight: "thyMinHeight", thyMinWidth: "thyMinWidth", thyGridColumnCount: "thyGridColumnCount", thyMaxColumn: "thyMaxColumn", thyMinColumn: "thyMinColumn", thyLockAspectRatio: "thyLockAspectRatio", thyPreview: "thyPreview", thyDisabled: "thyDisabled", thyMaxHeight: "thyMaxHeight", thyMaxWidth: "thyMaxWidth" }, outputs: { thyResize: "thyResize", thyResizeEnd: "thyResizeEnd", thyResizeStart: "thyResizeStart" }, features: [ɵngcc0.ɵɵProvidersFeature([ThyResizableService]), ɵngcc0.ɵɵInheritDefinitionFeature] });
ThyResizableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Platform },
    { type: NgZone },
    { type: ThyResizableService }
];
ThyResizableDirective.propDecorators = {
    thyBounds: [{ type: Input }],
    thyMaxHeight: [{ type: Input }],
    thyMaxWidth: [{ type: Input }],
    thyMinHeight: [{ type: Input }],
    thyMinWidth: [{ type: Input }],
    thyGridColumnCount: [{ type: Input }],
    thyMaxColumn: [{ type: Input }],
    thyMinColumn: [{ type: Input }],
    thyLockAspectRatio: [{ type: Input }],
    thyPreview: [{ type: Input }],
    thyDisabled: [{ type: Input }],
    thyResize: [{ type: Output }],
    thyResizeEnd: [{ type: Output }],
    thyResizeStart: [{ type: Output }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], ThyResizableDirective.prototype, "thyLockAspectRatio", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], ThyResizableDirective.prototype, "thyPreview", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], ThyResizableDirective.prototype, "thyDisabled", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyResizableService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyResizableDirective, [{
        type: Directive,
        args: [{
                selector: '[thyResizable]',
                providers: [ThyResizableService],
                host: {
                    class: 'thy-resizable',
                    '[class.thy-resizable-resizing]': 'resizing',
                    '[class.thy-resizable-disabled]': 'thyDisabled',
                    '(mouseenter)': 'onMouseenter()',
                    '(mouseleave)': 'onMouseleave()'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }, { type: ThyResizableService }]; }, { thyBounds: [{
            type: Input
        }], thyMinHeight: [{
            type: Input
        }], thyMinWidth: [{
            type: Input
        }], thyGridColumnCount: [{
            type: Input
        }], thyMaxColumn: [{
            type: Input
        }], thyMinColumn: [{
            type: Input
        }], thyLockAspectRatio: [{
            type: Input
        }], thyPreview: [{
            type: Input
        }], thyDisabled: [{
            type: Input
        }], thyResize: [{
            type: Output
        }], thyResizeEnd: [{
            type: Output
        }], thyResizeStart: [{
            type: Output
        }], thyMaxHeight: [{
            type: Input
        }], thyMaxWidth: [{
            type: Input
        }] }); })();

class ThyResizeHandleMouseDownEvent {
    constructor(direction, mouseEvent) {
        this.direction = direction;
        this.mouseEvent = mouseEvent;
    }
}
const _MixinBase = mixinUnsubscribe(MixinBase);
class ThyResizeHandleComponent extends _MixinBase {
    constructor(thyResizableService, cdr, elementRef) {
        super();
        this.thyResizableService = thyResizableService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.thyDirection = 'bottomRight';
        this.thyMouseDown = new EventEmitter();
        this.entered = false;
        // TODO: move to host after View Engine deprecation
        this.elementRef.nativeElement.classList.add('thy-resizable-handle');
    }
    ngOnInit() {
        this.thyResizableService.mouseEntered$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(entered => {
            this.entered = entered;
            this.cdr.markForCheck();
        });
    }
    onMousedown(event) {
        this.thyResizableService.handleMouseDown$.next(new ThyResizeHandleMouseDownEvent(this.thyDirection, event));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
ThyResizeHandleComponent.ɵfac = function ThyResizeHandleComponent_Factory(t) { return new (t || ThyResizeHandleComponent)(ɵngcc0.ɵɵdirectiveInject(ThyResizableService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ThyResizeHandleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyResizeHandleComponent, selectors: [["thy-resize-handle"], ["", "thy-resize-handle", ""]], hostVars: 18, hostBindings: function ThyResizeHandleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function ThyResizeHandleComponent_mousedown_HostBindingHandler($event) { return ctx.onMousedown($event); })("touchstart", function ThyResizeHandleComponent_touchstart_HostBindingHandler($event) { return ctx.onMousedown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-resizable-handle-top", ctx.thyDirection === "top")("thy-resizable-handle-right", ctx.thyDirection === "right")("thy-resizable-handle-bottom", ctx.thyDirection === "bottom")("thy-resizable-handle-left", ctx.thyDirection === "left")("thy-resizable-handle-topRight", ctx.thyDirection === "topRight")("thy-resizable-handle-bottomRight", ctx.thyDirection === "bottomRight")("thy-resizable-handle-bottomLeft", ctx.thyDirection === "bottomLeft")("thy-resizable-handle-topLeft", ctx.thyDirection === "topLeft")("thy-resizable-handle-box-hover", ctx.entered);
    } }, inputs: { thyDirection: "thyDirection" }, outputs: { thyMouseDown: "thyMouseDown" }, exportAs: ["thyResizeHandle"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ThyResizeHandleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
ThyResizeHandleComponent.ctorParameters = () => [
    { type: ThyResizableService },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
ThyResizeHandleComponent.propDecorators = {
    thyDirection: [{ type: Input }],
    thyMouseDown: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyResizeHandleComponent, [{
        type: Component,
        args: [{
                selector: 'thy-resize-handle, [thy-resize-handle]',
                exportAs: 'thyResizeHandle',
                template: `
        <ng-content></ng-content>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.thy-resizable-handle-top]': `thyDirection === 'top'`,
                    '[class.thy-resizable-handle-right]': `thyDirection === 'right'`,
                    '[class.thy-resizable-handle-bottom]': `thyDirection === 'bottom'`,
                    '[class.thy-resizable-handle-left]': `thyDirection === 'left'`,
                    '[class.thy-resizable-handle-topRight]': `thyDirection === 'topRight'`,
                    '[class.thy-resizable-handle-bottomRight]': `thyDirection === 'bottomRight'`,
                    '[class.thy-resizable-handle-bottomLeft]': `thyDirection === 'bottomLeft'`,
                    '[class.thy-resizable-handle-topLeft]': `thyDirection === 'topLeft'`,
                    '[class.thy-resizable-handle-box-hover]': 'entered',
                    '(mousedown)': 'onMousedown($event)',
                    '(touchstart)': 'onMousedown($event)'
                }
            }]
    }], function () { return [{ type: ThyResizableService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { thyDirection: [{
            type: Input
        }], thyMouseDown: [{
            type: Output
        }] }); })();

const DEFAULT_RESIZE_DIRECTION = [
    'bottomRight',
    'topRight',
    'bottomLeft',
    'topLeft',
    'bottom',
    'right',
    'top',
    'left'
];
class ThyResizeHandlesComponent {
    constructor() {
        this.thyDirections = DEFAULT_RESIZE_DIRECTION;
        this.directions = new Set(this.thyDirections);
    }
    ngOnChanges(changes) {
        if (changes.thyDirections) {
            this.directions = new Set(changes.thyDirections.currentValue);
        }
    }
}
ThyResizeHandlesComponent.ɵfac = function ThyResizeHandlesComponent_Factory(t) { return new (t || ThyResizeHandlesComponent)(); };
ThyResizeHandlesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyResizeHandlesComponent, selectors: [["thy-resize-handles"]], inputs: { thyDirections: "thyDirections" }, exportAs: ["thyResizeHandles"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[3, "thyDirection", 4, "ngFor", "ngForOf"], [3, "thyDirection"]], template: function ThyResizeHandlesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ThyResizeHandlesComponent_thy_resize_handle_0_Template, 1, 1, "thy-resize-handle", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.directions);
    } }, directives: [ɵngcc2.NgForOf, ThyResizeHandleComponent], encapsulation: 2, changeDetection: 0 });
ThyResizeHandlesComponent.ctorParameters = () => [];
ThyResizeHandlesComponent.propDecorators = {
    thyDirections: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyResizeHandlesComponent, [{
        type: Component,
        args: [{
                selector: 'thy-resize-handles',
                exportAs: 'thyResizeHandles',
                template: `
        <thy-resize-handle *ngFor="let dir of directions" [thyDirection]="dir"></thy-resize-handle>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { thyDirections: [{
            type: Input
        }] }); })();

class ThyResizableModule {
}
ThyResizableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyResizableModule });
ThyResizableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyResizableModule_Factory(t) { return new (t || ThyResizableModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyResizableModule, { declarations: function () { return [ThyResizableDirective, ThyResizeHandleComponent, ThyResizeHandlesComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ThyResizableDirective, ThyResizeHandleComponent, ThyResizeHandlesComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyResizableModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [ThyResizableDirective, ThyResizeHandleComponent, ThyResizeHandlesComponent],
                exports: [ThyResizableDirective, ThyResizeHandleComponent, ThyResizeHandlesComponent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_RESIZE_DIRECTION, ThyResizableDirective, ThyResizableModule, ThyResizableService, ThyResizeHandleComponent, ThyResizeHandleMouseDownEvent, ThyResizeHandlesComponent, ensureInBounds, getEventWithPoint };

//# sourceMappingURL=ngx-tethys-resizable.js.map