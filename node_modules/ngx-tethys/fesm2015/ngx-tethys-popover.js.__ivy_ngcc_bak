import * as i0 from '@angular/core';
import { Component, HostBinding, InjectionToken, EventEmitter, ElementRef, Inject, ChangeDetectorRef, NgZone, ViewChild, HostListener, Injector, Injectable, Optional, Input, Output, Directive, ViewContainerRef, NgModule } from '@angular/core';
import { ThyAbstractOverlayConfig, ThyAbstractOverlayContainer, ThyClickDispatcher, ThyAbstractOverlayRef, ThyAbstractInternalOverlayRef, ThyAbstractOverlayService, getFlexiblePositions, ThyTranslate, ThyOverlayDirectiveBase } from 'ngx-tethys/core';
import { isFunction } from 'ngx-tethys/util';
import { timer, Subject, of } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';
import { coerceElement, coerceArray } from '@angular/cdk/coercion';
import * as i1 from '@angular/cdk/overlay';
import { Overlay, FlexibleConnectedPositionStrategy, ViewportRuler, OverlayContainer, OverlayModule } from '@angular/cdk/overlay';
import * as i5 from '@angular/cdk/platform';
import { Platform } from '@angular/cdk/platform';
import { CdkPortalOutlet, ComponentPortal, PortalModule } from '@angular/cdk/portal';
import * as i4 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { state, style, trigger } from '@angular/animations';
import * as i3 from '@angular/cdk/scrolling';
import { ThyIconModule } from 'ngx-tethys/icon';
import { FocusMonitor } from '@angular/cdk/a11y';

class ThyPopoverBodyComponent {
    constructor() {
        this.isPopoverBody = true;
    }
}
ThyPopoverBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-popover-body',
                template: '<ng-content></ng-content>',
                exportAs: 'thyPopoverBody'
            },] }
];
ThyPopoverBodyComponent.propDecorators = {
    isPopoverBody: [{ type: HostBinding, args: ['class.thy-popover-body',] }]
};

class ThyPopoverConfig extends ThyAbstractOverlayConfig {
}
const THY_POPOVER_DEFAULT_CONFIG = new InjectionToken('thy-popover-default-config');
const THY_POPOVER_DEFAULT_CONFIG_VALUE = {
    hasBackdrop: true,
    backdropClass: 'thy-popover-backdrop',
    panelClass: '',
    offset: 4,
    backdropClosable: true,
    closeOnNavigation: true,
    placement: 'bottom',
    insideClosable: false,
    manualClosure: false,
    originActiveClass: 'thy-popover-origin-active'
};
const THY_POPOVER_DEFAULT_CONFIG_PROVIDER = {
    provide: THY_POPOVER_DEFAULT_CONFIG,
    useValue: THY_POPOVER_DEFAULT_CONFIG_VALUE
};
const THY_POPOVER_SCROLL_STRATEGY = new InjectionToken('thy-popover-scroll-strategy');
const THY_POPOVER_SCROLL_STRATEGY_FACTORY = (overlay) => {
    return () => overlay.scrollStrategies.block();
};
const THY_POPOVER_SCROLL_STRATEGY_PROVIDER = {
    provide: THY_POPOVER_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: THY_POPOVER_SCROLL_STRATEGY_FACTORY
};

const animationBody = [
    // Note: The `enter` animation transitions to `transform: none`, because for some reason
    // specifying the transform explicitly, causes IE both to blur the dialog content and
    // decimate the animation performance. Leaving it as `none` solves both issues. translate(-300px,-100px)
    state('void, exit', style({ opacity: 0, transform: 'scale(0.1)' })),
    state('enter', style({ transform: 'none' }))
    // transition('* => enter', animate('100ms cubic-bezier(0, 0, 0.57, 1)', style({ transform: 'none', opacity: 1 }))),
    // transition(
    //     '* => exit',
    //     animate('150ms cubic-bezier(0.24, 0.18, 0.96, 0.52)', style({ transform: 'scale(0.3)', opacity: 0 }))
    // )
];
/**
 * Animations used by ThyPopover.
 * @docs-private
 */
const thyPopoverAnimations = {
    popoverContainer: trigger('popoverContainer', animationBody)
};
// export const setAnimationStart

const popoverUpperOverlayOptions = {
    name: 'popover',
    animationEnabled: true,
    disposeWhenClose: true
};

class ThyPopoverContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, thyClickDispatcher, ngZone) {
        super(popoverUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.thyClickDispatcher = thyClickDispatcher;
        this.ngZone = ngZone;
        /** State of the popover animation. */
        this.animationState = 'enter';
        /** Emits when an animation state changes. */
        this.animationStateChanged = new EventEmitter();
        this.insideClicked = new EventEmitter();
        this.outsideClicked = new EventEmitter();
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'enter';
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
    }
    beforeAttachPortal() { }
    ngAfterViewInit() {
        if (this.config.outsideClosable && !this.config.hasBackdrop) {
            timer().subscribe(() => {
                this.thyClickDispatcher
                    .clicked()
                    .pipe(takeUntil(this.animationClosingDone))
                    .subscribe((event) => {
                    if (!this.elementRef.nativeElement.contains(event.target)) {
                        this.ngZone.run(() => {
                            this.outsideClicked.emit();
                        });
                    }
                });
            });
        }
    }
    /** Callback, invoked whenever an animation on the host completes. */
    onAnimationDone(event) {
        // if (event.toState === 'void') {
        //     this.trapFocus();
        // } else if (event.toState === 'exit') {
        //     this.restoreFocus();
        // }
        this.animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    startExitAnimation() {
        this.animationState = 'exit';
        // Mark the container for check so it can react if the
        // view container is using OnPush change detection.
        this.changeDetectorRef.markForCheck();
    }
    onInsideClick() {
        if (this.config.insideClosable) {
            this.insideClicked.emit();
        }
    }
    ngOnDestroy() {
        super.destroy();
    }
}
ThyPopoverContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-popover-container',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                animations: [thyPopoverAnimations.popoverContainer],
                host: {
                    class: 'thy-popover-container',
                    tabindex: '-1',
                    '[attr.role]': `'popover'`,
                    '[@popoverContainer]': 'animationState',
                    '(@popoverContainer.start)': 'onAnimationStart($event)',
                    '(@popoverContainer.done)': 'onAnimationDone($event)'
                }
            },] }
];
ThyPopoverContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThyPopoverConfig },
    { type: ChangeDetectorRef },
    { type: ThyClickDispatcher },
    { type: NgZone }
];
ThyPopoverContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }],
    onInsideClick: [{ type: HostListener, args: ['click', [],] }]
};

class ThyPopoverRef extends ThyAbstractOverlayRef {
}
class ThyInternalPopoverRef extends ThyAbstractInternalOverlayRef {
    constructor(overlayRef, containerInstance, config) {
        super(popoverUpperOverlayOptions, overlayRef, containerInstance, config);
        containerInstance.insideClicked.subscribe(() => {
            this.close();
        });
        containerInstance.outsideClicked.subscribe(() => {
            this.close();
        });
    }
    /**
     * Updates the popover's position.
     * @param position New popover position.
     */
    updatePosition() {
        this.overlayRef.updatePosition();
        return this;
    }
}

class ThyPopover extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig, scrollStrategy, ngZone, _viewportRuler, _document, _platform, _overlayContainer) {
        super(popoverUpperOverlayOptions, overlay, injector, Object.assign(Object.assign({}, THY_POPOVER_DEFAULT_CONFIG_VALUE), defaultConfig), scrollStrategy);
        this.ngZone = ngZone;
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        this.ngUnsubscribe$ = new Subject();
        this.originInstancesMap = new Map();
    }
    buildPositionStrategy(config) {
        const origin = config.originPosition ? config.originPosition : config.origin;
        // const positionStrategy = this.overlay.position().flexibleConnectedTo(origin);
        const positionStrategy = new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        const positions = getFlexiblePositions(config.placement, config.offset, 'thy-popover');
        positionStrategy.withPositions(positions);
        positionStrategy.withGrowAfterOpen(true);
        positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {
            if (change.scrollableViewProperties.isOverlayClipped) {
                // After position changes occur and the overlay is clipped by
                // a parent scrollable then close the tooltip.
                this.ngZone.run(() => this.close());
            }
        });
        return positionStrategy;
    }
    buildScrollStrategy(config) {
        if (config.scrollStrategy) {
            return config.scrollStrategy;
        }
        else if (this.scrollStrategy && isFunction(this.scrollStrategy)) {
            return this.scrollStrategy();
        }
        else {
            this.overlay.scrollStrategies.block();
        }
    }
    buildOverlayConfig(config) {
        const positionStrategy = this.buildPositionStrategy(config);
        const overlayConfig = this.buildBaseOverlayConfig(config);
        overlayConfig.positionStrategy = positionStrategy;
        overlayConfig.scrollStrategy = this.buildScrollStrategy(config);
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThyPopoverConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThyPopoverContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalPopoverRef(overlayRef, containerInstance, config);
    }
    createInjector(config, popoverRef, popoverContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            { provide: ThyPopoverContainerComponent, useValue: popoverContainer },
            {
                provide: ThyPopoverRef,
                useValue: popoverRef
            }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    originElementAddActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.add(...coerceArray(config.originActiveClass));
        }
    }
    originElementRemoveActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.remove(...coerceArray(config.originActiveClass));
        }
    }
    ensureCloseClosest(origin) {
        let closeAndEnd = false;
        this.originInstancesMap.forEach((value, key) => {
            if (value.config.manualClosure) {
                if (key === origin) {
                    value.popoverRef.close();
                    closeAndEnd = true;
                }
            }
            else {
                if (key === origin) {
                    closeAndEnd = true;
                }
                value.popoverRef.close();
            }
        });
        return closeAndEnd;
    }
    open(componentOrTemplateRef, config) {
        const originElement = coerceElement(config.origin);
        // 默认关闭之前的弹出框
        // 1. 当之前的 Popover 设置 manualClosure 为 true 时, 弹出其他 Popover 时不自动关闭 manualClosure 为 true 的 Popover
        // 2. 当前的 Origin 对应的 Popover 已经弹出，不管 manualClosure 设置为何，直接关闭并返回
        if (this.ensureCloseClosest(originElement)) {
            return;
        }
        const popoverRef = this.openUpperOverlay(componentOrTemplateRef, config);
        config = popoverRef.containerInstance.config;
        popoverRef.afterClosed().subscribe(() => {
            this.originElementRemoveActiveClass(config);
            this.originInstancesMap.delete(originElement);
        });
        this.originElementAddActiveClass(config);
        this.originInstancesMap.set(originElement, {
            config,
            popoverRef
        });
        return popoverRef;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyPopover.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyPopover_Factory() { return new ThyPopover(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(THY_POPOVER_DEFAULT_CONFIG, 8), i0.ɵɵinject(THY_POPOVER_SCROLL_STRATEGY), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.ViewportRuler), i0.ɵɵinject(i4.DOCUMENT, 8), i0.ɵɵinject(i5.Platform), i0.ɵɵinject(i1.OverlayContainer)); }, token: ThyPopover, providedIn: "root" });
ThyPopover.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ThyPopover.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThyPopoverConfig, decorators: [{ type: Optional }, { type: Inject, args: [THY_POPOVER_DEFAULT_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [THY_POPOVER_SCROLL_STRATEGY,] }] },
    { type: NgZone },
    { type: ViewportRuler },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: Platform },
    { type: OverlayContainer }
];

class ThyPopoverHeaderComponent {
    constructor(translate, thyPopover) {
        this.translate = translate;
        this.thyPopover = thyPopover;
        this.thyClosed = new EventEmitter();
    }
    set thyTitleTranslationKey(key) {
        if (key && !this.thyTitle) {
            this.thyTitle = this.translate.instant(key);
        }
    }
    close(event) {
        this.thyClosed.emit(event);
        this.thyPopover.close();
    }
}
ThyPopoverHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-popover-header',
                template: "<div class=\"thy-popover-header\">\n  <h5 class=\"thy-popover-title\">{{ thyTitle }}</h5>\n  <button type=\"button\" class=\"close\" (click)=\"close($event)\">\n    <thy-icon thyIconName=\"close-bold\"></thy-icon>\n  </button>\n</div>\n",
                exportAs: 'thyPopoverHeader'
            },] }
];
ThyPopoverHeaderComponent.ctorParameters = () => [
    { type: ThyTranslate },
    { type: ThyPopover }
];
ThyPopoverHeaderComponent.propDecorators = {
    thyTitle: [{ type: Input }],
    thyTitleTranslationKey: [{ type: Input }],
    thyClosed: [{ type: Output }]
};

class ThyPopoverDirective extends ThyOverlayDirectiveBase {
    constructor(elementRef, platform, focusMonitor, ngZone, popover, viewContainerRef) {
        super(elementRef, platform, focusMonitor, ngZone);
        this.popover = popover;
        this.viewContainerRef = viewContainerRef;
        this.popoverOpened = false;
        this.showDelay = 0;
        this.hideDelay = 0;
        this.tooltipPin = true;
    }
    set thyTrigger(trigger) {
        this.trigger = trigger;
    }
    ngOnInit() {
        this.initialize();
    }
    createOverlay() {
        const config = Object.assign({
            origin: this.elementRef.nativeElement,
            hasBackdrop: this.trigger === 'click' || this.trigger === 'focus',
            viewContainerRef: this.viewContainerRef,
            placement: this.thyPlacement,
            offset: this.thyOffset
        }, this.thyConfig);
        this.popoverRef = this.popover.open(this.content, config);
        this.popoverRef.afterClosed().subscribe(() => {
            this.popoverOpened = false;
        });
        return this.popoverRef.getOverlayRef();
    }
    show(delay = this.showDelay) {
        if (this.hideTimeoutId) {
            clearTimeout(this.hideTimeoutId);
            this.hideTimeoutId = null;
        }
        if (this.disabled || (this.overlayRef && this.overlayRef.hasAttached())) {
            return;
        }
        if (this.trigger !== 'hover') {
            delay = 0;
        }
        this.showTimeoutId = setTimeout(() => {
            const overlayRef = this.createOverlay();
            this.overlayRef = overlayRef;
            this.popoverOpened = true;
            this.showTimeoutId = null;
        }, delay);
    }
    hide(delay = this.hideDelay) {
        if (this.showTimeoutId) {
            clearTimeout(this.showTimeoutId);
            this.showTimeoutId = null;
        }
        this.hideTimeoutId = setTimeout(() => {
            if (this.popoverRef) {
                this.popoverRef.close();
            }
            this.hideTimeoutId = null;
        }, delay);
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyPopoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyPopover]'
            },] }
];
ThyPopoverDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Platform },
    { type: FocusMonitor },
    { type: NgZone },
    { type: ThyPopover },
    { type: ViewContainerRef }
];
ThyPopoverDirective.propDecorators = {
    popoverOpened: [{ type: HostBinding, args: [`class.thy-popover-opened`,] }],
    content: [{ type: Input, args: ['thyPopover',] }],
    thyTrigger: [{ type: Input }],
    thyPlacement: [{ type: Input }],
    thyOffset: [{ type: Input }],
    thyConfig: [{ type: Input }],
    showDelay: [{ type: Input, args: ['thyShowDelay',] }],
    hideDelay: [{ type: Input, args: ['thyHideDelay',] }]
};

class ThyPopoverModule {
}
ThyPopoverModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ThyPopoverContainerComponent, ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverBodyComponent],
                entryComponents: [ThyPopoverContainerComponent],
                imports: [CommonModule, OverlayModule, PortalModule, ThyIconModule],
                exports: [ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverBodyComponent],
                providers: [THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_SCROLL_STRATEGY_PROVIDER]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { THY_POPOVER_DEFAULT_CONFIG, THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_DEFAULT_CONFIG_VALUE, THY_POPOVER_SCROLL_STRATEGY, THY_POPOVER_SCROLL_STRATEGY_FACTORY, THY_POPOVER_SCROLL_STRATEGY_PROVIDER, ThyInternalPopoverRef, ThyPopover, ThyPopoverBodyComponent, ThyPopoverConfig, ThyPopoverContainerComponent, ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverModule, ThyPopoverRef, thyPopoverAnimations };
//# sourceMappingURL=ngx-tethys-popover.js.map
