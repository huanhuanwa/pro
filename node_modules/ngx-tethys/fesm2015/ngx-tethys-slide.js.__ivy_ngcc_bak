import { InjectionToken, ElementRef, Component, Inject, ChangeDetectorRef, Renderer2, ViewChild, Injectable, Injector, Optional, ViewEncapsulation, HostBinding, Input, ContentChild, Directive, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { ThySharedModule } from 'ngx-tethys/shared';
import { ThyAbstractOverlayConfig, ThyAbstractOverlayContainer, ThyAbstractOverlayRef, ThyAbstractInternalOverlayRef, ThyAbstractOverlayService } from 'ngx-tethys/core';
import { helpers, coerceArray, coerceBooleanProperty } from 'ngx-tethys/util';
import { Subject, of } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
import { coerceElement } from '@angular/cdk/coercion';
import { ViewportRuler, OverlayRef, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { CdkPortalOutlet, ComponentPortal, PortalModule } from '@angular/cdk/portal';
import { filter, startWith, takeUntil } from 'rxjs/operators';
import { transition, style, animate, state, trigger } from '@angular/animations';
import { ThyIconModule } from 'ngx-tethys/icon';

class ThySlideConfig extends ThyAbstractOverlayConfig {
}
class ThySlideOption extends ThySlideConfig {
}
const THY_SLIDE_DEFAULT_CONFIG = new InjectionToken('thy-slide-default-options');
const slideUpperOverlayOptions = {
    name: 'slide',
    animationEnabled: true,
    disposeWhenClose: true
};
const slideDefaultConfigValue = {
    hasBackdrop: true,
    backdropClass: 'thy-slide-backdrop',
    backdropClosable: true,
    closeOnNavigation: true,
    autoFocus: true,
    restoreFocus: true,
    from: 'right',
    panelClass: 'thy-slide',
    containerClass: '',
    role: 'slide',
    offset: 0,
    originActiveClass: 'thy-slide-origin-active',
    mode: 'over',
    drawerContainer: ''
};
const ɵ0 = {};
const THY_SLIDE_DEFAULT_CONFIG_PROVIDER = {
    provide: THY_SLIDE_DEFAULT_CONFIG,
    useValue: ɵ0
};

const animationBody = [
    transition('void => offsetLeft', [style({ width: 0 }), animate('0.2s ease-in')]),
    transition('offsetLeft => exit', [animate('0.2s', style({ width: 0 }))]),
    transition('void => offsetRight', [style({ width: 0 }), animate('0.2s ease')]),
    transition('offsetRight => exit', [animate('0.2s', style({ width: 0 }))]),
    transition('void => offsetTop', [style({ height: 0 }), animate('0.2s ease-in')]),
    transition('offsetTop => exit', [animate('0.2s', style({ height: 0 }))]),
    transition('void => offsetBottom', [style({ height: 0 }), animate('0.2s ease-in')]),
    transition('offsetBottom => exit', [animate('0.2s', style({ height: 0 }))]),
    state('left right top bottom', style({ transform: '*' })),
    transition('void => left', [style({ transform: 'translateX(-100%)' }), animate('0.2s ease-in')]),
    transition('left => exit', [animate('0.2s', style({ transform: 'translateX(-100%)' }))]),
    transition('void => right', [style({ transform: 'translateX(100%)' }), animate('0.2s ease-in')]),
    transition('right => exit', [animate('0.2s', style({ transform: 'translateX(100%)' }))]),
    transition('void => top', [style({ transform: 'translateY(-100%)' }), animate('0.2s ease-in')]),
    transition('top => exit', [animate('0.2s', style({ transform: 'translateY(-100%)' }))]),
    transition('void => bottom', [style({ transform: 'translateY(100%)' }), animate('0.2s ease-in')]),
    transition('bottom => exit', [animate('0.2s', style({ transform: 'translateY(100%)' }))])
];
const thySlideAnimations = {
    slideContainer: trigger('slideContainer', animationBody)
};

class ThySlideContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, renderer, viewportRuler) {
        super(slideUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.renderer = renderer;
        this.viewportRuler = viewportRuler;
        this.animationState = 'void';
        this.slideContainerStyles = {};
        this.ngUnsubscribe$ = new Subject();
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === this.animationState;
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
        this.setDrawerContainerElement();
        this.checkContainerWithinViewport();
        this.addDrawerContainerElementClass();
    }
    get isPush() {
        return this.config.mode === 'push' && !!this.drawerContainerElement;
    }
    get isSide() {
        return this.config.mode === 'side' && !!this.drawerContainerElement;
    }
    get isLeftOrRight() {
        return this.config.from === 'left' || this.config.from === 'right';
    }
    get hostOffset() {
        let offset = 0;
        if (this.isLeftOrRight) {
            offset = this.elementRef.nativeElement.clientWidth + this.config.offset || 0;
        }
        else {
            offset = this.elementRef.nativeElement.clientHeight + this.config.offset || 0;
        }
        return offset;
    }
    get transform() {
        switch (this.config.from) {
            case 'left':
                return `translateX(${this.hostOffset}px)`;
            case 'right':
                return `translateX(-${this.hostOffset}px)`;
            case 'top':
                return `translateY(${this.hostOffset}px)`;
            case 'bottom':
                return `translateY(${this.hostOffset}px)`;
        }
    }
    get drawerContainerElementClass() {
        return `thy-slide-${this.config.mode}-drawer-container`;
    }
    setDrawerContainerElement() {
        if (typeof this.config.drawerContainer === 'string') {
            this.drawerContainerElement = this.config.drawerContainer && document.querySelector(this.config.drawerContainer);
        }
        if (this.config.drawerContainer instanceof ElementRef) {
            this.drawerContainerElement = this.config.drawerContainer.nativeElement;
        }
        if (this.config.drawerContainer instanceof HTMLElement) {
            this.drawerContainerElement = this.config.drawerContainer;
        }
    }
    setSlideContainerStyles() {
        let width, height, top, left;
        const drawerContainerElementRect = (this.drawerContainerElement || document.body).getBoundingClientRect();
        if (this.isLeftOrRight) {
            height = drawerContainerElementRect.height;
            top = drawerContainerElementRect.top;
            this.renderer.setStyle(this.elementRef.nativeElement, 'top', `${top}px`);
        }
        else {
            width = drawerContainerElementRect.width;
            left = drawerContainerElementRect.left;
            this.renderer.setStyle(this.elementRef.nativeElement, 'left', `${left}px`);
        }
        this.slideContainerStyles = {
            width: width,
            height: height
        };
    }
    checkContainerWithinViewport() {
        this.viewportRuler
            .change(100)
            .pipe(startWith(null), takeUntil(this.ngUnsubscribe$))
            .subscribe(() => {
            this.setSlideContainerStyles();
        });
    }
    addDrawerContainerElementClass() {
        if (this.drawerContainerElement) {
            this.renderer.addClass(this.drawerContainerElement, this.drawerContainerElementClass);
        }
    }
    removeDrawerContainerElementClass() {
        if (this.drawerContainerElement) {
            this.renderer.removeClass(this.drawerContainerElement, this.drawerContainerElementClass);
        }
    }
    setDrawerContainerElementStyle() {
        if (this.isSide) {
            this.renderer.setStyle(this.drawerContainerElement, `margin-${this.config.from}`, `${this.hostOffset}px`);
        }
        else if (this.isPush) {
            this.renderer.setStyle(this.drawerContainerElement, `transform`, this.transform);
        }
    }
    removeDrawerContainerElementStyle() {
        if (this.isSide) {
            this.renderer.removeStyle(this.drawerContainerElement, `margin-${this.config.from}`);
        }
        else if (this.isPush) {
            this.renderer.removeStyle(this.drawerContainerElement, `transform`);
        }
    }
    beforeAttachPortal() {
        if (this.config.offset) {
            this.renderer.setStyle(this.elementRef.nativeElement, this.config.from, `${this.config.offset}px`);
            this.animationState = helpers.camelCase(['offset', this.config.from]);
        }
        else {
            this.animationState = this.config.from;
        }
        this.setDrawerContainerElementStyle();
    }
    beforeDetachPortal() {
        this.removeDrawerContainerElementStyle();
    }
    onAnimationDone(event) {
        this.animationStateChanged.emit(event);
    }
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    ngOnDestroy() {
        super.destroy();
        this.removeDrawerContainerElementClass();
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
}
ThySlideContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slide-container',
                template: `
        <ng-template cdkPortalOutlet></ng-template>
    `,
                animations: [thySlideAnimations.slideContainer],
                host: {
                    class: 'thy-slide-container',
                    '[class.thy-slide-push]': 'isPush',
                    '[class.thy-slide-side]': 'isSide',
                    '[class.thy-slide-over]': '!isPush && !isSide',
                    tabindex: '-1',
                    '[attr.role]': `'slide'`,
                    '[@slideContainer]': 'animationState',
                    '(@slideContainer.start)': 'onAnimationStart($event)',
                    '(@slideContainer.done)': 'onAnimationDone($event)',
                    '[style.width.px]': 'slideContainerStyles.width',
                    '[style.height.px]': 'slideContainerStyles.height',
                    '[style.max-height.px]': 'slideContainerStyles.height'
                }
            },] }
];
ThySlideContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThySlideConfig },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ViewportRuler }
];
ThySlideContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
};

class ThySlideRef extends ThyAbstractOverlayRef {
}
class ThyInternalSlideRef extends ThyAbstractInternalOverlayRef {
    constructor(overlayRef, containerInstance, config) {
        super(slideUpperOverlayOptions, overlayRef, containerInstance, config);
    }
    updatePosition(position) {
        return this.updateGlobalPosition(position);
    }
}
ThyInternalSlideRef.decorators = [
    { type: Injectable }
];
ThyInternalSlideRef.ctorParameters = () => [
    { type: OverlayRef },
    { type: ThySlideContainerComponent },
    { type: ThySlideConfig }
];

class ThySlideService extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig) {
        const slideDefaultConfig = Object.assign({}, slideDefaultConfigValue, defaultConfig);
        super(slideUpperOverlayOptions, overlay, injector, slideDefaultConfig);
    }
    originElementAddActiveClass(config) {
        if (config.origin) {
            coerceElement(config.origin).classList.add(...coerceArray(config.originActiveClass));
        }
    }
    originElementRemoveActiveClass(config) {
        if (config.origin) {
            coerceElement(config.origin).classList.remove(...coerceArray(config.originActiveClass));
        }
    }
    buildOverlayConfig(config) {
        const defaultClasses = ['thy-slide-overlay-pane', `thy-slide-${config.from}`];
        const overlayConfig = Object.assign(Object.assign({}, this.buildBaseOverlayConfig(config, defaultClasses)), { width: config.width });
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThySlideConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThySlideContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalSlideRef(overlayRef, containerInstance, config);
    }
    createInjector(config, overlayRef, containerInstance) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            { provide: ThySlideContainerComponent, useValue: containerInstance },
            { provide: ThySlideRef, useValue: overlayRef }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    overlayIsOpened(config) {
        const openedOverlay = this.getUpperOverlayById(config.id);
        this.close(openedOverlay);
        return openedOverlay;
    }
    open(componentOrTemplateRef, config) {
        if (this.overlayIsOpened(config)) {
            return;
        }
        const slideRef = this.openUpperOverlay(componentOrTemplateRef, config);
        this.originElementAddActiveClass(slideRef.containerInstance.config);
        slideRef.afterClosed().subscribe(() => {
            this.originElementRemoveActiveClass(slideRef.containerInstance.config);
        });
        return slideRef;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThySlideService.decorators = [
    { type: Injectable }
];
ThySlideService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThySlideConfig, decorators: [{ type: Optional }, { type: Inject, args: [THY_SLIDE_DEFAULT_CONFIG,] }] }
];

class ThySlideLayoutComponent {
    constructor() {
        this.slideLayout = true;
    }
    ngOnInit() { }
}
ThySlideLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slide-layout',
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None
            },] }
];
ThySlideLayoutComponent.ctorParameters = () => [];
ThySlideLayoutComponent.propDecorators = {
    slideLayout: [{ type: HostBinding, args: ['class.thy-slide-layout',] }]
};

class ThySlideHeaderComponent {
    constructor(thySlideService) {
        this.thySlideService = thySlideService;
        this.isIconFont = false;
        this._iconName = '';
        this.slideLayoutHeader = true;
    }
    set thyIcon(value) {
        this._iconName = value;
        if (value.includes('wtf')) {
            this.isIconFont = true;
        }
        else {
            this.isIconFont = false;
        }
    }
    get thyIcon() {
        return this._iconName;
    }
    ngOnInit() { }
    closeModal(event) {
        event.stopPropagation();
        this.thySlideService.close();
    }
}
ThySlideHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slide-header',
                template: "<ng-container>\n  <ng-template *ngIf=\"headerTemplate; else default\" [ngTemplateOutlet]=\"headerTemplate\"></ng-template>\n  <ng-template #default>\n    <h3 class=\"thy-slide-header-title\">\n      <thy-icon *ngIf=\"!isIconFont && thyIcon; else iconFont\" [thyIconName]=\"thyIcon\"></thy-icon>\n      <ng-template #iconFont>\n        <i *ngIf=\"thyIcon\" class=\"wft {{ thyIcon }}\"></i>\n      </ng-template>\n      {{ thyTitle }}\n    </h3>\n\n    <div class=\"thy-slide-header-main\">\n      <ng-container>\n        <ng-template *ngIf=\"headerOperateTemplate\" [ngTemplateOutlet]=\"headerOperateTemplate\"> </ng-template>\n      </ng-container>\n    </div>\n    <button type=\"button\" class=\"close\" (click)=\"closeModal($event)\">\n      <thy-icon thyIconName=\"close\"></thy-icon>\n    </button>\n  </ng-template>\n</ng-container>\n"
            },] }
];
ThySlideHeaderComponent.ctorParameters = () => [
    { type: ThySlideService }
];
ThySlideHeaderComponent.propDecorators = {
    slideLayoutHeader: [{ type: HostBinding, args: ['class.thy-slide-header',] }],
    thyTitle: [{ type: Input }],
    thyIcon: [{ type: Input }],
    headerTemplate: [{ type: ContentChild, args: ['thyHeader',] }],
    headerOperateTemplate: [{ type: ContentChild, args: ['thyHeaderOperate',] }]
};

class ThySlideBodyComponent {
    constructor() {
        this.slideLayoutBody = true;
    }
    ngOnInit() { }
}
ThySlideBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slide-body',
                template: `
        <ng-content></ng-content>
    `
            },] }
];
ThySlideBodyComponent.propDecorators = {
    slideLayoutBody: [{ type: HostBinding, args: ['class.thy-slide-body',] }]
};

class ThySlideBodySectionComponent {
    constructor() {
        this.thySlideBodyItem = true;
        this.hasDivider = false;
    }
    set thyDividerBorder(value) {
        this.hasDivider = coerceBooleanProperty(value);
    }
    ngOnInit() { }
}
ThySlideBodySectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slide-body-section',
                template: '<ng-content></ng-content>'
            },] }
];
ThySlideBodySectionComponent.propDecorators = {
    thySlideBodyItem: [{ type: HostBinding, args: ['class.thy-slide-body-section',] }],
    hasDivider: [{ type: HostBinding, args: ['class.thy-slide-body-section-divider',] }],
    thyDividerBorder: [{ type: Input }]
};

class ThySlideFooterComponent {
    constructor() {
        this.slideLayoutFooter = true;
    }
    ngOnInit() { }
}
ThySlideFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-slide-footer',
                template: '<ng-content></ng-content>'
            },] }
];
ThySlideFooterComponent.propDecorators = {
    slideLayoutFooter: [{ type: HostBinding, args: ['class.thy-slide-footer',] }]
};

class ThyDrawerContainerDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
ThyDrawerContainerDirective.decorators = [
    { type: Directive, args: [{ selector: '[thyDrawerContainer]' },] }
];
ThyDrawerContainerDirective.ctorParameters = () => [
    { type: ElementRef }
];

class ThySlideModule {
}
ThySlideModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ThySlideContainerComponent,
                    ThySlideLayoutComponent,
                    ThySlideHeaderComponent,
                    ThySlideBodyComponent,
                    ThySlideBodySectionComponent,
                    ThySlideFooterComponent,
                    ThyDrawerContainerDirective
                ],
                entryComponents: [ThySlideContainerComponent],
                imports: [CommonModule, ThySharedModule, ThyIconModule, OverlayModule, PortalModule],
                exports: [
                    ThySlideLayoutComponent,
                    ThySlideHeaderComponent,
                    ThySlideBodyComponent,
                    ThySlideBodySectionComponent,
                    ThySlideFooterComponent,
                    ThyDrawerContainerDirective
                ],
                providers: [ThyInternalSlideRef, ThySlideService, THY_SLIDE_DEFAULT_CONFIG_PROVIDER]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { THY_SLIDE_DEFAULT_CONFIG, THY_SLIDE_DEFAULT_CONFIG_PROVIDER, ThyDrawerContainerDirective, ThyInternalSlideRef, ThySlideBodyComponent, ThySlideBodySectionComponent, ThySlideConfig, ThySlideContainerComponent, ThySlideFooterComponent, ThySlideHeaderComponent, ThySlideLayoutComponent, ThySlideModule, ThySlideOption, ThySlideRef, ThySlideService, slideDefaultConfigValue, slideUpperOverlayOptions, thySlideAnimations, ɵ0 };
//# sourceMappingURL=ngx-tethys-slide.js.map
