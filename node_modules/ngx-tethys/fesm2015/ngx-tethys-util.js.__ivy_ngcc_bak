import * as dateFns from 'date-fns';
import { isDevMode, TemplateRef, ElementRef } from '@angular/core';
import { _isNumberValue, coerceCssPixelValue as coerceCssPixelValue$1 } from '@angular/cdk/coercion';
import * as keycodes$1 from '@angular/cdk/keycodes';
export * from '@angular/cdk/keycodes';

const differenceInCalendarDays = dateFns.differenceInCalendarDays;
const differenceInCalendarMonths = dateFns.differenceInCalendarMonths;
const differenceInCalendarYears = dateFns.differenceInCalendarYears;
const differenceInWeeks = dateFns.differenceInWeeks;
const differenceInHours = dateFns.differenceInHours;
const differenceInMinutes = dateFns.differenceInMinutes;
const differenceInSeconds = dateFns.differenceInSeconds;
const isSameDay = dateFns.isSameDay;
const isSameHour = dateFns.isSameHour;
const isSameMinute = dateFns.isSameMinute;
const isSameMonth = dateFns.isSameMonth;
const isSameSecond = dateFns.isSameSecond;
const isSameYear = dateFns.isSameYear;
const isToday = dateFns.isToday;
const isTomorrow = dateFns.isTomorrow;
const isValid = dateFns.isValid;
const setYear = dateFns.setYear;
const startOfMonth = dateFns.startOfMonth;
const startOfWeek = dateFns.startOfWeek;
const addMonths = dateFns.addMonths;
const addYears = dateFns.addYears;
const setDay = dateFns.setDay;
const setMonth = dateFns.setMonth;
const getUnixTime = dateFns.getUnixTime;
const startOfDay = dateFns.startOfDay;
const endOfDay = dateFns.endOfDay;
const fromUnixTime = dateFns.fromUnixTime;
const isWeekend = dateFns.isWeekend;
const getWeek = dateFns.getWeek;
const getDaysInMonth = dateFns.getDaysInMonth;
const addSeconds = dateFns.addSeconds;
const addMinutes = dateFns.addMinutes;
const addHours = dateFns.addHours;
const addWeeks = dateFns.addWeeks;
const addQuarters = dateFns.addQuarters;
const startOfQuarter = dateFns.startOfQuarter;
const startOfYear = dateFns.startOfYear;
const endOfWeek = dateFns.endOfWeek;
const endOfMonth = dateFns.endOfMonth;
const endOfQuarter = dateFns.endOfQuarter;
const endOfYear = dateFns.endOfYear;
const format = dateFns.format;
const getQuarter = dateFns.getQuarter;
const addDays = dateFns.addDays;

function sortRangeValue(rangeValue) {
    if (Array.isArray(rangeValue)) {
        const [start, end] = rangeValue;
        return start && end && start.isAfterSecond(end) ? [end, start] : [start, end];
    }
    return rangeValue;
}
class TinyDate {
    constructor(date) {
        if (date) {
            if (date instanceof Date) {
                this.nativeDate = date;
            }
            else if (typeof date === 'string' || typeof date === 'number') {
                this.nativeDate = new Date(date);
            }
            else {
                throw new Error(`The input date type is not supported expect Date | string | number | { date: number; with_time: 0 | 1}, actual ${JSON.stringify(date)}`);
            }
        }
        else {
            this.nativeDate = new Date();
        }
    }
    static fromUnixTime(unixTime) {
        return new TinyDate(fromUnixTime(unixTime));
    }
    // get
    getTime() {
        return this.nativeDate.getTime();
    }
    getDate() {
        return this.nativeDate.getDate();
    }
    getYear() {
        return this.nativeDate.getFullYear();
    }
    getQuarter() {
        return getQuarter(this.nativeDate);
    }
    getMonth() {
        return this.nativeDate.getMonth();
    }
    getWeek(options = { weekStartsOn: 1 }) {
        return getWeek(this.nativeDate, options);
    }
    getDay() {
        return this.nativeDate.getDay();
    }
    getHours() {
        return this.nativeDate.getHours();
    }
    getMinutes() {
        return this.nativeDate.getMinutes();
    }
    getSeconds() {
        return this.nativeDate.getSeconds();
    }
    getMilliseconds() {
        return this.nativeDate.getMilliseconds();
    }
    getDaysInMonth() {
        return getDaysInMonth(this.nativeDate);
    }
    getDaysInQuarter() {
        return differenceInCalendarDays(this.endOfQuarter().addSeconds(1).nativeDate, this.startOfQuarter().nativeDate);
    }
    // set
    setDate(amount) {
        const date = new Date(this.nativeDate);
        date.setDate(amount);
        return new TinyDate(date);
    }
    setHms(hour, minute, second) {
        const date = new Date(this.nativeDate);
        date.setHours(hour, minute, second);
        return new TinyDate(date);
    }
    setYear(year) {
        return new TinyDate(setYear(this.nativeDate, year));
    }
    setMonth(month) {
        return new TinyDate(setMonth(this.nativeDate, month));
    }
    setDay(day, options) {
        return new TinyDate(setDay(this.nativeDate, day, options));
    }
    // add
    addYears(amount) {
        return new TinyDate(addYears(this.nativeDate, amount));
    }
    addQuarters(amount) {
        return new TinyDate(addQuarters(this.nativeDate, amount));
    }
    addMonths(amount) {
        return new TinyDate(addMonths(this.nativeDate, amount));
    }
    addWeeks(amount) {
        return new TinyDate(addWeeks(this.nativeDate, amount));
    }
    addDays(amount) {
        return new TinyDate(addDays(this.nativeDate, amount));
    }
    addHours(amount) {
        return new TinyDate(addHours(this.nativeDate, amount));
    }
    addSeconds(amount) {
        return new TinyDate(addSeconds(this.nativeDate, amount));
    }
    addMinutes(amount) {
        return new TinyDate(addMinutes(this.nativeDate, amount));
    }
    // isSame
    isSame(date, grain = 'day') {
        let fn;
        switch (grain) {
            case 'year':
                fn = isSameYear;
                break;
            case 'month':
                fn = isSameMonth;
                break;
            case 'day':
                fn = isSameDay;
                break;
            case 'hour':
                fn = isSameHour;
                break;
            case 'minute':
                fn = isSameMinute;
                break;
            case 'second':
                fn = isSameSecond;
                break;
            default:
                fn = isSameDay;
                break;
        }
        return fn(this.nativeDate, this.toNativeDate(date));
    }
    isSameYear(date) {
        return this.isSame(date, 'year');
    }
    isSameMonth(date) {
        return this.isSame(date, 'month');
    }
    isSameDay(date) {
        return this.isSame(date, 'day');
    }
    isSameHour(date) {
        return this.isSame(date, 'hour');
    }
    isSameMinute(date) {
        return this.isSame(date, 'minute');
    }
    isSameSecond(date) {
        return this.isSame(date, 'second');
    }
    // isBefore and isAfter
    isBeforeYear(date) {
        return this.compare(date, 'year');
    }
    isBeforeMonth(date) {
        return this.compare(date, 'month');
    }
    isBeforeWeek(date) {
        return this.compare(date, 'week');
    }
    isBeforeDay(date) {
        return this.compare(date, 'day');
    }
    isBeforeHour(date) {
        return this.compare(date, 'hour');
    }
    isBeforeMinute(date) {
        return this.compare(date, 'minute');
    }
    isBeforeSecond(date) {
        return this.compare(date, 'second');
    }
    isAfterYear(date) {
        return this.compare(date, 'year', false);
    }
    isAfterMonth(date) {
        return this.compare(date, 'month', false);
    }
    isAfterWeek(date) {
        return this.compare(date, 'week', false);
    }
    isAfterDay(date) {
        return this.compare(date, 'day', false);
    }
    isAfterHour(date) {
        return this.compare(date, 'hour', false);
    }
    isAfterMinute(date) {
        return this.compare(date, 'minute', false);
    }
    isAfterSecond(date) {
        return this.compare(date, 'second', false);
    }
    // is
    isWeekend() {
        return isWeekend(this.nativeDate);
    }
    isToday() {
        return isToday(this.nativeDate);
    }
    isTomorrow() {
        return isTomorrow(this.nativeDate);
    }
    isValid() {
        return isValid(this.nativeDate);
    }
    // startOf and endOf
    startOfYear() {
        return new TinyDate(startOfYear(this.nativeDate));
    }
    startOfQuarter() {
        return new TinyDate(startOfQuarter(this.nativeDate));
    }
    startOfMonth() {
        return new TinyDate(startOfMonth(this.nativeDate));
    }
    startOfWeek(options) {
        return new TinyDate(startOfWeek(this.nativeDate, options));
    }
    startOfDay() {
        return new TinyDate(startOfDay(this.nativeDate));
    }
    endOfYear() {
        return new TinyDate(endOfYear(this.nativeDate));
    }
    endOfQuarter() {
        return new TinyDate(endOfQuarter(this.nativeDate));
    }
    endOfMonth() {
        return new TinyDate(endOfMonth(this.nativeDate));
    }
    endOfWeek(options) {
        return new TinyDate(endOfWeek(this.nativeDate, options));
    }
    endOfDay() {
        return new TinyDate(endOfDay(this.nativeDate));
    }
    // other
    format(mat, options) {
        return format(this.nativeDate, mat, options);
    }
    calendarStart(options) {
        return new TinyDate(startOfWeek(startOfMonth(this.nativeDate), options));
    }
    clone() {
        return new TinyDate(new Date(this.nativeDate));
    }
    getUnixTime() {
        return getUnixTime(this.nativeDate);
    }
    compare(date, grain = 'day', isBefore = true) {
        if (date === null) {
            return false;
        }
        let fn;
        switch (grain) {
            case 'year':
                fn = differenceInCalendarYears;
                break;
            case 'month':
                fn = differenceInCalendarMonths;
                break;
            case 'day':
                fn = differenceInCalendarDays;
                break;
            case 'week':
                fn = differenceInWeeks;
                break;
            case 'hour':
                fn = differenceInHours;
                break;
            case 'minute':
                fn = differenceInMinutes;
                break;
            case 'second':
                fn = differenceInSeconds;
                break;
            default:
                fn = differenceInCalendarDays;
                break;
        }
        return isBefore ? fn(this.nativeDate, this.toNativeDate(date)) < 0 : fn(this.nativeDate, this.toNativeDate(date)) > 0;
    }
    toNativeDate(date) {
        return date instanceof TinyDate ? date.nativeDate : date;
    }
}

const record = {};
const PREFIX = '[NGX-TETHYS]:';
function notRecorded(...args) {
    const asRecord = args.reduce((acc, c) => acc + c.toString(), '');
    if (record[asRecord]) {
        return false;
    }
    else {
        record[asRecord] = true;
        return true;
    }
}
function consoleCommonBehavior(consoleFunc, ...args) {
    if (isDevMode() && notRecorded(...args)) {
        consoleFunc(...args);
    }
}
// Warning should only be printed in dev mode and only once.
const warn = (...args) => consoleCommonBehavior((...arg) => console.warn(PREFIX, ...arg), ...args);
function createWarnDeprecation(prefix) {
    return (...args) => {
        const stack = new Error().stack;
        return consoleCommonBehavior((...arg) => {
            console.warn(prefix, 'deprecated:', ...arg, stack);
        }, ...args);
    };
}
const warnDeprecation = createWarnDeprecation(PREFIX);
// Log should only be printed in dev mode.
const log = (...args) => {
    if (isDevMode()) {
        console.log(PREFIX, ...args);
    }
};

function inputValueToBoolean(value) {
    warnDeprecation(`The method inputValueToBoolean will be deprecated, please use coerceBooleanProperty instead.`);
    return value === '' || (value && value !== 'false');
}
function isUndefined(value) {
    return value === undefined;
}
function isNull(value) {
    return value === null;
}
function isUndefinedOrNull(value) {
    return isUndefined(value) || isNull(value);
}
function isArray(value) {
    return value && baseGetTag(value) === '[object Array]';
}
function isEmpty(value) {
    return !(isArray(value) && value.length > 0);
}
function isString(value) {
    return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && baseGetTag(value) === '[object String]');
}
function isObjectLike(value) {
    return value !== null && typeof value === 'object';
}
function baseGetTag(value) {
    const objectProto = Object.prototype;
    const hasOwnProperty = objectProto.hasOwnProperty;
    const toString = objectProto.toString;
    const symToStringTag = typeof Symbol !== 'undefined' ? Symbol.toStringTag : undefined;
    if (value == null) {
        return value === undefined ? '[object Undefined]' : '[object Null]';
    }
    if (!(symToStringTag && symToStringTag in Object(value))) {
        return toString.call(value);
    }
    const isOwn = hasOwnProperty.call(value, symToStringTag);
    const tag = value[symToStringTag];
    let unmasked = false;
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) { }
    const result = toString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        }
        else {
            delete value[symToStringTag];
        }
    }
    return result;
}
function isNumber(value) {
    return typeof value === 'number' || (isObjectLike(value) && baseGetTag(value) === '[object Number]');
}
function isObject(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    const type = typeof value;
    return !!value && (type === 'object' || type === 'function');
}
function isFunction(value) {
    const type = typeof value;
    return !!value && type === 'function';
}
function isDate(value) {
    const type = typeof value;
    return !!value && type === 'object' && !!value.getTime;
}
function coerceArray(value) {
    return Array.isArray(value) ? value : [value];
}
function get(object, path, defaultValue) {
    const paths = path.split('.');
    let result = object[paths.shift()];
    while (result && paths.length) {
        result = result[paths.shift()];
    }
    return result === undefined ? defaultValue : result;
}
function set(object, path, value) {
    if (object == null) {
        return object;
    }
    const paths = path.split('.');
    let index = -1;
    const length = paths.length;
    const lastIndex = length - 1;
    let nested = object;
    while (nested !== null && ++index < length) {
        const key = paths[index];
        if (isObject(nested)) {
            if (index === lastIndex) {
                nested[key] = value;
                nested = nested[key];
                break;
            }
            else {
                if (nested[key] == null) {
                    nested[key] = {};
                }
            }
        }
        nested = nested[key];
    }
    return object;
}
function isBoolean(value) {
    return value === true || value === false || (isObjectLike(value) && baseGetTag(value) === '[object Boolean]');
}
function fromArray(value) {
    if (Array.from && isFunction(Array.from)) {
        return Array.from(value);
    }
    else {
        return Array.prototype.slice.call(value);
    }
}
function htmlElementIsEmpty(element) {
    if (element && element.childNodes) {
        const nodes = element.childNodes;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.nodeType === Node.ELEMENT_NODE && node.outerHTML.toString().trim().length !== 0) {
                return false;
            }
            else if (node.nodeType === Node.TEXT_NODE && node.textContent.toString().trim().length !== 0) {
                return false;
            }
            else if (node.nodeType !== Node.COMMENT_NODE) {
                return false;
            }
        }
    }
    return true;
}
function hexToRgb(hexValue, alpha) {
    const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    const hex = hexValue.replace(rgx, (m, r, g, b) => r + r + g + g + b + b);
    const rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    const resultR = parseInt(rgb[1], 16);
    const resultG = parseInt(rgb[2], 16);
    const resultB = parseInt(rgb[3], 16);
    if (alpha) {
        return `rgba(${resultR}, ${resultG}, ${resultB}, ${alpha})`;
    }
    else {
        return `rgb(${resultR}, ${resultG}, ${resultB})`;
    }
}
function formatDate(date) {
    if (isNumber(date)) {
        if (date.toString().length === 10) {
            return date;
        }
        else {
            return parseInt((date / 1000).toFixed(0), 10);
        }
    }
    else {
        return parseInt((date.getTime() / 1000).toFixed(0), 10);
    }
}
function clamp(value, min = 0, max = 100) {
    return Math.max(min, Math.min(max, value));
}
function keyBy(array, key) {
    const result = {};
    array.forEach(item => {
        const keyValue = item[key];
        result[keyValue] = item;
    });
    return result;
}
function indexKeyBy(array, key) {
    const result = {};
    array.forEach((item, index) => {
        const keyValue = item[key];
        result[keyValue] = index;
    });
    return result;
}
function upperFirst(string) {
    return string.slice(0, 1).toUpperCase() + string.slice(1);
}
function camelCase(values) {
    if (isArray(values)) {
        return values.reduce((result, word, index) => {
            word = word.toLowerCase();
            return result + (index ? upperFirst(word) : word);
        }, '');
    }
    else {
        return;
    }
}
function generateRandomStr() {
    return Math.random()
        .toString(36)
        .substring(2);
}
function isTemplateRef(value) {
    return value instanceof TemplateRef;
}
function isHTMLElement(value) {
    return value instanceof HTMLElement;
}
function isElementRef(value) {
    return value instanceof ElementRef;
}
function coerceBooleanProperty(value) {
    if (value === '' || (value && value !== 'false')) {
        return true;
    }
    else {
        return false;
    }
}
function coerceNumberValue(value, fallbackValue = 0) {
    return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function coerceCssPixelValue(value) {
    return coerceCssPixelValue$1(value);
}
function valueFunctionProp(prop, ...args) {
    return typeof prop === 'function' ? prop(...args) : prop;
}
function shallowEqual(objA, objB) {
    if (objA === objB) {
        return true;
    }
    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {
        return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
        return false;
    }
    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    // tslint:disable-next-line:prefer-for-of
    for (let idx = 0; idx < keysA.length; idx++) {
        const key = keysA[idx];
        if (!bHasOwnProperty(key)) {
            return false;
        }
        if (objA[key] !== objB[key]) {
            return false;
        }
    }
    return true;
}
function concatArray(items, originalItems = []) {
    let _originalItems = [];
    if (!originalItems) {
        _originalItems = [];
    }
    else {
        _originalItems = coerceArray(originalItems);
    }
    if (items) {
        if (isArray(items)) {
            return [..._originalItems, ...items];
        }
        else {
            return [..._originalItems, items];
        }
    }
    else {
        return _originalItems;
    }
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    inputValueToBoolean: inputValueToBoolean,
    isUndefined: isUndefined,
    isNull: isNull,
    isUndefinedOrNull: isUndefinedOrNull,
    isArray: isArray,
    isEmpty: isEmpty,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isFunction: isFunction,
    isDate: isDate,
    coerceArray: coerceArray,
    get: get,
    set: set,
    isBoolean: isBoolean,
    fromArray: fromArray,
    htmlElementIsEmpty: htmlElementIsEmpty,
    hexToRgb: hexToRgb,
    formatDate: formatDate,
    clamp: clamp,
    keyBy: keyBy,
    indexKeyBy: indexKeyBy,
    camelCase: camelCase,
    generateRandomStr: generateRandomStr,
    isTemplateRef: isTemplateRef,
    isHTMLElement: isHTMLElement,
    isElementRef: isElementRef,
    coerceBooleanProperty: coerceBooleanProperty,
    coerceNumberValue: coerceNumberValue,
    coerceCssPixelValue: coerceCssPixelValue,
    valueFunctionProp: valueFunctionProp,
    shallowEqual: shallowEqual,
    concatArray: concatArray
});

const proto = Element.prototype;
const vendor = proto.matches ||
    proto.matchesSelector ||
    proto.webkitMatchesSelector ||
    proto.mozMatchesSelector ||
    proto.msMatchesSelector ||
    proto.oMatchesSelector;
/**
 * Match `el` to `selector`.
 */
function match(el, selector) {
    if (vendor) {
        return vendor.call(el, selector);
    }
    const nodes = el.parentNode.querySelectorAll(selector);
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i] === el) {
            return true;
        }
    }
    return false;
}
function isDocument(element) {
    return ((typeof HTMLDocument !== 'undefined' && element instanceof HTMLDocument) ||
        (element.nodeType && element.nodeType === element.DOCUMENT_NODE));
}
function isElement(element) {
    return ((typeof HTMLElement !== 'undefined' && element instanceof HTMLElement) ||
        (element.nodeType && element.nodeType === element.ELEMENT_NODE));
}
function getWindow(elem) {
    return elem != null && elem === elem.window ? elem : elem.nodeType === 9 && elem.defaultView;
}
function getElementOffset(elem) {
    let docElem, win, rect, doc;
    if (!elem) {
        return;
    }
    // Support: IE<=11+
    // Running getBoundingClientRect on a
    // disconnected node in IE throws an error
    if (!elem.getClientRects().length) {
        return { top: 0, left: 0 };
    }
    rect = elem.getBoundingClientRect();
    // Make sure element is not hidden (display: none)
    if (rect.width || rect.height) {
        doc = elem.ownerDocument;
        win = getWindow(doc);
        docElem = doc.documentElement;
        return {
            top: rect.top + win.pageYOffset - docElem.clientTop,
            left: rect.left + win.pageXOffset - docElem.clientLeft,
            height: rect.height,
            width: rect.width
        };
    }
    return rect;
}
function getOffset(element, container) {
    if (!element || !element.getClientRects().length) {
        return null;
    }
    const rect = element.getBoundingClientRect();
    if (rect.width || rect.height) {
        if (container === window) {
            const documentElement = element.ownerDocument.documentElement;
            return {
                top: rect.top - documentElement.clientTop,
                left: rect.left - documentElement.clientLeft
            };
        }
        const containerRect = container.getBoundingClientRect();
        return {
            top: rect.top - containerRect.top,
            left: rect.left - containerRect.left
        };
    }
    return rect;
}
function getElementOuterHeight(element) {
    const _element = element.documentElement ? element.documentElement : element;
    let height = _element.clientHeight;
    const computedStyle = window.getComputedStyle(_element);
    height += parseInt(computedStyle.marginTop, 10);
    height += parseInt(computedStyle.marginBottom, 10);
    return height;
}
function getHTMLElementBySelector(selector, defaultElementRef) {
    if (!selector) {
        return defaultElementRef.nativeElement;
    }
    else if (selector === 'body') {
        return document.body;
    }
    else if (isString(selector)) {
        return document.querySelector(selector);
    }
    else if (selector instanceof ElementRef) {
        return selector.nativeElement;
    }
    else {
        return selector;
    }
}
function isInputOrTextarea(element) {
    return ['INPUT', 'TEXTAREA'].indexOf(element.nodeName) >= 0;
}
function isWindow(container) {
    return typeof window !== 'undefined' && container === window;
}
function getContainerRect(container) {
    return !isWindow(container)
        ? container.getBoundingClientRect()
        : {
            top: 0,
            left: 0,
            bottom: 0
        };
}
function getStyleAsText(styles) {
    if (!styles) {
        return '';
    }
    return Object.keys(styles)
        .map(key => {
        const val = styles[key];
        return `${key}:${typeof val === 'string' ? val : val + 'px'}`;
    })
        .join(';');
}
function isTouchEvent(event) {
    return event.type.startsWith('touch');
}

var dom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    match: match,
    isDocument: isDocument,
    isElement: isElement,
    getWindow: getWindow,
    getElementOffset: getElementOffset,
    getOffset: getOffset,
    getElementOuterHeight: getElementOuterHeight,
    getHTMLElementBySelector: getHTMLElementBySelector,
    isInputOrTextarea: isInputOrTextarea,
    isWindow: isWindow,
    getContainerRect: getContainerRect,
    getStyleAsText: getStyleAsText,
    isTouchEvent: isTouchEvent
});

class Producer {
    constructor(entities, options) {
        this.idKey = '_id';
        this.entities = entities || [];
        if (options && options.idKey) {
            this.idKey = options.idKey;
        }
    }
    /**
     * Add an entity or entities.
     *
     * @example
     * produce([users]).add(Entity);
     * produce([users]).add([Entity, Entity]);
     * produce([users]).add(Entity, { prepend: true });
     * produce([users]).add(Entity, { afterId: '' });
     */
    add(entity, addOptions) {
        const addEntities = coerceArray(entity);
        if (addEntities.length === 0) {
            return this.entities;
        }
        if (addOptions && (addOptions.afterId || addOptions.prepend)) {
            if (addOptions.afterId) {
                const entities = [...this.entities];
                const index = this.entities.findIndex(item => {
                    return item[this.idKey] === addOptions.afterId;
                }) + 1;
                entities.splice(index, 0, ...addEntities);
                this.entities = [...entities];
            }
            else if (addOptions.prepend) {
                this.entities = [...addEntities, ...this.entities];
            }
        }
        else {
            this.entities = [...this.entities, ...addEntities];
        }
        return this.entities;
    }
    update(idsOrFn, newStateOrFn) {
        const ids = coerceArray(idsOrFn);
        for (let i = 0; i < this.entities.length; i++) {
            const oldEntity = this.entities[i];
            if (ids.indexOf(oldEntity[this.idKey]) >= 0) {
                const newState = isFunction(newStateOrFn) ? newStateOrFn(oldEntity) : newStateOrFn;
                this.entities[i] = Object.assign(Object.assign({}, oldEntity), newState);
            }
        }
        return [...this.entities];
    }
    remove(idsOrFn) {
        if (isFunction(idsOrFn)) {
            this.entities = this.entities.filter(entity => {
                return !idsOrFn(entity);
            });
        }
        else {
            const ids = coerceArray(idsOrFn);
            this.entities = this.entities.filter(entity => {
                return ids.indexOf(entity[this.idKey]) === -1;
            });
        }
        return this.entities;
    }
    /**
     *
     * Move one or more entities:
     *
     * @example
     * produce([users]).move(5, {afterId: 2});
     * produce([users]).move(5, {toIndex: 0});
     */
    move(id, moveOptions) {
        const fromIndex = this.entities.findIndex(item => item[this.idKey] === id);
        let toIndex = 0;
        const newEntities = [...this.entities];
        if (!id || fromIndex < 0) {
            return [...this.entities];
        }
        if (moveOptions) {
            if (!isUndefinedOrNull(moveOptions.afterId)) {
                toIndex = this.entities.findIndex(item => item[this.idKey] === moveOptions.afterId);
            }
            else if (moveOptions.toIndex) {
                toIndex = moveOptions.toIndex;
            }
        }
        toIndex = Math.max(0, Math.min(this.entities.length - 1, toIndex));
        if (toIndex === fromIndex) {
            return [...this.entities];
        }
        else {
            const target = this.entities[fromIndex];
            const delta = toIndex < fromIndex ? -1 : 1;
            for (let i = fromIndex; i !== toIndex; i += delta) {
                newEntities[i] = newEntities[i + delta];
            }
            newEntities[toIndex] = target;
            return [...newEntities];
        }
    }
}
function produce(entities, options) {
    return new Producer(entities, options);
}

function getReferenceIdKey(referenceKey, idKeys) {
    if (idKeys && idKeys[referenceKey]) {
        return idKeys[referenceKey];
    }
    else {
        return '_id';
    }
}
/**
 * Append references to original references
 * @example
 * mergeReferences({departments: [{ _id: '1', name: 'name-1'}]}, {departments: [{ _id: '3', name: 'name-3'}]})
 * mergeReferences({users: [{ uid: '1', name: 'name-1'}]}, {users: [{ uid: '3', name: 'name-3'}]}, { users: "uid" })
 * @param originalReferences original references
 * @param references append references
 * @param idKeys references 's id key, default is '_id'
 *
 * @returns TReferences
 */
function mergeReferences(originalReferences, references, idKeys) {
    for (const key in references) {
        if (references.hasOwnProperty(key)) {
            const reference = references[key];
            const referenceIdKey = getReferenceIdKey(key, idKeys);
            const originalReference = originalReferences[key];
            if (!originalReference) {
                throw new Error(`original reference must exist when append new reference: ${key}`);
            }
            if (originalReference instanceof Array) {
                // original reference id index map
                const originalReferenceIdIndexMap = indexKeyBy(originalReferences[key], referenceIdKey);
                // append reference is array
                if (reference instanceof Array) {
                    reference.forEach((item) => {
                        const itemId = item[referenceIdKey];
                        const index = originalReferenceIdIndexMap[itemId];
                        if (index >= 0) {
                            originalReference[index] = Object.assign(Object.assign({}, originalReference[index]), item);
                        }
                        else {
                            originalReferences[key] = [...originalReferences[key], item];
                        }
                    });
                }
                else {
                    // append reference is not array, support append signal object to array reference
                    const itemId = reference[referenceIdKey];
                    const index = originalReferenceIdIndexMap[itemId];
                    if (itemId >= 0) {
                        originalReference[index] = Object.assign(Object.assign({}, originalReference[index]), reference);
                    }
                    else {
                        originalReferences[key] = [...originalReferences[key], reference];
                    }
                }
            }
            else {
                originalReferences[key] = Object.assign(Object.assign({}, originalReferences[key]), reference);
            }
        }
    }
    return originalReferences;
}
/**
 * Build dictionary for references
 * @param references references
 * @param idKeys references 's id key, default is '_id'
 */
function buildReferencesKeyBy(references, idKeys) {
    const result = {};
    for (const key in references) {
        if (references.hasOwnProperty(key)) {
            const referenceIdKey = getReferenceIdKey(key, idKeys);
            const reference = references[key];
            if (reference instanceof Array) {
                const originalReferenceIdMap = keyBy(reference, referenceIdKey);
                result[key] = originalReferenceIdMap;
            }
        }
    }
    return result;
}

var references = /*#__PURE__*/Object.freeze({
    __proto__: null,
    mergeReferences: mergeReferences,
    buildReferencesKeyBy: buildReferencesKeyBy
});

var keycodes = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), keycodes$1));

/**
 * Generated bundle index. Do not edit.
 */

export { PREFIX, Producer, TinyDate, addDays, addHours, addMinutes, addMonths, addQuarters, addSeconds, addWeeks, addYears, buildReferencesKeyBy, camelCase, clamp, coerceArray, coerceBooleanProperty, coerceCssPixelValue, coerceNumberValue, concatArray, createWarnDeprecation, differenceInCalendarDays, differenceInCalendarMonths, differenceInCalendarYears, differenceInHours, differenceInMinutes, differenceInSeconds, differenceInWeeks, dom, endOfDay, endOfMonth, endOfQuarter, endOfWeek, endOfYear, format, formatDate, fromArray, fromUnixTime, generateRandomStr, get, getContainerRect, getDaysInMonth, getElementOffset, getElementOuterHeight, getHTMLElementBySelector, getOffset, getQuarter, getStyleAsText, getUnixTime, getWeek, getWindow, index as helpers, hexToRgb, htmlElementIsEmpty, indexKeyBy, inputValueToBoolean, isArray, isBoolean, isDate, isDocument, isElement, isElementRef, isEmpty, isFunction, isHTMLElement, isInputOrTextarea, isNull, isNumber, isObject, isSameDay, isSameHour, isSameMinute, isSameMonth, isSameSecond, isSameYear, isString, isTemplateRef, isToday, isTomorrow, isTouchEvent, isUndefined, isUndefinedOrNull, isValid, isWeekend, isWindow, keyBy, keycodes, log, match, mergeReferences, produce, references, set, setDay, setMonth, setYear, shallowEqual, sortRangeValue, startOfDay, startOfMonth, startOfQuarter, startOfWeek, startOfYear, valueFunctionProp, warn, warnDeprecation };
//# sourceMappingURL=ngx-tethys-util.js.map
