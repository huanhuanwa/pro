import * as i0 from '@angular/core';
import { Component, HostBinding, InjectionToken, EventEmitter, ElementRef, Inject, ChangeDetectorRef, NgZone, ViewChild, HostListener, Injector, Injectable, Optional, Input, Output, Directive, ViewContainerRef, NgModule } from '@angular/core';
import { ThyAbstractOverlayConfig, ThyAbstractOverlayContainer, ThyClickDispatcher, ThyAbstractOverlayRef, ThyAbstractInternalOverlayRef, ThyAbstractOverlayService, getFlexiblePositions, ThyTranslate, ThyOverlayDirectiveBase } from 'ngx-tethys/core';
import { isFunction } from 'ngx-tethys/util';
import { timer, Subject, of } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';
import { coerceElement, coerceArray } from '@angular/cdk/coercion';
import * as i1 from '@angular/cdk/overlay';
import { Overlay, FlexibleConnectedPositionStrategy, ViewportRuler, OverlayContainer, OverlayModule } from '@angular/cdk/overlay';
import * as i5 from '@angular/cdk/platform';
import { Platform } from '@angular/cdk/platform';
import { CdkPortalOutlet, ComponentPortal, PortalModule } from '@angular/cdk/portal';
import * as i4 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { state, style, trigger } from '@angular/animations';
import * as i3 from '@angular/cdk/scrolling';
import { ThyIconModule } from 'ngx-tethys/icon';
import { FocusMonitor } from '@angular/cdk/a11y';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngx-tethys/core';
import * as ɵngcc2 from '@angular/cdk/portal';
import * as ɵngcc3 from '@angular/cdk/overlay';
import * as ɵngcc4 from '@angular/cdk/platform';
import * as ɵngcc5 from 'ngx-tethys/icon';
import * as ɵngcc6 from '@angular/cdk/a11y';

const _c0 = ["*"];
function ThyPopoverContainerComponent_ng_template_0_Template(rf, ctx) { }
class ThyPopoverBodyComponent {
    constructor() {
        this.isPopoverBody = true;
    }
}
ThyPopoverBodyComponent.ɵfac = function ThyPopoverBodyComponent_Factory(t) { return new (t || ThyPopoverBodyComponent)(); };
ThyPopoverBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyPopoverBodyComponent, selectors: [["thy-popover-body"]], hostVars: 2, hostBindings: function ThyPopoverBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-popover-body", ctx.isPopoverBody);
    } }, exportAs: ["thyPopoverBody"], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ThyPopoverBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
ThyPopoverBodyComponent.propDecorators = {
    isPopoverBody: [{ type: HostBinding, args: ['class.thy-popover-body',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyPopoverBodyComponent, [{
        type: Component,
        args: [{
                selector: 'thy-popover-body',
                template: '<ng-content></ng-content>',
                exportAs: 'thyPopoverBody'
            }]
    }], function () { return []; }, { isPopoverBody: [{
            type: HostBinding,
            args: ['class.thy-popover-body']
        }] }); })();

class ThyPopoverConfig extends ThyAbstractOverlayConfig {
}
const THY_POPOVER_DEFAULT_CONFIG = new InjectionToken('thy-popover-default-config');
const THY_POPOVER_DEFAULT_CONFIG_VALUE = {
    hasBackdrop: true,
    backdropClass: 'thy-popover-backdrop',
    panelClass: '',
    offset: 4,
    backdropClosable: true,
    closeOnNavigation: true,
    placement: 'bottom',
    insideClosable: false,
    manualClosure: false,
    originActiveClass: 'thy-popover-origin-active'
};
const THY_POPOVER_DEFAULT_CONFIG_PROVIDER = {
    provide: THY_POPOVER_DEFAULT_CONFIG,
    useValue: THY_POPOVER_DEFAULT_CONFIG_VALUE
};
const THY_POPOVER_SCROLL_STRATEGY = new InjectionToken('thy-popover-scroll-strategy');
const THY_POPOVER_SCROLL_STRATEGY_FACTORY = (overlay) => {
    return () => overlay.scrollStrategies.block();
};
const THY_POPOVER_SCROLL_STRATEGY_PROVIDER = {
    provide: THY_POPOVER_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: THY_POPOVER_SCROLL_STRATEGY_FACTORY
};

const animationBody = [
    // Note: The `enter` animation transitions to `transform: none`, because for some reason
    // specifying the transform explicitly, causes IE both to blur the dialog content and
    // decimate the animation performance. Leaving it as `none` solves both issues. translate(-300px,-100px)
    state('void, exit', style({ opacity: 0, transform: 'scale(0.1)' })),
    state('enter', style({ transform: 'none' }))
    // transition('* => enter', animate('100ms cubic-bezier(0, 0, 0.57, 1)', style({ transform: 'none', opacity: 1 }))),
    // transition(
    //     '* => exit',
    //     animate('150ms cubic-bezier(0.24, 0.18, 0.96, 0.52)', style({ transform: 'scale(0.3)', opacity: 0 }))
    // )
];
/**
 * Animations used by ThyPopover.
 * @docs-private
 */
const thyPopoverAnimations = {
    popoverContainer: trigger('popoverContainer', animationBody)
};
// export const setAnimationStart

const popoverUpperOverlayOptions = {
    name: 'popover',
    animationEnabled: true,
    disposeWhenClose: true
};

class ThyPopoverContainerComponent extends ThyAbstractOverlayContainer {
    constructor(elementRef, document, config, changeDetectorRef, thyClickDispatcher, ngZone) {
        super(popoverUpperOverlayOptions, changeDetectorRef);
        this.elementRef = elementRef;
        this.document = document;
        this.config = config;
        this.thyClickDispatcher = thyClickDispatcher;
        this.ngZone = ngZone;
        /** State of the popover animation. */
        this.animationState = 'enter';
        /** Emits when an animation state changes. */
        this.animationStateChanged = new EventEmitter();
        this.insideClicked = new EventEmitter();
        this.outsideClicked = new EventEmitter();
        this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'enter';
        }));
        this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
            return event.phaseName === 'done' && event.toState === 'exit';
        }));
    }
    beforeAttachPortal() { }
    ngAfterViewInit() {
        if (this.config.outsideClosable && !this.config.hasBackdrop) {
            timer().subscribe(() => {
                this.thyClickDispatcher
                    .clicked()
                    .pipe(takeUntil(this.animationClosingDone))
                    .subscribe((event) => {
                    if (!this.elementRef.nativeElement.contains(event.target)) {
                        this.ngZone.run(() => {
                            this.outsideClicked.emit();
                        });
                    }
                });
            });
        }
    }
    /** Callback, invoked whenever an animation on the host completes. */
    onAnimationDone(event) {
        // if (event.toState === 'void') {
        //     this.trapFocus();
        // } else if (event.toState === 'exit') {
        //     this.restoreFocus();
        // }
        this.animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    onAnimationStart(event) {
        this.animationStateChanged.emit(event);
    }
    startExitAnimation() {
        this.animationState = 'exit';
        // Mark the container for check so it can react if the
        // view container is using OnPush change detection.
        this.changeDetectorRef.markForCheck();
    }
    onInsideClick() {
        if (this.config.insideClosable) {
            this.insideClicked.emit();
        }
    }
    ngOnDestroy() {
        super.destroy();
    }
}
ThyPopoverContainerComponent.ɵfac = function ThyPopoverContainerComponent_Factory(t) { return new (t || ThyPopoverContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ThyPopoverConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ThyClickDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ThyPopoverContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyPopoverContainerComponent, selectors: [["thy-popover-container"]], viewQuery: function ThyPopoverContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(CdkPortalOutlet, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, hostAttrs: ["tabindex", "-1", 1, "thy-popover-container"], hostVars: 2, hostBindings: function ThyPopoverContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@popoverContainer.start", function ThyPopoverContainerComponent_animation_popoverContainer_start_HostBindingHandler($event) { return ctx.onAnimationStart($event); })("@popoverContainer.done", function ThyPopoverContainerComponent_animation_popoverContainer_done_HostBindingHandler($event) { return ctx.onAnimationDone($event); });
        ɵngcc0.ɵɵlistener("click", function ThyPopoverContainerComponent_click_HostBindingHandler() { return ctx.onInsideClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "popover");
        ɵngcc0.ɵɵsyntheticHostProperty("@popoverContainer", ctx.animationState);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function ThyPopoverContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ThyPopoverContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [ɵngcc2.CdkPortalOutlet], encapsulation: 2, data: { animation: [thyPopoverAnimations.popoverContainer] } });
ThyPopoverContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ThyPopoverConfig },
    { type: ChangeDetectorRef },
    { type: ThyClickDispatcher },
    { type: NgZone }
];
ThyPopoverContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }],
    onInsideClick: [{ type: HostListener, args: ['click', [],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyPopoverContainerComponent, [{
        type: Component,
        args: [{
                selector: 'thy-popover-container',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                animations: [thyPopoverAnimations.popoverContainer],
                host: {
                    class: 'thy-popover-container',
                    tabindex: '-1',
                    '[attr.role]': `'popover'`,
                    '[@popoverContainer]': 'animationState',
                    '(@popoverContainer.start)': 'onAnimationStart($event)',
                    '(@popoverContainer.done)': 'onAnimationDone($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ThyPopoverConfig }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.ThyClickDispatcher }, { type: ɵngcc0.NgZone }]; }, { onInsideClick: [{
            type: HostListener,
            args: ['click', []]
        }], portalOutlet: [{
            type: ViewChild,
            args: [CdkPortalOutlet, { static: true }]
        }] }); })();

class ThyPopoverRef extends ThyAbstractOverlayRef {
}
class ThyInternalPopoverRef extends ThyAbstractInternalOverlayRef {
    constructor(overlayRef, containerInstance, config) {
        super(popoverUpperOverlayOptions, overlayRef, containerInstance, config);
        containerInstance.insideClicked.subscribe(() => {
            this.close();
        });
        containerInstance.outsideClicked.subscribe(() => {
            this.close();
        });
    }
    /**
     * Updates the popover's position.
     * @param position New popover position.
     */
    updatePosition() {
        this.overlayRef.updatePosition();
        return this;
    }
}

class ThyPopover extends ThyAbstractOverlayService {
    constructor(overlay, injector, defaultConfig, scrollStrategy, ngZone, _viewportRuler, _document, _platform, _overlayContainer) {
        super(popoverUpperOverlayOptions, overlay, injector, Object.assign(Object.assign({}, THY_POPOVER_DEFAULT_CONFIG_VALUE), defaultConfig), scrollStrategy);
        this.ngZone = ngZone;
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        this.ngUnsubscribe$ = new Subject();
        this.originInstancesMap = new Map();
    }
    buildPositionStrategy(config) {
        const origin = config.originPosition ? config.originPosition : config.origin;
        // const positionStrategy = this.overlay.position().flexibleConnectedTo(origin);
        const positionStrategy = new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        const positions = getFlexiblePositions(config.placement, config.offset, 'thy-popover');
        positionStrategy.withPositions(positions);
        positionStrategy.withGrowAfterOpen(true);
        positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(change => {
            if (change.scrollableViewProperties.isOverlayClipped) {
                // After position changes occur and the overlay is clipped by
                // a parent scrollable then close the tooltip.
                this.ngZone.run(() => this.close());
            }
        });
        return positionStrategy;
    }
    buildScrollStrategy(config) {
        if (config.scrollStrategy) {
            return config.scrollStrategy;
        }
        else if (this.scrollStrategy && isFunction(this.scrollStrategy)) {
            return this.scrollStrategy();
        }
        else {
            this.overlay.scrollStrategies.block();
        }
    }
    buildOverlayConfig(config) {
        const positionStrategy = this.buildPositionStrategy(config);
        const overlayConfig = this.buildBaseOverlayConfig(config);
        overlayConfig.positionStrategy = positionStrategy;
        overlayConfig.scrollStrategy = this.buildScrollStrategy(config);
        return overlayConfig;
    }
    attachUpperOverlayContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = Injector.create({
            parent: userInjector || this.injector,
            providers: [{ provide: ThyPopoverConfig, useValue: config }]
        });
        const containerPortal = new ComponentPortal(ThyPopoverContainerComponent, config.viewContainerRef, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createUpperOverlayRef(overlayRef, containerInstance, config) {
        return new ThyInternalPopoverRef(overlayRef, containerInstance, config);
    }
    createInjector(config, popoverRef, popoverContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injectionTokens = [
            { provide: ThyPopoverContainerComponent, useValue: popoverContainer },
            {
                provide: ThyPopoverRef,
                useValue: popoverRef
            }
        ];
        if (config.direction && (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.push({
                provide: Directionality,
                useValue: {
                    value: config.direction,
                    change: of()
                }
            });
        }
        return Injector.create({ parent: userInjector || this.injector, providers: injectionTokens });
    }
    originElementAddActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.add(...coerceArray(config.originActiveClass));
        }
    }
    originElementRemoveActiveClass(config) {
        if (config.originActiveClass) {
            coerceElement(config.origin).classList.remove(...coerceArray(config.originActiveClass));
        }
    }
    ensureCloseClosest(origin) {
        let closeAndEnd = false;
        this.originInstancesMap.forEach((value, key) => {
            if (value.config.manualClosure) {
                if (key === origin) {
                    value.popoverRef.close();
                    closeAndEnd = true;
                }
            }
            else {
                if (key === origin) {
                    closeAndEnd = true;
                }
                value.popoverRef.close();
            }
        });
        return closeAndEnd;
    }
    open(componentOrTemplateRef, config) {
        const originElement = coerceElement(config.origin);
        // 默认关闭之前的弹出框
        // 1. 当之前的 Popover 设置 manualClosure 为 true 时, 弹出其他 Popover 时不自动关闭 manualClosure 为 true 的 Popover
        // 2. 当前的 Origin 对应的 Popover 已经弹出，不管 manualClosure 设置为何，直接关闭并返回
        if (this.ensureCloseClosest(originElement)) {
            return;
        }
        const popoverRef = this.openUpperOverlay(componentOrTemplateRef, config);
        config = popoverRef.containerInstance.config;
        popoverRef.afterClosed().subscribe(() => {
            this.originElementRemoveActiveClass(config);
            this.originInstancesMap.delete(originElement);
        });
        this.originElementAddActiveClass(config);
        this.originInstancesMap.set(originElement, {
            config,
            popoverRef
        });
        return popoverRef;
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyPopover.ɵfac = function ThyPopover_Factory(t) { return new (t || ThyPopover)(ɵngcc0.ɵɵinject(ɵngcc3.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(THY_POPOVER_DEFAULT_CONFIG, 8), ɵngcc0.ɵɵinject(THY_POPOVER_SCROLL_STRATEGY), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc3.ViewportRuler), ɵngcc0.ɵɵinject(DOCUMENT, 8), ɵngcc0.ɵɵinject(ɵngcc4.Platform), ɵngcc0.ɵɵinject(ɵngcc3.OverlayContainer)); };
ThyPopover.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThyPopover_Factory() { return new ThyPopover(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(THY_POPOVER_DEFAULT_CONFIG, 8), i0.ɵɵinject(THY_POPOVER_SCROLL_STRATEGY), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.ViewportRuler), i0.ɵɵinject(i4.DOCUMENT, 8), i0.ɵɵinject(i5.Platform), i0.ɵɵinject(i1.OverlayContainer)); }, token: ThyPopover, providedIn: "root" });
ThyPopover.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ThyPopoverConfig, decorators: [{ type: Optional }, { type: Inject, args: [THY_POPOVER_DEFAULT_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [THY_POPOVER_SCROLL_STRATEGY,] }] },
    { type: NgZone },
    { type: ViewportRuler },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: Platform },
    { type: OverlayContainer }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyPopover, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc3.Overlay }, { type: ɵngcc0.Injector }, { type: ThyPopoverConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [THY_POPOVER_DEFAULT_CONFIG]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [THY_POPOVER_SCROLL_STRATEGY]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.ViewportRuler }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc4.Platform }, { type: ɵngcc3.OverlayContainer }]; }, null); })();

class ThyPopoverHeaderComponent {
    constructor(translate, thyPopover) {
        this.translate = translate;
        this.thyPopover = thyPopover;
        this.thyClosed = new EventEmitter();
    }
    set thyTitleTranslationKey(key) {
        if (key && !this.thyTitle) {
            this.thyTitle = this.translate.instant(key);
        }
    }
    close(event) {
        this.thyClosed.emit(event);
        this.thyPopover.close();
    }
}
ThyPopoverHeaderComponent.ɵfac = function ThyPopoverHeaderComponent_Factory(t) { return new (t || ThyPopoverHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ThyTranslate), ɵngcc0.ɵɵdirectiveInject(ThyPopover)); };
ThyPopoverHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ThyPopoverHeaderComponent, selectors: [["thy-popover-header"]], inputs: { thyTitleTranslationKey: "thyTitleTranslationKey", thyTitle: "thyTitle" }, outputs: { thyClosed: "thyClosed" }, exportAs: ["thyPopoverHeader"], decls: 5, vars: 1, consts: [[1, "thy-popover-header"], [1, "thy-popover-title"], ["type", "button", 1, "close", 3, "click"], ["thyIconName", "close-bold"]], template: function ThyPopoverHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "h5", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 2);
        ɵngcc0.ɵɵlistener("click", function ThyPopoverHeaderComponent_Template_button_click_3_listener($event) { return ctx.close($event); });
        ɵngcc0.ɵɵelement(4, "thy-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.thyTitle);
    } }, directives: [ɵngcc5.ThyIconComponent], encapsulation: 2 });
ThyPopoverHeaderComponent.ctorParameters = () => [
    { type: ThyTranslate },
    { type: ThyPopover }
];
ThyPopoverHeaderComponent.propDecorators = {
    thyTitle: [{ type: Input }],
    thyTitleTranslationKey: [{ type: Input }],
    thyClosed: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyPopoverHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'thy-popover-header',
                template: "<div class=\"thy-popover-header\">\n  <h5 class=\"thy-popover-title\">{{ thyTitle }}</h5>\n  <button type=\"button\" class=\"close\" (click)=\"close($event)\">\n    <thy-icon thyIconName=\"close-bold\"></thy-icon>\n  </button>\n</div>\n",
                exportAs: 'thyPopoverHeader'
            }]
    }], function () { return [{ type: ɵngcc1.ThyTranslate }, { type: ThyPopover }]; }, { thyClosed: [{
            type: Output
        }], thyTitleTranslationKey: [{
            type: Input
        }], thyTitle: [{
            type: Input
        }] }); })();

class ThyPopoverDirective extends ThyOverlayDirectiveBase {
    constructor(elementRef, platform, focusMonitor, ngZone, popover, viewContainerRef) {
        super(elementRef, platform, focusMonitor, ngZone);
        this.popover = popover;
        this.viewContainerRef = viewContainerRef;
        this.popoverOpened = false;
        this.showDelay = 0;
        this.hideDelay = 0;
        this.tooltipPin = true;
    }
    set thyTrigger(trigger) {
        this.trigger = trigger;
    }
    ngOnInit() {
        this.initialize();
    }
    createOverlay() {
        const config = Object.assign({
            origin: this.elementRef.nativeElement,
            hasBackdrop: this.trigger === 'click' || this.trigger === 'focus',
            viewContainerRef: this.viewContainerRef,
            placement: this.thyPlacement,
            offset: this.thyOffset
        }, this.thyConfig);
        this.popoverRef = this.popover.open(this.content, config);
        this.popoverRef.afterClosed().subscribe(() => {
            this.popoverOpened = false;
        });
        return this.popoverRef.getOverlayRef();
    }
    show(delay = this.showDelay) {
        if (this.hideTimeoutId) {
            clearTimeout(this.hideTimeoutId);
            this.hideTimeoutId = null;
        }
        if (this.disabled || (this.overlayRef && this.overlayRef.hasAttached())) {
            return;
        }
        if (this.trigger !== 'hover') {
            delay = 0;
        }
        this.showTimeoutId = setTimeout(() => {
            const overlayRef = this.createOverlay();
            this.overlayRef = overlayRef;
            this.popoverOpened = true;
            this.showTimeoutId = null;
        }, delay);
    }
    hide(delay = this.hideDelay) {
        if (this.showTimeoutId) {
            clearTimeout(this.showTimeoutId);
            this.showTimeoutId = null;
        }
        this.hideTimeoutId = setTimeout(() => {
            if (this.popoverRef) {
                this.popoverRef.close();
            }
            this.hideTimeoutId = null;
        }, delay);
    }
    ngOnDestroy() {
        this.dispose();
    }
}
ThyPopoverDirective.ɵfac = function ThyPopoverDirective_Factory(t) { return new (t || ThyPopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ThyPopover), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ThyPopoverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ThyPopoverDirective, selectors: [["", "thyPopover", ""]], hostVars: 2, hostBindings: function ThyPopoverDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thy-popover-opened", ctx.popoverOpened);
    } }, inputs: { showDelay: ["thyShowDelay", "showDelay"], hideDelay: ["thyHideDelay", "hideDelay"], thyTrigger: "thyTrigger", content: ["thyPopover", "content"], thyPlacement: "thyPlacement", thyOffset: "thyOffset", thyConfig: "thyConfig" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
ThyPopoverDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Platform },
    { type: FocusMonitor },
    { type: NgZone },
    { type: ThyPopover },
    { type: ViewContainerRef }
];
ThyPopoverDirective.propDecorators = {
    popoverOpened: [{ type: HostBinding, args: [`class.thy-popover-opened`,] }],
    content: [{ type: Input, args: ['thyPopover',] }],
    thyTrigger: [{ type: Input }],
    thyPlacement: [{ type: Input }],
    thyOffset: [{ type: Input }],
    thyConfig: [{ type: Input }],
    showDelay: [{ type: Input, args: ['thyShowDelay',] }],
    hideDelay: [{ type: Input, args: ['thyHideDelay',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyPopoverDirective, [{
        type: Directive,
        args: [{
                selector: '[thyPopover]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.Platform }, { type: ɵngcc6.FocusMonitor }, { type: ɵngcc0.NgZone }, { type: ThyPopover }, { type: ɵngcc0.ViewContainerRef }]; }, { popoverOpened: [{
            type: HostBinding,
            args: [`class.thy-popover-opened`]
        }], showDelay: [{
            type: Input,
            args: ['thyShowDelay']
        }], hideDelay: [{
            type: Input,
            args: ['thyHideDelay']
        }], thyTrigger: [{
            type: Input
        }], content: [{
            type: Input,
            args: ['thyPopover']
        }], thyPlacement: [{
            type: Input
        }], thyOffset: [{
            type: Input
        }], thyConfig: [{
            type: Input
        }] }); })();

class ThyPopoverModule {
}
ThyPopoverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ThyPopoverModule });
ThyPopoverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ThyPopoverModule_Factory(t) { return new (t || ThyPopoverModule)(); }, providers: [THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_SCROLL_STRATEGY_PROVIDER], imports: [[CommonModule, OverlayModule, PortalModule, ThyIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ThyPopoverModule, { declarations: function () { return [ThyPopoverContainerComponent, ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverBodyComponent]; }, imports: function () { return [CommonModule, OverlayModule, PortalModule, ThyIconModule]; }, exports: function () { return [ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverBodyComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThyPopoverModule, [{
        type: NgModule,
        args: [{
                declarations: [ThyPopoverContainerComponent, ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverBodyComponent],
                entryComponents: [ThyPopoverContainerComponent],
                imports: [CommonModule, OverlayModule, PortalModule, ThyIconModule],
                exports: [ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverBodyComponent],
                providers: [THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_SCROLL_STRATEGY_PROVIDER]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { THY_POPOVER_DEFAULT_CONFIG, THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_DEFAULT_CONFIG_VALUE, THY_POPOVER_SCROLL_STRATEGY, THY_POPOVER_SCROLL_STRATEGY_FACTORY, THY_POPOVER_SCROLL_STRATEGY_PROVIDER, ThyInternalPopoverRef, ThyPopover, ThyPopoverBodyComponent, ThyPopoverConfig, ThyPopoverContainerComponent, ThyPopoverDirective, ThyPopoverHeaderComponent, ThyPopoverModule, ThyPopoverRef, thyPopoverAnimations };

//# sourceMappingURL=ngx-tethys-popover.js.map