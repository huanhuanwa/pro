import { Injectable, NgZone, Inject, EventEmitter, Directive, ElementRef, Renderer2, Input, Output, Component, ChangeDetectionStrategy, ChangeDetectorRef, NgModule } from '@angular/core';
import { __decorate, __metadata } from 'tslib';
import { mixinUnsubscribe, MixinBase, InputBoolean } from 'ngx-tethys/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { isTouchEvent } from 'ngx-tethys/util';
import { Subject } from 'rxjs';
import { Platform } from '@angular/cdk/platform';
import { takeUntil } from 'rxjs/operators';

class ThyResizableService {
    constructor(ngZone, document) {
        this.ngZone = ngZone;
        this.listeners = new Map();
        this.handleMouseDown$ = new Subject();
        this.documentMouseUp$ = new Subject();
        this.documentMouseMove$ = new Subject();
        this.mouseEntered$ = new Subject();
        this.document = document;
    }
    startResizing(event) {
        const _isTouchEvent = isTouchEvent(event);
        this.clearListeners();
        const moveEvent = _isTouchEvent ? 'touchmove' : 'mousemove';
        const upEvent = _isTouchEvent ? 'touchend' : 'mouseup';
        const moveEventHandler = (e) => {
            this.documentMouseMove$.next(e);
        };
        const upEventHandler = (e) => {
            this.documentMouseUp$.next(e);
            this.clearListeners();
        };
        this.listeners.set(moveEvent, moveEventHandler);
        this.listeners.set(upEvent, upEventHandler);
        this.ngZone.runOutsideAngular(() => {
            this.listeners.forEach((handler, name) => {
                this.document.addEventListener(name, handler);
            });
        });
    }
    clearListeners() {
        this.listeners.forEach((handler, name) => {
            this.document.removeEventListener(name, handler);
        });
        this.listeners.clear();
    }
    ngOnDestroy() {
        this.handleMouseDown$.complete();
        this.documentMouseUp$.complete();
        this.documentMouseMove$.complete();
        this.mouseEntered$.complete();
        this.clearListeners();
    }
}
ThyResizableService.decorators = [
    { type: Injectable }
];
ThyResizableService.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

function getEventWithPoint(event) {
    return isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
}
function ensureInBounds(value, boundValue) {
    return value ? (value < boundValue ? value : boundValue) : boundValue;
}

const _MixinBase$1 = mixinUnsubscribe(MixinBase);
class ThyResizableDirective extends _MixinBase$1 {
    constructor(elementRef, renderer, platform, ngZone, thyResizableService) {
        super();
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.platform = platform;
        this.ngZone = ngZone;
        this.thyResizableService = thyResizableService;
        this.thyBounds = 'parent';
        this.thyMinHeight = 40;
        this.thyMinWidth = 40;
        this.thyGridColumnCount = -1;
        this.thyMaxColumn = -1;
        this.thyMinColumn = -1;
        this.thyLockAspectRatio = false;
        this.thyPreview = false;
        this.thyDisabled = false;
        this.thyResize = new EventEmitter();
        this.thyResizeEnd = new EventEmitter();
        this.thyResizeStart = new EventEmitter();
        this.resizing = false;
        this.sizeCache = null;
        this.ghostElement = null;
        this.currentHandleEvent = null;
        this.thyResizableService.handleMouseDown$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            if (this.thyDisabled) {
                return;
            }
            this.resizing = true;
            this.thyResizableService.startResizing(event.mouseEvent);
            this.currentHandleEvent = event;
            this.setCursor();
            this.thyResizeStart.emit({
                mouseEvent: event.mouseEvent
            });
            this.nativeElementRect = this.nativeElement.getBoundingClientRect();
        });
        this.thyResizableService.documentMouseUp$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            if (this.resizing) {
                this.resizing = false;
                this.thyResizableService.documentMouseUp$.next();
                this.endResize(event);
            }
        });
        this.thyResizableService.documentMouseMove$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(event => {
            if (this.resizing) {
                this.resize(event);
            }
        });
    }
    ngAfterViewInit() {
        if (this.platform.isBrowser) {
            this.nativeElement = this.elementRef.nativeElement;
            this.setPosition();
        }
    }
    setCursor() {
        switch (this.currentHandleEvent.direction) {
            case 'left':
            case 'right':
                this.renderer.setStyle(document.body, 'cursor', 'ew-resize');
                break;
            case 'top':
            case 'bottom':
                this.renderer.setStyle(document.body, 'cursor', 'ns-resize');
                break;
            case 'topLeft':
            case 'bottomRight':
                this.renderer.setStyle(document.body, 'cursor', 'nwse-resize');
                break;
            case 'topRight':
            case 'bottomLeft':
                this.renderer.setStyle(document.body, 'cursor', 'nesw-resize');
                break;
        }
        this.renderer.setStyle(document.body, 'user-select', 'none');
    }
    setPosition() {
        const position = getComputedStyle(this.nativeElement).position;
        if (position === 'static' || !position) {
            this.renderer.setStyle(this.nativeElement, 'position', 'relative');
        }
    }
    onMouseenter() {
        this.thyResizableService.mouseEntered$.next(true);
    }
    onMouseleave() {
        this.thyResizableService.mouseEntered$.next(false);
    }
    endResize(event) {
        this.renderer.setStyle(document.body, 'cursor', '');
        this.renderer.setStyle(document.body, 'user-select', '');
        this.removeGhostElement();
        const size = this.sizeCache
            ? Object.assign({}, this.sizeCache) : {
            width: this.nativeElementRect.width,
            height: this.nativeElementRect.height
        };
        this.ngZone.run(() => {
            this.thyResizeEnd.emit(Object.assign(Object.assign({}, size), { mouseEvent: event }));
        });
        this.sizeCache = null;
        this.currentHandleEvent = null;
    }
    resize(event) {
        const nativeElementRect = this.nativeElementRect;
        const resizeEvent = getEventWithPoint(event);
        const handleEvent = getEventWithPoint(this.currentHandleEvent.mouseEvent);
        let width = nativeElementRect.width;
        let height = nativeElementRect.height;
        const ratio = this.thyLockAspectRatio ? width / height : -1;
        switch (this.currentHandleEvent.direction) {
            case 'bottomRight':
                width = resizeEvent.clientX - nativeElementRect.left;
                height = resizeEvent.clientY - nativeElementRect.top;
                break;
            case 'bottomLeft':
                width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
                height = resizeEvent.clientY - nativeElementRect.top;
                break;
            case 'topRight':
                width = resizeEvent.clientX - nativeElementRect.left;
                height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
                break;
            case 'topLeft':
                width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
                height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
                break;
            case 'top':
                height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
                break;
            case 'right':
                width = resizeEvent.clientX - nativeElementRect.left;
                break;
            case 'bottom':
                height = resizeEvent.clientY - nativeElementRect.top;
                break;
            case 'left':
                width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
        }
        const size = this.calcSize(width, height, ratio);
        this.sizeCache = Object.assign({}, size);
        if (this.thyPreview) {
            this.previewResize(size);
        }
        this.ngZone.run(() => {
            this.thyResize.emit(Object.assign(Object.assign({}, size), { mouseEvent: event }));
        });
    }
    calcSize(width, height, ratio) {
        let newWidth;
        let newHeight;
        let maxWidth;
        let maxHeight;
        let col = 0;
        let spanWidth = 0;
        let minWidth = this.thyMinWidth;
        let boundWidth = Infinity;
        let boundHeight = Infinity;
        if (this.thyBounds === 'parent') {
            const parent = this.renderer.parentNode(this.nativeElement);
            if (parent instanceof HTMLElement) {
                const parentRect = parent.getBoundingClientRect();
                boundWidth = parentRect.width;
                boundHeight = parentRect.height;
            }
        }
        else if (this.thyBounds === 'window') {
            if (typeof window !== 'undefined') {
                boundWidth = window.innerWidth;
                boundHeight = window.innerHeight;
            }
        }
        else if (this.thyBounds && this.thyBounds.nativeElement && this.thyBounds.nativeElement instanceof HTMLElement) {
            const boundsRect = this.thyBounds.nativeElement.getBoundingClientRect();
            boundWidth = boundsRect.width;
            boundHeight = boundsRect.height;
        }
        maxWidth = ensureInBounds(this.thyMaxWidth, boundWidth);
        maxHeight = ensureInBounds(this.thyMaxHeight, boundHeight);
        if (this.thyGridColumnCount !== -1) {
            spanWidth = maxWidth / this.thyGridColumnCount;
            minWidth = this.thyMinColumn !== -1 ? spanWidth * this.thyMinColumn : minWidth;
            maxWidth = this.thyMaxColumn !== -1 ? spanWidth * this.thyMaxColumn : maxWidth;
        }
        if (ratio !== -1) {
            if (/(left|right)/i.test(this.currentHandleEvent.direction)) {
                newWidth = Math.min(Math.max(width, minWidth), maxWidth);
                newHeight = Math.min(Math.max(newWidth / ratio, this.thyMinHeight), maxHeight);
                if (newHeight >= maxHeight || newHeight <= this.thyMinHeight) {
                    newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
                }
            }
            else {
                newHeight = Math.min(Math.max(height, this.thyMinHeight), maxHeight);
                newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
                if (newWidth >= maxWidth || newWidth <= minWidth) {
                    newHeight = Math.min(Math.max(newWidth / ratio, this.thyMinHeight), maxHeight);
                }
            }
        }
        else {
            newWidth = Math.min(Math.max(width, minWidth), maxWidth);
            newHeight = Math.min(Math.max(height, this.thyMinHeight), maxHeight);
        }
        if (this.thyGridColumnCount !== -1) {
            col = Math.round(newWidth / spanWidth);
            newWidth = col * spanWidth;
        }
        return {
            col,
            width: newWidth,
            height: newHeight
        };
    }
    previewResize({ width, height }) {
        this.createGhostElement();
        this.renderer.setStyle(this.ghostElement, 'width', `${width}px`);
        this.renderer.setStyle(this.ghostElement, 'height', `${height}px`);
    }
    createGhostElement() {
        if (!this.ghostElement) {
            this.ghostElement = this.renderer.createElement('div');
            this.renderer.setAttribute(this.ghostElement, 'class', 'thy-resizable-preview');
        }
        this.renderer.appendChild(this.nativeElement, this.ghostElement);
    }
    removeGhostElement() {
        if (this.ghostElement) {
            this.renderer.removeChild(this.nativeElement, this.ghostElement);
        }
    }
    ngOnDestroy() {
        this.ghostElement = null;
        this.sizeCache = null;
        super.ngOnDestroy();
    }
}
ThyResizableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyResizable]',
                providers: [ThyResizableService],
                host: {
                    class: 'thy-resizable',
                    '[class.thy-resizable-resizing]': 'resizing',
                    '[class.thy-resizable-disabled]': 'thyDisabled',
                    '(mouseenter)': 'onMouseenter()',
                    '(mouseleave)': 'onMouseleave()'
                }
            },] }
];
ThyResizableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Platform },
    { type: NgZone },
    { type: ThyResizableService }
];
ThyResizableDirective.propDecorators = {
    thyBounds: [{ type: Input }],
    thyMaxHeight: [{ type: Input }],
    thyMaxWidth: [{ type: Input }],
    thyMinHeight: [{ type: Input }],
    thyMinWidth: [{ type: Input }],
    thyGridColumnCount: [{ type: Input }],
    thyMaxColumn: [{ type: Input }],
    thyMinColumn: [{ type: Input }],
    thyLockAspectRatio: [{ type: Input }],
    thyPreview: [{ type: Input }],
    thyDisabled: [{ type: Input }],
    thyResize: [{ type: Output }],
    thyResizeEnd: [{ type: Output }],
    thyResizeStart: [{ type: Output }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], ThyResizableDirective.prototype, "thyLockAspectRatio", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], ThyResizableDirective.prototype, "thyPreview", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], ThyResizableDirective.prototype, "thyDisabled", void 0);

class ThyResizeHandleMouseDownEvent {
    constructor(direction, mouseEvent) {
        this.direction = direction;
        this.mouseEvent = mouseEvent;
    }
}
const _MixinBase = mixinUnsubscribe(MixinBase);
class ThyResizeHandleComponent extends _MixinBase {
    constructor(thyResizableService, cdr, elementRef) {
        super();
        this.thyResizableService = thyResizableService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.thyDirection = 'bottomRight';
        this.thyMouseDown = new EventEmitter();
        this.entered = false;
        // TODO: move to host after View Engine deprecation
        this.elementRef.nativeElement.classList.add('thy-resizable-handle');
    }
    ngOnInit() {
        this.thyResizableService.mouseEntered$.pipe(takeUntil(this.ngUnsubscribe$)).subscribe(entered => {
            this.entered = entered;
            this.cdr.markForCheck();
        });
    }
    onMousedown(event) {
        this.thyResizableService.handleMouseDown$.next(new ThyResizeHandleMouseDownEvent(this.thyDirection, event));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
ThyResizeHandleComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-resize-handle, [thy-resize-handle]',
                exportAs: 'thyResizeHandle',
                template: `
        <ng-content></ng-content>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.thy-resizable-handle-top]': `thyDirection === 'top'`,
                    '[class.thy-resizable-handle-right]': `thyDirection === 'right'`,
                    '[class.thy-resizable-handle-bottom]': `thyDirection === 'bottom'`,
                    '[class.thy-resizable-handle-left]': `thyDirection === 'left'`,
                    '[class.thy-resizable-handle-topRight]': `thyDirection === 'topRight'`,
                    '[class.thy-resizable-handle-bottomRight]': `thyDirection === 'bottomRight'`,
                    '[class.thy-resizable-handle-bottomLeft]': `thyDirection === 'bottomLeft'`,
                    '[class.thy-resizable-handle-topLeft]': `thyDirection === 'topLeft'`,
                    '[class.thy-resizable-handle-box-hover]': 'entered',
                    '(mousedown)': 'onMousedown($event)',
                    '(touchstart)': 'onMousedown($event)'
                }
            },] }
];
ThyResizeHandleComponent.ctorParameters = () => [
    { type: ThyResizableService },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
ThyResizeHandleComponent.propDecorators = {
    thyDirection: [{ type: Input }],
    thyMouseDown: [{ type: Output }]
};

const DEFAULT_RESIZE_DIRECTION = [
    'bottomRight',
    'topRight',
    'bottomLeft',
    'topLeft',
    'bottom',
    'right',
    'top',
    'left'
];
class ThyResizeHandlesComponent {
    constructor() {
        this.thyDirections = DEFAULT_RESIZE_DIRECTION;
        this.directions = new Set(this.thyDirections);
    }
    ngOnChanges(changes) {
        if (changes.thyDirections) {
            this.directions = new Set(changes.thyDirections.currentValue);
        }
    }
}
ThyResizeHandlesComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-resize-handles',
                exportAs: 'thyResizeHandles',
                template: `
        <thy-resize-handle *ngFor="let dir of directions" [thyDirection]="dir"></thy-resize-handle>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ThyResizeHandlesComponent.ctorParameters = () => [];
ThyResizeHandlesComponent.propDecorators = {
    thyDirections: [{ type: Input }]
};

class ThyResizableModule {
}
ThyResizableModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [ThyResizableDirective, ThyResizeHandleComponent, ThyResizeHandlesComponent],
                exports: [ThyResizableDirective, ThyResizeHandleComponent, ThyResizeHandlesComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_RESIZE_DIRECTION, ThyResizableDirective, ThyResizableModule, ThyResizableService, ThyResizeHandleComponent, ThyResizeHandleMouseDownEvent, ThyResizeHandlesComponent, ensureInBounds, getEventWithPoint };
//# sourceMappingURL=ngx-tethys-resizable.js.map
