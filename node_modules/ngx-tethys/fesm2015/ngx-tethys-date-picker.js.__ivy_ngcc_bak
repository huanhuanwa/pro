import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { formatDate, CommonModule, registerLocaleData } from '@angular/common';
import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, ElementRef, Renderer2, ViewContainerRef, Input, Output, Injectable, ChangeDetectorRef, NgModule, ViewChild, Directive, forwardRef, Pipe } from '@angular/core';
import localeZhHans from '@angular/common/locales/zh-Hans';
import { FormsModule, NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { TinyDate, sortRangeValue, valueFunctionProp, isTemplateRef, isEmpty, isString, coerceBooleanProperty, warnDeprecation } from 'ngx-tethys/util';
import { fromUnixTime, startOfDay, endOfDay } from 'date-fns';
import { ThyButtonModule } from 'ngx-tethys/button';
import { ThyIconModule } from 'ngx-tethys/icon';
import { ThyTimePickerModule } from 'ngx-tethys/time-picker';
import { __decorate, __metadata } from 'tslib';
import { Subject, fromEvent } from 'rxjs';
import { getFlexiblePositions, InputBoolean } from 'ngx-tethys/core';
import { ThyInputModule } from 'ngx-tethys/input';
import { ThyPopover, ThyPopoverModule } from 'ngx-tethys/popover';
import { tap, mapTo, takeUntil, debounceTime } from 'rxjs/operators';
import { coerceArray } from '@angular/cdk/coercion';

function instanceOfDateEntry(object) {
    return isSupportDateType(object, 'date') && typeof object.with_time === 'number';
}
function instanceOfRangeEntry(object) {
    return isSupportDateType(object, 'begin') && isSupportDateType(object, 'end');
}
function isSupportDateType(object, key) {
    return typeof object[key] === 'number' || object[key] === null || object[key] instanceof Date;
}

class CalendarFooterComponent {
    constructor(_elementRef, _renderer, _viewContainerRef) {
        this.showTime = false;
        this.mustShowTime = false;
        this.selectTime = new EventEmitter();
        this.clickOk = new EventEmitter();
        this.clickRemove = new EventEmitter();
        this.showTimePickerChange = new EventEmitter();
        this.isShowTime = false;
        this.isCanTime = false;
    }
    ngOnInit() {
        this._initTimeShowMode();
        if (!this.value) {
            this.value = new TinyDate();
        }
    }
    onSelectTime(date) {
        this.selectTime.emit(new TinyDate(date));
    }
    onTimeOk() {
        this.selectTime.emit(this.value);
        this.clickOk.emit();
    }
    onClear() {
        this.value = null;
        this.clickRemove.emit();
    }
    changeTimeShowMode(type) {
        switch (type) {
            case 'can':
                this.isCanTime = true;
                this.isShowTime = false;
                break;
            case 'show':
                this.isCanTime = false;
                this.isShowTime = true;
                break;
        }
        this.showTimePickerChange.emit(this.isShowTime);
    }
    _initTimeShowMode() {
        if (this.mustShowTime) {
            this.changeTimeShowMode('show');
        }
        else {
            if (this.showTime) {
                this.changeTimeShowMode('can');
            }
        }
    }
}
CalendarFooterComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'calendar-footer',
                exportAs: 'calendarFooter',
                template: "<div *ngIf=\"isShowTime || isCanTime\" class=\"time-picker-section\" (click)=\"$event.stopPropagation()\">\n  <a\n    href=\"javascript:;\"\n    *ngIf=\"isCanTime\"\n    class=\"link-has-icon time-picker-set-btn\"\n    (click)=\"changeTimeShowMode('show')\"\n  >\n    <thy-icon thyIconName=\"clock-circle\"></thy-icon>\u8BBE\u7F6E\u65F6\u95F4\n  </a>\n  <thy-time-picker\n    *ngIf=\"isShowTime\"\n    class=\"time-picker-wrap\"\n    [showMeridian]=\"false\"\n    [ngModel]=\"value?.nativeDate\"\n    (ngModelChange)=\"onSelectTime($event)\"\n  ></thy-time-picker>\n  <div class=\"time-picker-btn-wrap\">\n    <button *ngIf=\"!isCanTime\" class=\"time-picker-ok-btn\" thyButton=\"primary\" thySize=\"sm\" (click)=\"onTimeOk()\">\n      \u786E\u5B9A\n    </button>\n    <button class=\"time-picker-clear-btn\" thyButton=\"link-secondary\" thySize=\"sm\" (click)=\"onClear()\">\n      \u6E05\u9664\n    </button>\n  </div>\n</div>\n"
            },] }
];
CalendarFooterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef }
];
CalendarFooterComponent.propDecorators = {
    showTime: [{ type: Input }],
    mustShowTime: [{ type: Input }],
    value: [{ type: Input }],
    selectTime: [{ type: Output }],
    clickOk: [{ type: Output }],
    clickRemove: [{ type: Output }],
    showTimePickerChange: [{ type: Output }]
};

function DATE_HELPER_SERVICE_FACTORY() {
    return new DateHelperByDatePipe();
}
class DateHelperService {
    constructor() {
        this.relyOnDatePipe = this instanceof DateHelperByDatePipe;
    }
}
DateHelperService.ɵprov = i0.ɵɵdefineInjectable({ factory: DATE_HELPER_SERVICE_FACTORY, token: DateHelperService, providedIn: "root" });
DateHelperService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
                useFactory: DATE_HELPER_SERVICE_FACTORY
            },] }
];
class DateHelperByDatePipe extends DateHelperService {
    getISOWeek(date) {
        return +this.format(date, 'w');
    }
    getFirstDayOfWeek() {
        return 0;
    }
    format(date, formatStr) {
        return date ? formatDate(date, formatStr, 'zh-Hans') : '';
    }
    transCompatFormat(format) {
        return format && format.replace(/Y/g, 'y').replace(/D/g, 'd');
    }
}
DateHelperByDatePipe.ɵprov = i0.ɵɵdefineInjectable({ factory: DATE_HELPER_SERVICE_FACTORY, token: DateHelperByDatePipe, providedIn: "root" });

class CalendarHeaderComponent {
    constructor(dateHelper) {
        this.dateHelper = dateHelper;
        this.enablePrev = true;
        this.enableNext = true;
        this.valueChange = new EventEmitter();
        this.panelModeChange = new EventEmitter();
        this.chooseDecade = new EventEmitter();
        this.chooseYear = new EventEmitter();
        this.chooseMonth = new EventEmitter();
        this.prefixCls = 'thy-calendar';
        // tslint:disable-next-line: max-line-length
        this.yearToMonth = false; // Indicate whether should change to month panel when current is year panel (if referer=month, it should show month panel when choosed a year)
    }
    ngOnInit() {
        if (!this.value) {
            this.value = new TinyDate();
        }
    }
    ngOnChanges(changes) {
        if (changes.value) {
            this.render();
        }
    }
    previousYear() {
        this.gotoYear(-1);
    }
    nextYear() {
        this.gotoYear(1);
    }
    previousMonth() {
        this.gotoMonth(-1);
    }
    nextMonth() {
        this.gotoMonth(1);
    }
    changePanel(mode, value) {
        this.panelModeChange.emit(mode);
        if (value) {
            this.changeValueFromInside(value);
        }
    }
    onChooseDecade(value) {
        this.changePanel('year', value);
        this.chooseDecade.emit(value);
    }
    onChooseYear(value) {
        this.changePanel(this.yearToMonth ? 'month' : 'date', value);
        this.yearToMonth = false; // Clear
        this.chooseYear.emit(value);
    }
    onChooseMonth(value) {
        this.changePanel('date', value);
        this.yearToMonth = false; // Clear
        this.chooseMonth.emit(value);
    }
    changeToMonthPanel() {
        this.changePanel('month');
        this.yearToMonth = true;
    }
    render() {
        if (this.value) {
            this.yearMonthDaySelectors = this.createYearMonthDaySelectors();
        }
    }
    gotoMonth(amount) {
        this.changeValueFromInside(this.value.addMonths(amount));
    }
    gotoYear(amount) {
        this.changeValueFromInside(this.value.addYears(amount));
    }
    changeValueFromInside(value) {
        if (this.value !== value) {
            this.value = value;
            this.valueChange.emit(this.value);
            this.render();
        }
    }
    formatDateTime(format) {
        return this.dateHelper.format(this.value.nativeDate, format);
    }
    createYearMonthDaySelectors() {
        let year;
        let month;
        // NOTE: Compat for DatePipe formatting rules
        let yearFormat = 'yyyy年';
        if (this.dateHelper.relyOnDatePipe) {
            yearFormat = this.dateHelper.transCompatFormat(yearFormat);
        }
        year = {
            className: `${this.prefixCls}-year-select`,
            onClick: () => this.changePanel('year'),
            label: this.formatDateTime(yearFormat)
        };
        month = {
            className: `${this.prefixCls}-month-select`,
            onClick: () => this.changeToMonthPanel(),
            label: this.formatDateTime('MMM')
        };
        // NOTE: Compat for DatePipe formatting rules
        let dayFormat = 'd日';
        if (this.dateHelper.relyOnDatePipe) {
            dayFormat = this.dateHelper.transCompatFormat(dayFormat);
        }
        let result;
        result = [year, month];
        return result.filter(selector => !!selector);
    }
}
CalendarHeaderComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'calendar-header',
                exportAs: 'calendarHeader',
                template: "<div class=\"{{ prefixCls }}-header\">\n  <div style=\"position: relative;\">\n    <a *ngIf=\"enablePrev\" class=\"{{ prefixCls }}-prev-year-btn\" role=\"button\" (click)=\"previousYear()\" title=\"\u53BB\u5E74\"></a>\n    <a\n      *ngIf=\"enablePrev\"\n      class=\"{{ prefixCls }}-prev-month-btn\"\n      role=\"button\"\n      (click)=\"previousMonth()\"\n      title=\"\u4E0A\u6708\"\n    ></a>\n\n    <span class=\"{{ prefixCls }}-my-select\">\n      <ng-container *ngFor=\"let selector of yearMonthDaySelectors\">\n        <a\n          class=\"{{ selector.className }}\"\n          role=\"button\"\n          (click)=\"selector.onClick ? selector.onClick() : null\"\n          title=\"{{ selector.title || null }}\"\n        >\n          {{ selector.label }}\n        </a>\n      </ng-container>\n    </span>\n\n    <a *ngIf=\"enableNext\" class=\"{{ prefixCls }}-next-month-btn\" role=\"button\" (click)=\"nextMonth()\" title=\"\u4E0B\u4E2A\u6708\"></a>\n    <a *ngIf=\"enableNext\" class=\"{{ prefixCls }}-next-year-btn\" role=\"button\" (click)=\"nextYear()\" title=\"\u4E0B\u4E00\u5E74\"></a>\n  </div>\n\n  <ng-container [ngSwitch]=\"panelMode\">\n    <ng-container *ngSwitchCase=\"'decade'\">\n      <decade-panel [value]=\"value\" (valueChange)=\"onChooseDecade($event)\"></decade-panel>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"'year'\">\n      <year-panel\n        [value]=\"value\"\n        [disabledDate]=\"disabledYear\"\n        (valueChange)=\"onChooseYear($event)\"\n        (decadePanelShow)=\"changePanel('decade')\"\n      ></year-panel>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"'month'\">\n      <month-panel\n        [value]=\"value\"\n        [disabledDate]=\"disabledMonth\"\n        (valueChange)=\"onChooseMonth($event)\"\n        (yearPanelShow)=\"changePanel('year')\"\n      ></month-panel>\n    </ng-container>\n  </ng-container>\n</div>\n"
            },] }
];
CalendarHeaderComponent.ctorParameters = () => [
    { type: DateHelperService }
];
CalendarHeaderComponent.propDecorators = {
    enablePrev: [{ type: Input }],
    enableNext: [{ type: Input }],
    disabledMonth: [{ type: Input }],
    disabledYear: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    panelMode: [{ type: Input }],
    panelModeChange: [{ type: Output }],
    chooseDecade: [{ type: Output }],
    chooseYear: [{ type: Output }],
    chooseMonth: [{ type: Output }]
};

const MAX_ROW$2 = 4;
const MAX_COL$2 = 3;
class DecadePanelComponent {
    constructor() {
        this.valueChange = new EventEmitter();
        this.prefixCls = 'thy-calendar-decade-panel';
    }
    get startYear() {
        return parseInt(`${this.value.getYear() / 100}`, 10) * 100;
    }
    get endYear() {
        return this.startYear + 99;
    }
    ngOnChanges(changes) {
        if (changes.value) {
            this.render();
        }
    }
    previousCentury() {
        this.gotoYear(-100);
    }
    nextCentury() {
        this.gotoYear(100);
    }
    trackPanelDecade(_index, decadeData) {
        return decadeData.content;
    }
    render() {
        if (this.value) {
            this.panelDecades = this.makePanelDecades();
        }
    }
    // Re-render panel content by the header's buttons (NOTE: Do not try to trigger final value change)
    gotoYear(amount) {
        this.value = this.value.addYears(amount);
        // this.valueChange.emit(this.value); // Do not try to trigger final value change
        this.render();
    }
    chooseDecade(startYear) {
        this.value = this.value.setYear(startYear);
        this.valueChange.emit(this.value);
    }
    makePanelDecades() {
        const decades = [];
        const currentYear = this.value.getYear();
        const startYear = this.startYear;
        const endYear = this.endYear;
        const previousYear = startYear - 10;
        let index = 0;
        for (let rowIndex = 0; rowIndex < MAX_ROW$2; rowIndex++) {
            decades[rowIndex] = [];
            for (let colIndex = 0; colIndex < MAX_COL$2; colIndex++) {
                const start = previousYear + index * 10;
                const end = previousYear + index * 10 + 9;
                const content = `${start}-${end}`;
                const cell = (decades[rowIndex][colIndex] = {
                    content,
                    title: content,
                    isCurrent: currentYear >= start && currentYear <= end,
                    isLowerThanStart: end < startYear,
                    isBiggerThanEnd: start > endYear,
                    classMap: null,
                    onClick: () => this.chooseDecade(start)
                });
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    [`${this.prefixCls}-selected-cell`]: cell.isCurrent,
                    [`${this.prefixCls}-last-century-cell`]: cell.isLowerThanStart,
                    [`${this.prefixCls}-next-century-cell`]: cell.isBiggerThanEnd
                };
                index++;
            }
        }
        return decades;
    }
}
DecadePanelComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'decade-panel',
                exportAs: 'decadePanel',
                template: "<div class=\"{{ prefixCls }}\">\n  <div class=\"{{ prefixCls }}-header\">\n    <a class=\"{{ prefixCls }}-prev-century-btn\" role=\"button\" (click)=\"previousCentury()\" title=\"\u4E0A\u4E00\u4E16\u7EAA\"></a>\n\n    <div class=\"{{ prefixCls }}-century\">{{ startYear }}-{{ endYear }}</div>\n    <a class=\"{{ prefixCls }}-next-century-btn\" role=\"button\" (click)=\"nextCentury()\" title=\"\u4E0B\u4E00\u4E16\u7EAA\"></a>\n  </div>\n  <div class=\"{{ prefixCls }}-body\">\n    <table class=\"{{ prefixCls }}-table\" cellSpacing=\"0\" role=\"grid\">\n      <tbody class=\"{{ prefixCls }}-tbody\">\n        <tr *ngFor=\"let row of panelDecades\" role=\"row\">\n          <td\n            *ngFor=\"let cell of row; trackBy: trackPanelDecade\"\n            role=\"gridcell\"\n            title=\"{{ cell.title }}\"\n            (click)=\"cell.onClick()\"\n            [ngClass]=\"cell.classMap\"\n          >\n            <a class=\"{{ prefixCls }}-decade\">{{ cell.content }}</a>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</div>\n"
            },] }
];
DecadePanelComponent.ctorParameters = () => [];
DecadePanelComponent.propDecorators = {
    value: [{ type: Input }],
    valueChange: [{ type: Output }]
};

class MonthPanelComponent {
    constructor() {
        this.valueChange = new EventEmitter();
        this.yearPanelShow = new EventEmitter();
        this.prefixCls = 'thy-calendar-month-panel';
    }
    previousYear() {
        this.gotoYear(-1);
    }
    nextYear() {
        this.gotoYear(1);
    }
    gotoYear(amount) {
        this.value = this.value.addYears(amount);
    }
}
MonthPanelComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'month-panel',
                exportAs: 'monthPanel',
                template: "<div class=\"{{ prefixCls }}\">\n  <div class=\"{{ prefixCls }}-header\">\n    <a class=\"{{ prefixCls }}-prev-year-btn\" role=\"button\" (click)=\"previousYear()\" title=\"\u53BB\u5E74\"></a>\n\n    <a class=\"{{ prefixCls }}-year-select\" role=\"button\" (click)=\"yearPanelShow.emit()\" title=\"\u9009\u62E9\u5E74\u4EFD\">\n      <span class=\"{{ prefixCls }}-year-select-content\">{{ value.getYear() }}</span>\n    </a>\n\n    <a class=\"{{ prefixCls }}-next-year-btn\" role=\"button\" (click)=\"nextYear()\" title=\"\u4E0B\u4E00\u5E74\"></a>\n  </div>\n  <div class=\"{{ prefixCls }}-body\">\n    <month-table\n      [prefixCls]=\"'thy-calendar'\"\n      [disabledDate]=\"disabledDate\"\n      [value]=\"value\"\n      (valueChange)=\"valueChange.emit($event)\"\n    ></month-table>\n  </div>\n</div>\n"
            },] }
];
MonthPanelComponent.propDecorators = {
    value: [{ type: Input }],
    disabledDate: [{ type: Input }],
    valueChange: [{ type: Output }],
    yearPanelShow: [{ type: Output }]
};

function transformDateValue(value) {
    if (!value) {
        return { value: null };
    }
    let withTime;
    if (value && typeof value === 'number') {
        value = convertDate(value);
    }
    if (value && instanceOfDateEntry(value)) {
        const { date, with_time } = value;
        value = date ? convertDate(date) : null;
        withTime = !!with_time;
    }
    if (value && instanceOfRangeEntry(value)) {
        const rangeValue = value;
        value = [];
        if (rangeValue.begin && rangeValue.end) {
            value[0] = convertDate(rangeValue.begin);
            value[1] = convertDate(rangeValue.end);
        }
    }
    return { value: value, withTime };
}
function convertDate(date) {
    if (typeof date === 'number') {
        if (date.toString().length < 13) {
            return fromUnixTime(date);
        }
        else {
            return new Date(date);
        }
    }
    else {
        return date;
    }
}
function hasValue(value) {
    if (Array.isArray(value)) {
        return !!value[0] && !!value[1];
    }
    else {
        return !!value;
    }
}
function makeValue(value, isRange = false) {
    if (isRange) {
        return value ? value.map(val => new TinyDate(val)) : [];
    }
    else {
        return value ? new TinyDate(value) : null;
    }
}

class DatePopupComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.panelModeChange = new EventEmitter();
        this.calendarChange = new EventEmitter();
        this.valueChange = new EventEmitter();
        this.resultOk = new EventEmitter(); // Emitted when done with date selecting
        this.showTimePickerChange = new EventEmitter();
        this.prefixCls = 'thy-calendar';
        this.showTimePicker = false;
        this.partTypeMap = { left: 0, right: 1 };
    }
    setProperty(key, value) {
        this[key] = value;
        this.cdr.markForCheck();
    }
    ngOnInit() {
        // Initialization for range properties to prevent errors while later assignment
        if (this.isRange) {
            ['panelMode', 'selectedValue', 'hoverValue'].forEach(prop => this.initialArray(prop));
        }
        if (this.defaultPickerValue && !hasValue(this.value)) {
            const { value } = transformDateValue(this.defaultPickerValue);
            this.value = makeValue(value, this.isRange);
            if (this.isRange) {
                this.reInitializeRangeRelatedValue();
            }
        }
        this.initDisabledDate();
    }
    ngOnChanges(changes) {
        if (this.isRange) {
            if (changes.value) {
                this.reInitializeRangeRelatedValue();
            }
        }
    }
    reInitializeRangeRelatedValue() {
        this.clearHoverValue();
        this.selectedValue = this.value;
        this.valueForRangeShow = this.normalizeRangeValue(this.value);
    }
    initDisabledDate() {
        let minDate;
        let maxDate;
        let disabledDateFn;
        if (this.minDate) {
            const { value } = transformDateValue(this.minDate);
            minDate = new TinyDate(value);
        }
        if (this.maxDate) {
            const { value } = transformDateValue(this.maxDate);
            maxDate = new TinyDate(value);
        }
        if (this.disabledDate) {
            disabledDateFn = this.disabledDate;
        }
        this.disabledDate = d => {
            let expression = false;
            if (minDate) {
                expression = d < minDate.startOfDay().nativeDate;
            }
            if (maxDate && !expression) {
                expression = d > maxDate.endOfDay().nativeDate;
            }
            if (disabledDateFn && typeof disabledDateFn === 'function' && !expression) {
                expression = disabledDateFn(d);
            }
            return expression;
        };
    }
    onShowTimePickerChange(show) {
        this.showTimePicker = show;
        this.showTimePickerChange.emit(show);
    }
    onClickOk() {
        this.setValue(this.value);
        this.valueChange.emit(this.value);
        this.resultOk.emit();
    }
    onClickRemove() {
        this.value = this.isRange ? [] : null;
        this.setValue(this.value);
        this.valueChange.emit(this.value);
    }
    onDayHover(value) {
        if (this.isRange && this.selectedValue[0] && !this.selectedValue[1]) {
            // When right value is selected, don't do hover
            const base = this.selectedValue[0]; // Use the left of selected value as the base to decide later hoverValue
            if (base.isBeforeDay(value)) {
                this.hoverValue = [base, value];
            }
            else {
                this.hoverValue = [value, base];
            }
        }
    }
    onPanelModeChange(mode, partType) {
        if (this.isRange) {
            this.panelMode[this.getPartTypeIndex(partType)] = mode;
        }
        else {
            this.panelMode = mode;
        }
        this.panelModeChange.emit(this.panelMode);
    }
    onHeaderChange(value, partType) {
        if (this.isRange) {
            this.valueForRangeShow[this.getPartTypeIndex(partType)] = value;
            this.valueForRangeShow = this.normalizeRangeValue(this.valueForRangeShow); // Should always take care of start/end
        }
        else {
            if (this.showTimePicker) {
                this.setValue(value);
            }
        }
    }
    onSelectTime(value, partType) {
        if (this.isRange) {
            // TODO:range picker set time
        }
        else {
            this.setValue(new TinyDate(value.nativeDate));
        }
    }
    changeValueFromSelect(value) {
        if (this.isRange) {
            const [left, right] = this.selectedValue;
            if ((!left && !right) || (left && right)) {
                // If totally full or empty, clean up && re-assign left first
                this.hoverValue = this.selectedValue = [value];
                this.selectedValue = [new TinyDate(startOfDay(this.selectedValue[0].nativeDate))];
                this.calendarChange.emit([this.selectedValue[0].clone()]);
            }
            else if (left && !right) {
                // If one of them is empty, assign the other one and sort, then set the final values
                this.clearHoverValue(); // Clean up
                this.setRangeValue('right', value);
                this.selectedValue = sortRangeValue(this.selectedValue); // Sort
                this.selectedValue = [
                    new TinyDate(startOfDay(this.selectedValue[0].nativeDate)),
                    new TinyDate(endOfDay(this.selectedValue[1].nativeDate))
                ];
                this.valueForRangeShow = this.normalizeRangeValue(this.selectedValue);
                this.setValue(this.cloneRangeDate(this.selectedValue));
                this.calendarChange.emit(this.cloneRangeDate(this.selectedValue));
            }
        }
        else {
            this.setValue(value);
        }
    }
    enablePrevNext(direction, partType) {
        if (this.isRange) {
            const [start, end] = this.valueForRangeShow;
            const showMiddle = !start.addMonths(1).isSame(end, 'month'); // One month diff then don't show middle prev/next
            if ((partType === 'left' && direction === 'next') || (partType === 'right' && direction === 'prev')) {
                return showMiddle;
            }
            return true;
        }
        else {
            return true;
        }
    }
    getPanelMode(partType) {
        if (this.isRange) {
            return this.panelMode[this.getPartTypeIndex(partType)];
        }
        else {
            return this.panelMode;
        }
    }
    getValueBySelector(partType) {
        if (this.isRange) {
            const valueShow = this.valueForRangeShow; // Use the real time value that without decorations when timepicker is shown up
            return valueShow[this.getPartTypeIndex(partType)];
        }
        else {
            return this.value;
        }
    }
    getPartTypeIndex(partType) {
        return this.partTypeMap[partType];
    }
    clearHoverValue() {
        this.hoverValue = [];
    }
    setValue(value) {
        this.value = value;
        if (!this.showTime || !this.showTimePicker) {
            this.valueChange.emit(this.value);
        }
    }
    normalizeRangeValue(value) {
        const [start, end] = value;
        const newStart = start || new TinyDate();
        const newEnd = end && end.isSameMonth(newStart) ? end.addMonths(1) : end || newStart.addMonths(1);
        return [newStart, newEnd];
    }
    // Renew and set a range value to trigger sub-component's change detection
    setRangeValue(partType, value) {
        const ref = (this.selectedValue = this.cloneRangeDate(this.selectedValue));
        ref[this.getPartTypeIndex(partType)] = value;
    }
    cloneRangeDate(value) {
        return [value[0] && value[0].clone(), value[1] && value[1].clone()];
    }
    initialArray(key) {
        if (!this[key] || !Array.isArray(this[key])) {
            this[key] = [];
        }
    }
}
DatePopupComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'date-popup',
                exportAs: 'datePopup',
                template: "<div class=\"{{ prefixCls }}-picker-container {{ className }}\">\n  <div\n    class=\"{{ prefixCls }} {{ showWeek ? prefixCls + '-week-number' : '' }}\n     {{ isRange ? prefixCls + '-range' : '' }}\"\n  >\n    <div class=\"{{ prefixCls }}-panel\">\n      <div class=\"{{ prefixCls }}-date-panel\">\n        <ng-container *ngIf=\"isRange; else tplSinglePart\">\n          <!-- Range Selectors -->\n          <ng-container *ngTemplateOutlet=\"tplRangePart; context: { partType: 'left' }\"></ng-container>\n          <ng-container *ngTemplateOutlet=\"tplRangePart; context: { partType: 'right' }\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngIf=\"!isRange\">\n          <!-- Single ONLY -->\n          <ng-container *ngTemplateOutlet=\"tplFooter\"></ng-container>\n        </ng-container>\n      </div>\n      <ng-container *ngIf=\"isRange\">\n        <!-- Range ONLY -->\n        <ng-container *ngTemplateOutlet=\"tplFooter\"></ng-container>\n      </ng-container>\n    </div>\n  </div>\n</div>\n\n<ng-template #tplInnerPopup let-partType=\"partType\">\n  <inner-popup\n    [showWeek]=\"showWeek\"\n    [panelMode]=\"getPanelMode(partType)\"\n    (panelModeChange)=\"onPanelModeChange($event, partType)\"\n    [value]=\"getValueBySelector(partType)\"\n    [disabledDate]=\"disabledDate\"\n    [dateRender]=\"dateRender\"\n    [selectedValue]=\"selectedValue\"\n    [hoverValue]=\"hoverValue\"\n    [enablePrev]=\"enablePrevNext('prev', partType)\"\n    [enableNext]=\"enablePrevNext('next', partType)\"\n    (dayHover)=\"onDayHover($event)\"\n    (selectDate)=\"changeValueFromSelect($event)\"\n    (headerChange)=\"onHeaderChange($event, partType)\"\n  ></inner-popup>\n</ng-template>\n\n<ng-template #tplFooter>\n  <calendar-footer\n    [showTime]=\"showTime\"\n    [mustShowTime]=\"mustShowTime\"\n    [value]=\"value\"\n    (showTimePickerChange)=\"onShowTimePickerChange($event)\"\n    (selectTime)=\"onSelectTime($event)\"\n    (clickOk)=\"onClickOk()\"\n    (clickRemove)=\"onClickRemove()\"\n  ></calendar-footer>\n</ng-template>\n\n<!-- Single ONLY -->\n<ng-template #tplSinglePart>\n  <div>\n    <ng-container *ngTemplateOutlet=\"tplInnerPopup\"></ng-container>\n  </div>\n</ng-template>\n\n<!-- Range ONLY -->\n<ng-template #tplRangePart let-partType=\"partType\">\n  <div class=\"{{ prefixCls }}-range-part {{ prefixCls }}-range-{{ partType }}\">\n    <div style=\"outline: none;\">\n      <ng-container *ngTemplateOutlet=\"tplInnerPopup; context: { partType: partType }\"></ng-container>\n    </div>\n  </div>\n</ng-template>\n"
            },] }
];
DatePopupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
DatePopupComponent.propDecorators = {
    isRange: [{ type: Input }],
    showWeek: [{ type: Input }],
    format: [{ type: Input }],
    disabledDate: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    showToday: [{ type: Input }],
    showTime: [{ type: Input }],
    mustShowTime: [{ type: Input }],
    dateRender: [{ type: Input }],
    className: [{ type: Input }],
    panelMode: [{ type: Input }],
    value: [{ type: Input }],
    defaultPickerValue: [{ type: Input }],
    panelModeChange: [{ type: Output }],
    calendarChange: [{ type: Output }],
    valueChange: [{ type: Output }],
    resultOk: [{ type: Output }],
    showTimePickerChange: [{ type: Output }]
};

class InnerPopupComponent {
    constructor() {
        this.panelModeChange = new EventEmitter();
        this.headerChange = new EventEmitter();
        this.selectDate = new EventEmitter();
        this.dayHover = new EventEmitter();
        this.prefixCls = 'thy-calendar';
    }
    ngOnChanges(changes) {
        if (changes.value && !this.value) {
            this.value = new TinyDate();
        }
    }
    // The value real changed to outside
    onSelectDate(date) {
        const value = date instanceof TinyDate ? date : new TinyDate(date);
        this.selectDate.emit(value);
    }
}
InnerPopupComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'inner-popup',
                exportAs: 'innerPopup',
                template: "<calendar-header\n  [(panelMode)]=\"panelMode\"\n  (panelModeChange)=\"panelModeChange.emit($event)\"\n  [(value)]=\"value\"\n  (valueChange)=\"headerChange.emit($event)\"\n  [enablePrev]=\"enablePrev\"\n  [enableNext]=\"enableNext\"\n></calendar-header>\n\n<div class=\"{{ prefixCls }}-body\">\n  <date-table\n    [showWeek]=\"showWeek\"\n    [value]=\"value\"\n    (valueChange)=\"onSelectDate($event)\"\n    showWeekNumber=\"false\"\n    [disabledDate]=\"disabledDate\"\n    [dateCellRender]=\"dateRender\"\n    [selectedValue]=\"selectedValue\"\n    [hoverValue]=\"hoverValue\"\n    (dayHover)=\"dayHover.emit($event)\"\n  ></date-table>\n</div>\n"
            },] }
];
InnerPopupComponent.ctorParameters = () => [];
InnerPopupComponent.propDecorators = {
    showWeek: [{ type: Input }],
    enablePrev: [{ type: Input }],
    enableNext: [{ type: Input }],
    disabledDate: [{ type: Input }],
    dateRender: [{ type: Input }],
    selectedValue: [{ type: Input }],
    hoverValue: [{ type: Input }],
    panelMode: [{ type: Input }],
    panelModeChange: [{ type: Output }],
    value: [{ type: Input }],
    headerChange: [{ type: Output }],
    selectDate: [{ type: Output }],
    dayHover: [{ type: Output }]
};

const MAX_ROW$1 = 4;
const MAX_COL$1 = 3;
class YearPanelComponent {
    constructor() {
        this.valueChange = new EventEmitter();
        this.decadePanelShow = new EventEmitter();
        this.prefixCls = 'thy-calendar-year-panel';
    }
    get currentYear() {
        return this.value.getYear();
    }
    get startYear() {
        return parseInt(`${this.currentYear / 10}`, 10) * 10;
    }
    get endYear() {
        return this.startYear + 9;
    }
    ngOnChanges(changes) {
        if (changes.value || changes.disabledDate) {
            this.render();
        }
    }
    previousDecade() {
        this.gotoYear(-10);
    }
    nextDecade() {
        this.gotoYear(10);
    }
    trackPanelYear(_index, yearData) {
        return yearData.content;
    }
    render() {
        if (this.value) {
            this.panelYears = this.makePanelYears();
        }
    }
    // Re-render panel content by the header's buttons (NOTE: Do not try to trigger final value change)
    gotoYear(amount) {
        this.value = this.value.addYears(amount);
        // this.valueChange.emit(this.value); // Do not trigger final value change
        this.render();
    }
    chooseYear(year) {
        this.value = this.value.setYear(year);
        this.valueChange.emit(this.value);
        this.render();
    }
    makePanelYears() {
        const years = [];
        const currentYear = this.currentYear;
        const startYear = this.startYear;
        const endYear = this.endYear;
        const previousYear = startYear - 1;
        let index = 0;
        for (let rowIndex = 0; rowIndex < MAX_ROW$1; rowIndex++) {
            years[rowIndex] = [];
            for (let colIndex = 0; colIndex < MAX_COL$1; colIndex++) {
                const year = previousYear + index;
                const content = String(year);
                const disabled = this.disabledDate ? this.disabledDate(this.value.setYear(year).nativeDate) : false;
                const cell = (years[rowIndex][colIndex] = {
                    disabled,
                    content,
                    year,
                    title: content,
                    isCurrent: year === currentYear,
                    isLowerThanStart: year < startYear,
                    isBiggerThanEnd: year > endYear,
                    classMap: null,
                    onClick: () => this.chooseYear(cell.year)
                });
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    [`${this.prefixCls}-selected-cell`]: cell.isCurrent,
                    [`${this.prefixCls}-cell-disabled`]: disabled,
                    [`${this.prefixCls}-last-decade-cell`]: cell.isLowerThanStart,
                    [`${this.prefixCls}-next-decade-cell`]: cell.isBiggerThanEnd
                };
                index++;
            }
        }
        return years;
    }
}
YearPanelComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'year-panel',
                exportAs: 'yearPanel',
                template: "<div class=\"{{ prefixCls }}\">\n  <div class=\"{{ prefixCls }}-header\">\n    <a class=\"{{ prefixCls }}-prev-decade-btn\" role=\"button\" (click)=\"previousDecade()\" title=\"\u4E0A\u4E00\u5E74\u4EE3\"></a>\n    <a class=\"{{ prefixCls }}-decade-select\" role=\"button\" (click)=\"decadePanelShow.emit()\" title=\"\u9009\u62E9\u5E74\u4EE3\">\n      <span class=\"{{ prefixCls }}-decade-select-content\"> {{ startYear }}-{{ endYear }} </span>\n    </a>\n\n    <a class=\"{{ prefixCls }}-next-decade-btn\" (click)=\"nextDecade()\" title=\"\u4E0B\u4E00\u5E74\u4EE3\" role=\"button\"></a>\n  </div>\n  <div class=\"{{ prefixCls }}-body\">\n    <table class=\"{{ prefixCls }}-table\" cellSpacing=\"0\" role=\"grid\">\n      <tbody class=\"{{ prefixCls }}-tbody\">\n        <tr *ngFor=\"let row of panelYears\" role=\"row\">\n          <td\n            *ngFor=\"let yearCell of row; trackBy: trackPanelYear\"\n            role=\"gridcell\"\n            title=\"{{ yearCell.title }}\"\n            (click)=\"yearCell.disabled ? null : yearCell.onClick()\"\n            [ngClass]=\"yearCell.classMap\"\n          >\n            <a class=\"{{ prefixCls }}-year\">{{ yearCell.content }}</a>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</div>\n"
            },] }
];
YearPanelComponent.ctorParameters = () => [];
YearPanelComponent.propDecorators = {
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    disabledDate: [{ type: Input }],
    decadePanelShow: [{ type: Output }]
};

const MAX_ROW = 4;
const MAX_COL = 3;
class MonthTableComponent {
    constructor(dateHelper) {
        this.dateHelper = dateHelper;
        this.value = new TinyDate();
        this.prefixCls = 'thy-calendar';
        this.valueChange = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes.value || changes.disabledDate) {
            this.render();
        }
    }
    trackYear(_index) {
        return this.value ? this.value.getYear() : _index;
    }
    trackPanelMonth(_index, monthData) {
        return monthData.content;
    }
    render() {
        if (this.value) {
            this.panelMonths = this.makePanelMonths();
        }
    }
    makePanelMonths() {
        const months = [];
        const currentMonth = this.value.getMonth();
        const today = new TinyDate();
        let monthValue = 0;
        for (let rowIndex = 0; rowIndex < MAX_ROW; rowIndex++) {
            months[rowIndex] = [];
            for (let colIndex = 0; colIndex < MAX_COL; colIndex++) {
                const month = this.value.setMonth(monthValue);
                const disabled = this.disabledDate ? this.disabledDate(this.value.setMonth(monthValue).nativeDate) : false;
                const content = this.dateHelper.format(month.nativeDate, 'MMMM');
                const cell = (months[rowIndex][colIndex] = {
                    value: month.nativeDate,
                    disabled,
                    content,
                    month: monthValue,
                    title: content,
                    classMap: null,
                    onClick: () => this.chooseMonth(cell.month) // don't use monthValue here
                });
                cell.classMap = {
                    [`${this.prefixCls}-month-panel-cell`]: true,
                    [`${this.prefixCls}-month-panel-cell-disabled`]: disabled,
                    [`${this.prefixCls}-month-panel-selected-cell`]: monthValue === currentMonth,
                    [`${this.prefixCls}-month-panel-current-cell`]: today.getYear() === this.value.getYear() && monthValue === today.getMonth()
                };
                monthValue++;
            }
        }
        return months;
    }
    chooseMonth(month) {
        this.value = this.value.setMonth(month);
        this.valueChange.emit(this.value);
        this.render();
    }
}
MonthTableComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'month-table',
                exportAs: 'monthTable',
                template: "<table class=\"{{ prefixCls }}-month-panel-table\" cellSpacing=\"0\" role=\"grid\">\n  <tbody class=\"{{ prefixCls }}-month-panel-tbody\">\n    <tr *ngFor=\"let row of panelMonths; trackBy: trackYear\" role=\"row\">\n      <td\n        *ngFor=\"let monthCell of row; trackBy: trackPanelMonth\"\n        role=\"gridcell\"\n        title=\"{{ monthCell.title }}\"\n        (click)=\"monthCell.disabled ? null : monthCell.onClick()\"\n        [ngClass]=\"monthCell.classMap\"\n      >\n        <ng-container [ngSwitch]=\"prefixCls\">\n          <ng-container *ngSwitchCase=\"'thy-calendar'\">\n            <a class=\"{{ prefixCls }}-month-panel-month\">{{ monthCell.content }}</a>\n          </ng-container>\n        </ng-container>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"
            },] }
];
MonthTableComponent.ctorParameters = () => [
    { type: DateHelperService }
];
MonthTableComponent.propDecorators = {
    value: [{ type: Input }],
    prefixCls: [{ type: Input }],
    valueChange: [{ type: Output }],
    disabledDate: [{ type: Input }]
};

const DATE_ROW_NUM = 6;
const DATE_COL_NUM = 7;
class DateTableComponent {
    constructor(dateHelper) {
        this.dateHelper = dateHelper;
        this.prefixCls = 'thy-calendar';
        this.showWeek = false;
        this.dayHover = new EventEmitter(); // Emitted when hover on a day by mouse enter
        this.valueChange = new EventEmitter();
    }
    set value(date) {
        this._value = date;
    }
    get value() {
        return this._value;
    }
    ngOnChanges(changes) {
        if (this.isDateRealChange(changes.value) ||
            this.isDateRealChange(changes.selectedValue) ||
            this.isDateRealChange(changes.hoverValue)) {
            this.render();
        }
    }
    isDateRealChange(change) {
        if (change) {
            const previousValue = change.previousValue;
            const currentValue = change.currentValue;
            if (Array.isArray(currentValue)) {
                return (!Array.isArray(previousValue) ||
                    currentValue.length !== previousValue.length ||
                    currentValue.some((value, index) => {
                        const previousTinyDate = previousValue[index];
                        return previousTinyDate instanceof TinyDate ? previousTinyDate.isSameDay(value) : previousTinyDate !== value;
                    }));
            }
            else {
                return !this.isSameDate(previousValue, currentValue);
            }
        }
        return false;
    }
    isSameDate(left, right) {
        return (!left && !right) || (left && right && right.isSameDay(left));
    }
    render() {
        if (this.value) {
            this.headWeekDays = this.makeHeadWeekDays();
            this.weekRows = this.makeWeekRows();
        }
    }
    changeValueFromInside(value) {
        // Only change date not change time
        const newValue = this.value
            .setYear(value.getYear())
            .setMonth(value.getMonth())
            .setDate(value.getDate());
        this.valueChange.emit(newValue);
    }
    makeHeadWeekDays() {
        const weekDays = [];
        const start = this.value.calendarStart({ weekStartsOn: this.dateHelper.getFirstDayOfWeek() });
        for (let colIndex = 0; colIndex < DATE_COL_NUM; colIndex++) {
            const day = start.addDays(colIndex);
            weekDays[colIndex] = {
                short: this.dateHelper.format(day.nativeDate, this.dateHelper.relyOnDatePipe ? 'E' : 'ddd'),
                veryShort: this.dateHelper.format(day.nativeDate, this.getVeryShortWeekFormat()) // eg. 二
            };
        }
        return weekDays;
    }
    getVeryShortWeekFormat() {
        if (this.dateHelper.relyOnDatePipe) {
            return 'EEEEE'; // eg. 二
        }
        return 'dd';
    }
    makeWeekRows() {
        const weekRows = [];
        const firstDayOfMonth = this.value.calendarStart({ weekStartsOn: this.dateHelper.getFirstDayOfWeek() });
        for (let week = 0; week < DATE_ROW_NUM; week++) {
            const weekStart = firstDayOfMonth.addDays(week * 7);
            const row = {
                isActive: false,
                isCurrent: false,
                dateCells: [],
                year: weekStart.getYear()
            };
            for (let day = 0; day < 7; day++) {
                const date = weekStart.addDays(day);
                const dateFormat = this.dateHelper.relyOnDatePipe ? 'longDate' : 'YYYY-MM-DD';
                const title = this.dateHelper.format(date.nativeDate, dateFormat);
                const label = this.dateHelper.format(date.nativeDate, this.dateHelper.relyOnDatePipe ? 'dd' : 'DD');
                const cell = {
                    value: date.nativeDate,
                    label: label,
                    isSelected: false,
                    isDisabled: false,
                    isToday: false,
                    title: title,
                    dateCellRender: valueFunctionProp(this.dateCellRender, date),
                    content: `${date.getDate()}`,
                    onClick: () => this.changeValueFromInside(date),
                    // 暂时用不到鼠标事件的交互,在html这种删除了
                    onMouseEnter: () => this.dayHover.emit(date)
                };
                if (this.showWeek && !row.weekNum) {
                    row.weekNum = this.dateHelper.getISOWeek(date.nativeDate);
                }
                if (date.isToday()) {
                    cell.isToday = true;
                    row.isCurrent = true;
                }
                if (Array.isArray(this.selectedValue)) {
                    // Range selections
                    const rangeValue = this.hoverValue && this.hoverValue.length ? this.hoverValue : this.selectedValue;
                    const start = rangeValue[0];
                    const end = rangeValue[1];
                    if (start) {
                        if (start.isSameDay(date)) {
                            cell.isSelectedStartDate = true;
                            cell.isSelected = true;
                            row.isActive = true;
                        }
                        if (end) {
                            if (end.isSameDay(date)) {
                                cell.isSelectedEndDate = true;
                                cell.isSelected = true;
                                row.isActive = true;
                            }
                            else if (date.isAfterDay(start) && date.isBeforeDay(end)) {
                                cell.isInRange = true;
                            }
                        }
                    }
                }
                else if (date.isSameDay(this.value)) {
                    cell.isSelected = true;
                    row.isActive = true;
                }
                if (this.disabledDate && this.disabledDate(date.nativeDate)) {
                    cell.isDisabled = true;
                }
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    [`${this.prefixCls}-today`]: cell.isToday,
                    [`${this.prefixCls}-last-month-cell`]: date.isBeforeMonth(this.value),
                    [`${this.prefixCls}-next-month-btn-day`]: date.isAfterMonth(this.value),
                    [`${this.prefixCls}-selected-day`]: cell.isSelected,
                    [`${this.prefixCls}-disabled-cell`]: cell.isDisabled,
                    [`${this.prefixCls}-selected-start-date`]: !!cell.isSelectedStartDate,
                    [`${this.prefixCls}-selected-end-date`]: !!cell.isSelectedEndDate,
                    [`${this.prefixCls}-in-range-cell`]: !!cell.isInRange
                };
                row.dateCells.push(cell);
            }
            row.classMap = {
                [`${this.prefixCls}-current-week`]: row.isCurrent,
                [`${this.prefixCls}-active-week`]: row.isActive
            };
            weekRows.push(row);
        }
        return weekRows;
    }
    trackByDateFn(_index, item) {
        return `${item.title}`;
    }
    trackByWeekFn(_index, item) {
        return `${item.year}-${item.weekNum}`;
    }
}
DateTableComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'date-table',
                exportAs: 'dateTable',
                template: "<table class=\"{{ prefixCls }}-table\" cellSpacing=\"0\" role=\"grid\">\n  <thead>\n    <tr role=\"row\">\n      <th *ngIf=\"showWeek\" role=\"columnheader\" class=\"{{ prefixCls }}-column-header {{ prefixCls }}-week-number-header\">\n        <span class=\"{{ prefixCls }}-column-header-inner\">x</span>\n      </th>\n      <th *ngFor=\"let cell of headWeekDays\" role=\"columnheader\" title=\"{{ cell.short }}\" class=\"{{ prefixCls }}-column-header\">\n        <span *ngIf=\"prefixCls === 'thy-calendar'\" class=\"{{ prefixCls }}-column-header-inner\">{{ cell.veryShort }}</span>\n        <span *ngIf=\"prefixCls === 'thy-calendar-full'\" class=\"{{ prefixCls }}-column-header-inner\">\u5468{{ cell.veryShort }}</span>\n      </th>\n    </tr>\n  </thead>\n  <tbody class=\"{{ prefixCls }}-tbody\">\n    <tr *ngFor=\"let row of weekRows; trackBy: trackByWeekFn\" [ngClass]=\"row.classMap\" role=\"row\">\n      <td *ngIf=\"row.weekNum\" role=\"gridcell\" class=\"{{ prefixCls }}-week-number-cell\">\n        {{ row.weekNum }}\n      </td>\n      <!-- \u5728td\u4E2D\u5220\u9664\u4E86\u9F20\u6807\u4E8B\u4EF6 -->\n      <!-- \u53BB\u6389tooltip\uFF0C\u6545\u53BB\u6389title\u5C5E\u6027 -->\n      <td\n        *ngFor=\"let cell of row.dateCells; trackBy: trackByDateFn\"\n        role=\"gridcell\"\n        [ngClass]=\"cell.classMap\"\n        (click)=\"cell.isDisabled ? null : cell.onClick()\"\n        date-table-cell\n        [prefixCls]=\"prefixCls\"\n        [cell]=\"cell\"\n      ></td>\n    </tr>\n  </tbody>\n</table>\n"
            },] }
];
DateTableComponent.ctorParameters = () => [
    { type: DateHelperService }
];
DateTableComponent.propDecorators = {
    prefixCls: [{ type: Input }],
    selectedValue: [{ type: Input }],
    hoverValue: [{ type: Input }],
    value: [{ type: Input }],
    showWeek: [{ type: Input }],
    disabledDate: [{ type: Input }],
    dateCellRender: [{ type: Input }],
    dayHover: [{ type: Output }],
    valueChange: [{ type: Output }]
};

class DateTableCellComponent {
    constructor() {
        this.isTemplateRef = isTemplateRef;
        this.isNonEmptyString = (v) => isEmpty(v) && isString(v);
    }
}
DateTableCellComponent.decorators = [
    { type: Component, args: [{
                selector: '[date-table-cell]',
                exportAs: 'dateTableCell',
                template: "<ng-container [ngSwitch]=\"prefixCls\">\n  <ng-container *ngSwitchCase=\"'thy-calendar'\">\n    <ng-container [ngSwitch]=\"true\">\n      <ng-container *ngSwitchCase=\"isTemplateRef(cell.dateCellRender)\">\n        <ng-container *ngTemplateOutlet=\"cell.dateCellRender; context: { $implicit: cell.value }\"></ng-container>\n      </ng-container>\n      <ng-container *ngSwitchCase=\"isNonEmptyString(cell.dateCellRender)\">\n        <span [innerHTML]=\"cell.dateCellRender\"></span>\n      </ng-container>\n      <ng-container *ngSwitchDefault>\n        <div class=\"{{ prefixCls }}-date\" [attr.aria-selected]=\"cell.isSelected\" [attr.aria-disabled]=\"cell.isDisabled\">\n          {{ cell.content }}\n        </div>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'thy-calendar-full'\">\n    <div\n      tabindex=\"0\"\n      class=\"{{ prefixCls }}-date thy-calendar-full-cell-inner\"\n      [class.thy-calendar-full-calendar-date-today]=\"cell.isToday\"\n    >\n      <ng-container *ngIf=\"cell.fullCellRender; else defaultCell\">\n        <ng-container *ngTemplateOutlet=\"$any(cell.fullCellRender); context: { $implicit: cell.value }\"> </ng-container>\n      </ng-container>\n      <ng-template #defaultCell>\n        <div class=\"{{ prefixCls }}-date-value\">\n          <span class=\"{{ prefixCls }}-date-value-today-text\">\n            <span class=\"{{ prefixCls }}-date-value-text\">{{ cell.content }}</span>\n          </span>\n        </div>\n        <div class=\"{{ prefixCls }}-date-content\">\n          <ng-container *ngTemplateOutlet=\"$any(cell.dateCellRender); context: { $implicit: cell.value }\"> </ng-container>\n        </div>\n      </ng-template>\n    </div>\n  </ng-container>\n</ng-container>\n"
            },] }
];
DateTableCellComponent.propDecorators = {
    prefixCls: [{ type: Input }],
    cell: [{ type: Input }]
};

class LibPackerModule {
}
LibPackerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ThyButtonModule, ThyIconModule, ThyTimePickerModule],
                exports: [
                    CalendarHeaderComponent,
                    CalendarFooterComponent,
                    DateTableComponent,
                    YearPanelComponent,
                    MonthTableComponent,
                    MonthPanelComponent,
                    DecadePanelComponent,
                    InnerPopupComponent,
                    DatePopupComponent,
                    DateTableCellComponent
                ],
                declarations: [
                    CalendarHeaderComponent,
                    CalendarFooterComponent,
                    DateTableComponent,
                    YearPanelComponent,
                    MonthTableComponent,
                    MonthPanelComponent,
                    DecadePanelComponent,
                    InnerPopupComponent,
                    DatePopupComponent,
                    DateTableCellComponent
                ]
            },] }
];

class ThyPickerComponent {
    constructor(changeDetector, dateHelper) {
        this.changeDetector = changeDetector;
        this.dateHelper = dateHelper;
        this.isRange = false;
        this.open = undefined;
        this.placement = 'bottomLeft';
        this.valueChange = new EventEmitter();
        this.openChange = new EventEmitter(); // Emitted when overlay's open state change
        this.prefixCls = 'thy-calendar';
        this.animationOpenState = false;
        this.overlayOpen = false; // Available when "open"=undefined
        this.overlayPositions = getFlexiblePositions(this.placement, 4);
    }
    get realOpenState() {
        // The value that really decide the open state of overlay
        return this.isOpenHandledByUser() ? !!this.open : this.overlayOpen;
    }
    ngAfterViewInit() {
        this.overlayPositions = getFlexiblePositions(this.placement, 4);
        if (this.autoFocus) {
            this.focus();
        }
    }
    focus() {
        this.pickerInput.nativeElement.focus();
    }
    showOverlay() {
        if (!this.realOpenState) {
            this.overlayOpen = true;
            if (this.realOpenState) {
                this.animationOpenState = true;
            }
            this.openChange.emit(this.overlayOpen);
            setTimeout(() => {
                if (this.cdkConnectedOverlay && this.cdkConnectedOverlay.overlayRef) {
                    this.cdkConnectedOverlay.overlayRef.updatePosition();
                }
            });
        }
    }
    hideOverlay() {
        if (this.realOpenState) {
            this.overlayOpen = false;
            if (!this.realOpenState) {
                this.animationOpenState = false;
            }
            this.openChange.emit(this.overlayOpen);
            this.focus();
        }
    }
    onClickInputBox() {
        if (!this.disabled && !this.readonly && !this.isOpenHandledByUser()) {
            this.showOverlay();
        }
    }
    onClickBackdrop() {
        this.hideOverlay();
    }
    onOverlayDetach() {
        this.hideOverlay();
    }
    onPositionChange(position) {
        this.changeDetector.detectChanges();
    }
    onClickClear(event) {
        event.preventDefault();
        event.stopPropagation();
        this.value = this.isRange ? [] : null;
        this.valueChange.emit(this.value);
    }
    getPartTypeIndex(partType) {
        return { left: 0, right: 1 }[partType];
    }
    isEmptyValue(value) {
        if (value === null) {
            return true;
        }
        else if (this.isRange) {
            return !value || !Array.isArray(value) || value.every(val => !val);
        }
        else {
            return !value;
        }
    }
    // Whether open state is permanently controlled by user himself
    isOpenHandledByUser() {
        return this.open !== undefined;
    }
    getReadableValue() {
        let value;
        if (this.isRange) {
            const start = this.value[0] ? this.dateHelper.format(this.value[0].nativeDate, this.format) : '';
            const end = this.value[1] ? this.dateHelper.format(this.value[1].nativeDate, this.format) : '';
            return start && end ? `${start} ~ ${end}` : null;
        }
        else {
            value = this.value;
            return value ? this.dateHelper.format(value.nativeDate, this.format) : null;
        }
    }
    getPlaceholder() {
        return this.isRange && this.placeholder && Array.isArray(this.placeholder)
            ? this.placeholder.join(' ~ ')
            : this.placeholder;
    }
}
ThyPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'thy-picker',
                exportAs: 'thyPicker',
                template: "<span\n  cdkOverlayOrigin\n  #origin=\"cdkOverlayOrigin\"\n  class=\"{{ prefixCls }}-picker {{ size ? prefixCls + '-picker-' + size : '' }} {{ className }}\"\n  (click)=\"onClickInputBox()\"\n>\n  <ng-container>\n    <input\n      #pickerInput\n      thyInput\n      class=\"form-control-{{ size }} form-control {{ prefixCls }}-picker-input\"\n      [thySize]=\"size\"\n      [class.thy-input-disabled]=\"disabled\"\n      [class.thy-input-readonly]=\"readonly\"\n      [disabled]=\"disabled\"\n      readonly\n      value=\"{{ getReadableValue() }}\"\n      placeholder=\"{{ getPlaceholder() }}\"\n    />\n    <ng-container *ngTemplateOutlet=\"tplRightRest\"></ng-container>\n  </ng-container>\n</span>\n\n<!-- Right operator icons -->\n<ng-template #tplRightRest>\n  <span class=\"{{ prefixCls }}-picker-clear\">\n    <thy-icon\n      thyIconName=\"close-circle-bold-fill\"\n      *ngIf=\"!disabled && !isEmptyValue(value) && allowClear && !readonly\"\n      (click)=\"onClickClear($event)\"\n      ngClass=\"remove-link remove-link-{{ size }}\"\n    ></thy-icon>\n  </span>\n  <span class=\"{{ prefixCls }}-picker-icon\">\n    <thy-icon [thyIconName]=\"suffixIcon\" ngClass=\"remove-link-{{ size }}\"></thy-icon>\n  </span>\n</ng-template>\n\n<!-- Overlay -->\n<ng-template\n  cdkConnectedOverlay\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"realOpenState\"\n  [cdkConnectedOverlayHasBackdrop]=\"!isOpenHandledByUser()\"\n  [cdkConnectedOverlayPositions]=\"overlayPositions\"\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  (positionChange)=\"onPositionChange($event)\"\n  (backdropClick)=\"onClickBackdrop()\"\n  (detach)=\"onOverlayDetach()\"\n>\n  <div style=\"position: relative;\">\n    <!-- Compatible for overlay that not support offset dynamically and immediately -->\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ThyPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DateHelperService }
];
ThyPickerComponent.propDecorators = {
    isRange: [{ type: Input }],
    open: [{ type: Input }],
    disabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    readonly: [{ type: Input }],
    allowClear: [{ type: Input }],
    autoFocus: [{ type: Input }],
    className: [{ type: Input }],
    format: [{ type: Input }],
    size: [{ type: Input }],
    value: [{ type: Input }],
    suffixIcon: [{ type: Input }],
    placement: [{ type: Input }],
    valueChange: [{ type: Output }],
    openChange: [{ type: Output }],
    origin: [{ type: ViewChild, args: ['origin', { static: true },] }],
    cdkConnectedOverlay: [{ type: ViewChild, args: [CdkConnectedOverlay, { static: true },] }],
    pickerInput: [{ type: ViewChild, args: ['pickerInput', { static: true },] }]
};

class AbstractPickerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.thyAllowClear = true;
        this.thyAutoFocus = false;
        this.thyDisabled = false;
        this.thySize = 'default';
        // tslint:disable-next-line: max-line-length
        this.thyAutoStartAndEnd = false; // only for range picker, Whether to automatically take the beginning and ending unixTime of the day
        this.thyDefaultPickerValue = null;
        this.thySuffixIcon = 'calendar';
        this.thyOpenChange = new EventEmitter();
        this.isRange = false;
        this.destroyed$ = new Subject();
        this.isCustomPlaceHolder = false;
        this.onlyEmitDate = false;
        this.onChangeFn = () => void 0;
        this.onTouchedFn = () => void 0;
    }
    get realOpenState() {
        return this.picker.realOpenState;
    }
    initValue() {
        this.thyValue = this.isRange ? [] : null;
    }
    ngOnInit() {
        this.setDefaultPlaceHolder();
        this.initValue();
    }
    ngOnChanges(changes) {
        if (changes.thyPlaceHolder && changes.thyPlaceHolder.firstChange && typeof this.thyPlaceHolder !== 'undefined') {
            this.isCustomPlaceHolder = true;
        }
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    closeOverlay() {
        this.picker.hideOverlay();
    }
    onValueChange(originalValue) {
        this.setFormatRule();
        this.thyValue = originalValue;
        if (this.isRange) {
            const vAsRange = this.thyValue;
            let value = { begin: null, end: null };
            if (vAsRange.length) {
                const [begin, end] = vAsRange;
                if (this.thyAutoStartAndEnd) {
                    value = {
                        begin: begin.startOfDay().getUnixTime(),
                        end: end.endOfDay().getUnixTime()
                    };
                }
                else {
                    value = {
                        begin: begin.getUnixTime(),
                        end: end.getUnixTime()
                    };
                }
            }
            this.onChangeFn(value);
        }
        else {
            const value = { date: null, with_time: this.withTime ? 1 : 0 };
            if (this.thyValue) {
                value.date = this.thyValue.getUnixTime();
            }
            if (this.onlyEmitDate) {
                this.onChangeFn(value.date);
            }
            else {
                this.onChangeFn(value);
            }
        }
        this.onTouchedFn();
    }
    setFormatRule() {
        if (!this.thyFormat) {
            if (this.withTime) {
                this.thyFormat = 'yyyy-MM-dd HH:mm';
            }
            else {
                if (!this.onlyEmitDate) {
                    this.thyFormat = 'yyyy-MM-dd';
                }
            }
        }
    }
    onOpenChange(open) {
        this.thyOpen = open;
        this.thyOpenChange.emit(open);
    }
    writeValue(originalValue) {
        const { value, withTime } = transformDateValue(originalValue);
        this.setValue(value);
        this.setTimePickerState(withTime);
        this.onlyEmitDate = typeof withTime === 'undefined';
        this.originWithTime = withTime;
        this.setFormatRule();
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedFn = fn;
    }
    setTimePickerState(withTime) {
        this.withTime = withTime;
    }
    setDisabledState(disabled) {
        this.thyDisabled = disabled;
        this.cdr.markForCheck();
    }
    setDefaultPlaceHolder() {
        if (!this.isCustomPlaceHolder) {
            this.thyPlaceHolder = this.isRange ? ['开始日期', '结束日期'] : '请选择日期';
        }
        this.cdr.markForCheck();
    }
    setValue(value) {
        this.thyValue = makeValue(value, this.isRange);
    }
}
AbstractPickerComponent.decorators = [
    { type: Directive }
];
AbstractPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
AbstractPickerComponent.propDecorators = {
    thyAllowClear: [{ type: Input }],
    thyAutoFocus: [{ type: Input }],
    thyDisabled: [{ type: Input }],
    thyOpen: [{ type: Input }],
    thyDisabledDate: [{ type: Input }],
    thyMinDate: [{ type: Input }],
    thyMaxDate: [{ type: Input }],
    thyPlaceHolder: [{ type: Input }],
    thyReadonly: [{ type: Input }],
    thyOriginClassName: [{ type: Input }],
    thyPanelClassName: [{ type: Input }],
    thySize: [{ type: Input }],
    thyFormat: [{ type: Input }],
    thyAutoStartAndEnd: [{ type: Input }],
    thyDefaultPickerValue: [{ type: Input }],
    thySuffixIcon: [{ type: Input }],
    thyOpenChange: [{ type: Output }],
    picker: [{ type: ViewChild, args: [ThyPickerComponent, { static: true },] }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], AbstractPickerComponent.prototype, "thyAllowClear", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], AbstractPickerComponent.prototype, "thyAutoFocus", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Object)
], AbstractPickerComponent.prototype, "thyDisabled", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], AbstractPickerComponent.prototype, "thyOpen", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], AbstractPickerComponent.prototype, "thyReadonly", void 0);

class BasePickerComponent extends AbstractPickerComponent {
    constructor(cdr) {
        super(cdr);
        this.showWeek = false;
        this.thyOnPanelChange = new EventEmitter();
        this.thyOnCalendarChange = new EventEmitter();
        this.thyMustShowTime = false;
        this.thyPlacement = 'bottomLeft';
        this.thyOnOk = new EventEmitter();
    }
    get thyShowTime() {
        return this._showTime;
    }
    set thyShowTime(value) {
        this._showTime = typeof value === 'object' ? value : coerceBooleanProperty(value);
    }
    ngOnInit() {
        super.ngOnInit();
        if (!this.thyFormat) {
            if (this.showWeek) {
                this.thyFormat = 'yyyy-ww';
            }
            else {
                this.thyFormat = this.thyShowTime ? 'yyyy-MM-dd HH:mm' : 'yyyy-MM-dd';
            }
        }
        this.setDefaultTimePickerState();
    }
    onValueChange(value) {
        this.restoreTimePickerState(value);
        super.onValueChange(value);
        this.closeOverlay();
    }
    // Displays the time directly when the time must be displayed by default
    setDefaultTimePickerState() {
        this.withTime = this.thyMustShowTime;
    }
    // Restore after clearing time to select whether the original picker time is displayed or not
    restoreTimePickerState(value) {
        if (!value) {
            this.withTime = this.thyMustShowTime || this.originWithTime;
        }
    }
    // Emit thyOnCalendarChange when select date by thy-range-picker
    onCalendarChange(value) {
        if (this.isRange) {
            const rangeValue = value.map(x => x.nativeDate);
            this.thyOnCalendarChange.emit(rangeValue);
        }
    }
    onShowTimePickerChange(show) {
        this.withTime = show;
    }
    onResultOk() {
        if (this.isRange) {
            const value = this.thyValue;
            if (value.length) {
                this.thyOnOk.emit([value[0].nativeDate, value[1].nativeDate]);
            }
            else {
                this.thyOnOk.emit([]);
            }
        }
        else {
            if (this.thyValue) {
                this.thyOnOk.emit(this.thyValue.nativeDate);
            }
            else {
                this.thyOnOk.emit(null);
            }
        }
        this.closeOverlay();
    }
    onOpenChange(open) {
        this.thyOpenChange.emit(open);
    }
}
BasePickerComponent.decorators = [
    { type: Component, args: [{
                template: ``
            },] }
];
BasePickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
BasePickerComponent.propDecorators = {
    thyDateRender: [{ type: Input }],
    thyMode: [{ type: Input }],
    thyOnPanelChange: [{ type: Output }],
    thyOnCalendarChange: [{ type: Output }],
    thyShowTime: [{ type: Input }],
    thyMustShowTime: [{ type: Input }],
    thyPlacement: [{ type: Input }],
    thyOnOk: [{ type: Output }]
};

class HeaderPickerComponent extends AbstractPickerComponent {
    constructor(cdr) {
        super(cdr);
    }
    ngOnInit() {
        super.ngOnInit();
        this.panelMode = this.endPanelMode;
        const allHeaderPanels = ['decade', 'year', 'month'];
        this.supportPanels = allHeaderPanels.slice(0, allHeaderPanels.indexOf(this.endPanelMode) + 1);
    }
    onPanelModeChange(mode) {
        if (this.supportPanels.indexOf(mode) > -1) {
            this.panelMode = mode;
        }
        else {
            // Since the default "click year" logic can be "year panel" -> "date panel", we need force to the end panel otherwise
            this.panelMode = this.endPanelMode;
        }
    }
    onChooseValue(mode, value) {
        if (this.endPanelMode === mode) {
            super.onValueChange(value);
            this.closeOverlay();
        }
    }
    onOpenChange(open) {
        if (!open) {
            this.cleanUp();
        }
        this.thyOpenChange.emit(open);
    }
    // Restore some initial props to let open as new in next time
    cleanUp() {
        this.panelMode = this.endPanelMode;
    }
}
HeaderPickerComponent.decorators = [
    { type: Component, args: [{
                template: ``
            },] }
];
HeaderPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
HeaderPickerComponent.propDecorators = {
    thyPlaceHolder: [{ type: Input }],
    thyDefaultValue: [{ type: Input }],
    thyFormat: [{ type: Input }]
};

class ThyDatePickerComponent extends BasePickerComponent {
    constructor(cdr, renderer, elementRef) {
        super(cdr);
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.isRange = false;
        renderer.addClass(elementRef.nativeElement, 'thy-calendar-picker');
    }
}
ThyDatePickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'thy-date-picker',
                exportAs: 'thyDatePicker',
                template: "<thy-picker\n  [isRange]=\"isRange\"\n  [value]=\"thyValue\"\n  (valueChange)=\"onValueChange($event)\"\n  [open]=\"thyOpen\"\n  [disabled]=\"thyDisabled\"\n  [format]=\"thyFormat\"\n  [allowClear]=\"thyAllowClear\"\n  [className]=\"thyOriginClassName\"\n  [autoFocus]=\"thyAutoFocus\"\n  [placeholder]=\"thyPlaceHolder\"\n  [readonly]=\"thyReadonly\"\n  [size]=\"thySize\"\n  [suffixIcon]=\"thySuffixIcon\"\n  [placement]=\"thyPlacement\"\n  (openChange)=\"onOpenChange($event)\"\n>\n  <date-popup\n    *ngIf=\"realOpenState\"\n    [isRange]=\"isRange\"\n    [showWeek]=\"showWeek\"\n    [panelMode]=\"thyMode\"\n    [defaultPickerValue]=\"thyDefaultPickerValue\"\n    (panelModeChange)=\"thyOnPanelChange.emit($event)\"\n    (showTimePickerChange)=\"onShowTimePickerChange($event)\"\n    [value]=\"thyValue\"\n    (valueChange)=\"onValueChange($event)\"\n    (calendarChange)=\"onCalendarChange($event)\"\n    [showTime]=\"thyShowTime\"\n    [mustShowTime]=\"withTime\"\n    [format]=\"thyFormat\"\n    [dateRender]=\"thyDateRender\"\n    [disabledDate]=\"thyDisabledDate\"\n    [minDate]=\"thyMinDate\"\n    [maxDate]=\"thyMaxDate\"\n    [className]=\"thyPanelClassName\"\n    (resultOk)=\"onResultOk()\"\n  ></date-popup>\n</thy-picker>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyDatePickerComponent)
                    }
                ]
            },] }
];
ThyDatePickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];

class ThyMonthPickerComponent extends HeaderPickerComponent {
    constructor(cdr, renderer, elementRef) {
        super(cdr);
        this.thyFormat = 'yyyy-MM';
        this.endPanelMode = 'month';
        renderer.addClass(elementRef.nativeElement, 'thy-calendar-picker');
    }
}
ThyMonthPickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'thy-month-picker',
                exportAs: 'thyMonthPicker',
                template: "<thy-picker\n  [isRange]=\"false\"\n  [value]=\"thyValue\"\n  (valueChange)=\"onValueChange($event)\"\n  [open]=\"thyOpen\"\n  [disabled]=\"thyDisabled\"\n  [format]=\"thyFormat\"\n  [allowClear]=\"thyAllowClear\"\n  [className]=\"thyOriginClassName\"\n  [autoFocus]=\"thyAutoFocus\"\n  [placeholder]=\"thyPlaceHolder\"\n  [readonly]=\"thyReadonly\"\n  [size]=\"thySize\"\n  [suffixIcon]=\"thySuffixIcon\"\n  (openChange)=\"onOpenChange($event)\"\n>\n  <div *ngIf=\"realOpenState\">\n    <div class=\"thy-calendar-picker-container thy-calendar thy-calendar-month {{ thyPanelClassName }}\">\n      <div class=\"thy-calendar-header-wrap\">\n        <calendar-header\n          [disabledMonth]=\"thyDisabledDate\"\n          [disabledYear]=\"thyDisabledDate\"\n          [panelMode]=\"panelMode\"\n          (panelModeChange)=\"onPanelModeChange($event)\"\n          [value]=\"thyValue\"\n          (chooseYear)=\"onChooseValue('year', $event)\"\n          (chooseMonth)=\"onChooseValue('month', $event)\"\n          [enablePrev]=\"true\"\n          [enableNext]=\"true\"\n        ></calendar-header>\n      </div>\n    </div>\n  </div>\n</thy-picker>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyMonthPickerComponent)
                    }
                ]
            },] }
];
ThyMonthPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
ThyMonthPickerComponent.propDecorators = {
    thyFormat: [{ type: Input }]
};

class ThyRangePickerComponent extends BasePickerComponent {
    constructor(cdr, renderer, elementRef) {
        super(cdr);
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.isRange = true;
        renderer.addClass(elementRef.nativeElement, 'thy-calendar-picker');
    }
}
ThyRangePickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'thy-range-picker',
                exportAs: 'thyRangePicker',
                template: "<thy-picker\n  [isRange]=\"isRange\"\n  [value]=\"thyValue\"\n  (valueChange)=\"onValueChange($event)\"\n  [open]=\"thyOpen\"\n  [disabled]=\"thyDisabled\"\n  [format]=\"thyFormat\"\n  [allowClear]=\"thyAllowClear\"\n  [className]=\"thyOriginClassName\"\n  [autoFocus]=\"thyAutoFocus\"\n  [placeholder]=\"thyPlaceHolder\"\n  [readonly]=\"thyReadonly\"\n  [size]=\"thySize\"\n  [suffixIcon]=\"thySuffixIcon\"\n  [placement]=\"thyPlacement\"\n  (openChange)=\"onOpenChange($event)\"\n>\n  <date-popup\n    *ngIf=\"realOpenState\"\n    [isRange]=\"isRange\"\n    [showWeek]=\"showWeek\"\n    [panelMode]=\"thyMode\"\n    [defaultPickerValue]=\"thyDefaultPickerValue\"\n    (panelModeChange)=\"thyOnPanelChange.emit($event)\"\n    (showTimePickerChange)=\"onShowTimePickerChange($event)\"\n    [value]=\"thyValue\"\n    (valueChange)=\"onValueChange($event)\"\n    (calendarChange)=\"onCalendarChange($event)\"\n    [showTime]=\"thyShowTime\"\n    [mustShowTime]=\"withTime\"\n    [format]=\"thyFormat\"\n    [dateRender]=\"thyDateRender\"\n    [disabledDate]=\"thyDisabledDate\"\n    [minDate]=\"thyMinDate\"\n    [maxDate]=\"thyMaxDate\"\n    [className]=\"thyPanelClassName\"\n    (resultOk)=\"onResultOk()\"\n  ></date-popup>\n</thy-picker>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyRangePickerComponent)
                    }
                ]
            },] }
];
ThyRangePickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];

class ThyWeekPickerComponent extends BasePickerComponent {
    constructor(cdr, renderer, elementRef) {
        super(cdr);
        this.showWeek = true;
        renderer.addClass(elementRef.nativeElement, 'thy-calendar-picker');
    }
}
ThyWeekPickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'thy-week-picker',
                exportAs: 'thyWeekPicker',
                template: "<thy-picker\n  [isRange]=\"isRange\"\n  [value]=\"thyValue\"\n  (valueChange)=\"onValueChange($event)\"\n  [open]=\"thyOpen\"\n  [disabled]=\"thyDisabled\"\n  [format]=\"thyFormat\"\n  [allowClear]=\"thyAllowClear\"\n  [className]=\"thyOriginClassName\"\n  [autoFocus]=\"thyAutoFocus\"\n  [placeholder]=\"thyPlaceHolder\"\n  [readonly]=\"thyReadonly\"\n  [size]=\"thySize\"\n  [suffixIcon]=\"thySuffixIcon\"\n  [placement]=\"thyPlacement\"\n  (openChange)=\"onOpenChange($event)\"\n>\n  <date-popup\n    *ngIf=\"realOpenState\"\n    [isRange]=\"isRange\"\n    [showWeek]=\"showWeek\"\n    [panelMode]=\"thyMode\"\n    [defaultPickerValue]=\"thyDefaultPickerValue\"\n    (panelModeChange)=\"thyOnPanelChange.emit($event)\"\n    (showTimePickerChange)=\"onShowTimePickerChange($event)\"\n    [value]=\"thyValue\"\n    (valueChange)=\"onValueChange($event)\"\n    (calendarChange)=\"onCalendarChange($event)\"\n    [showTime]=\"thyShowTime\"\n    [mustShowTime]=\"withTime\"\n    [format]=\"thyFormat\"\n    [dateRender]=\"thyDateRender\"\n    [disabledDate]=\"thyDisabledDate\"\n    [minDate]=\"thyMinDate\"\n    [maxDate]=\"thyMaxDate\"\n    [className]=\"thyPanelClassName\"\n    (resultOk)=\"onResultOk()\"\n  ></date-popup>\n</thy-picker>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyWeekPickerComponent)
                    }
                ]
            },] }
];
ThyWeekPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];

class ThyYearPickerComponent extends HeaderPickerComponent {
    constructor(cdr, renderer, elementRef) {
        super(cdr);
        this.thyFormat = 'yyyy';
        this.endPanelMode = 'year';
        renderer.addClass(elementRef.nativeElement, 'thy-calendar-picker');
    }
}
ThyYearPickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'thy-year-picker',
                exportAs: 'thyYearPicker',
                template: "<thy-picker\n  [isRange]=\"false\"\n  [value]=\"thyValue\"\n  (valueChange)=\"onValueChange($event)\"\n  [open]=\"thyOpen\"\n  [disabled]=\"thyDisabled\"\n  [format]=\"thyFormat\"\n  [allowClear]=\"thyAllowClear\"\n  [className]=\"thyOriginClassName\"\n  [autoFocus]=\"thyAutoFocus\"\n  [placeholder]=\"thyPlaceHolder\"\n  [readonly]=\"thyReadonly\"\n  [size]=\"thySize\"\n  [suffixIcon]=\"thySuffixIcon\"\n  (openChange)=\"onOpenChange($event)\"\n>\n  <div *ngIf=\"realOpenState\">\n    <div class=\"thy-calendar-picker-container thy-calendar thy-calendar-month {{ thyPanelClassName }}\">\n      <div class=\"thy-calendar-header-wrap\">\n        <calendar-header\n          [disabledMonth]=\"thyDisabledDate\"\n          [disabledYear]=\"thyDisabledDate\"\n          [panelMode]=\"panelMode\"\n          (panelModeChange)=\"onPanelModeChange($event)\"\n          [value]=\"thyValue\"\n          (chooseYear)=\"onChooseValue('year', $event)\"\n          (chooseMonth)=\"onChooseValue('month', $event)\"\n          [enablePrev]=\"true\"\n          [enableNext]=\"true\"\n        ></calendar-header>\n      </div>\n    </div>\n  </div>\n</thy-picker>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyYearPickerComponent)
                    }
                ]
            },] }
];
ThyYearPickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
ThyYearPickerComponent.propDecorators = {
    thyFormat: [{ type: Input }]
};

const DATE_PICKER_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    // tslint:disable-next-line: no-use-before-declare
    useExisting: forwardRef(() => DatePickerRequiredValidator),
    multi: true
};
class DatePickerRequiredValidator {
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value != null && value !== false && `${value}` !== 'false';
    }
    validate(control) {
        return this.required ? this.validateRequired(control) : null;
    }
    validateRequired(control) {
        return isEmptyInputDateValue(control.value) ? { required: true } : null;
    }
}
DatePickerRequiredValidator.decorators = [
    { type: Directive, args: [{
                selector: '[thyDatePicker][required][formControlName],[thyDatePicker][required][formControl],[thyDatePicker][required][ngModel],thy-date-picker[required][formControlName],thy-date-picker[required][formControl],thy-date-picker[required][ngModel]',
                providers: [DATE_PICKER_REQUIRED_VALIDATOR]
            },] }
];
DatePickerRequiredValidator.propDecorators = {
    required: [{ type: Input }]
};
const RANGE_PICKER_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    // tslint:disable-next-line: no-use-before-declare
    useExisting: forwardRef(() => RangePickerRequiredValidator),
    multi: true
};
class RangePickerRequiredValidator {
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value != null && value !== false && `${value}` !== 'false';
    }
    validate(control) {
        return this.required ? this.validateRequired(control) : null;
    }
    validateRequired(control) {
        return isEmptyInputRangeValue(control.value) ? { required: true } : null;
    }
}
RangePickerRequiredValidator.decorators = [
    { type: Directive, args: [{
                selector: '[thyRangePicker][required][formControlName],[thyRangePicker][required][formControl],[thyRangePicker][required][ngModel],thy-range-picker[required][formControlName],thy-range-picker[required][formControl],thy-range-picker[required][ngModel]',
                providers: [RANGE_PICKER_REQUIRED_VALIDATOR]
            },] }
];
RangePickerRequiredValidator.propDecorators = {
    required: [{ type: Input }]
};
function isEmptyInputRangeValue(value) {
    return value == null || (instanceOfRangeEntry(value) && (value.begin == null || value.end == null));
}
function isEmptyInputDateValue(value) {
    return value == null || (instanceOfDateEntry(value) && value.date == null);
}

class ThyDatePickerFormatPipe {
    constructor(dateHelper) {
        this.dateHelper = dateHelper;
    }
    transform(originalValue, formatStr) {
        const { value, withTime } = transformDateValue(originalValue);
        if (!formatStr) {
            formatStr = withTime ? 'yyyy-MM-dd HH:mm' : 'yyyy-MM-dd';
        }
        if (!Array.isArray(value)) {
            return this.dateHelper.format(value, formatStr);
        }
        else {
            return value.map(date => this.dateHelper.format(date, formatStr)).join(' ~ ');
        }
    }
}
ThyDatePickerFormatPipe.decorators = [
    { type: Pipe, args: [{ name: 'thyDatePickerFormat' },] }
];
ThyDatePickerFormatPipe.ctorParameters = () => [
    { type: DateHelperService }
];
class ThyDatePickerFormatStringPipe {
    constructor(dateHelper) {
        this.dateHelper = dateHelper;
    }
    transform(originalValue) {
        const { withTime } = transformDateValue(originalValue);
        return withTime ? 'yyyy-MM-dd HH:mm' : 'yyyy-MM-dd';
    }
}
ThyDatePickerFormatStringPipe.decorators = [
    { type: Pipe, args: [{ name: 'thyDatePickerFormatString' },] }
];
ThyDatePickerFormatStringPipe.ctorParameters = () => [
    { type: DateHelperService }
];

class PickerDirective extends AbstractPickerComponent {
    constructor(elementRef, cdr, thyPopover) {
        super(cdr);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.thyPopover = thyPopover;
        this.showWeek = false;
        this.thyOnPanelChange = new EventEmitter();
        this.thyOnCalendarChange = new EventEmitter();
        this.thyMustShowTime = false;
        this.thyPlacement = 'bottom';
        this.offset = 4;
        this.hasBackdrop = true;
        this.thyStopPropagation = true;
        this.destroy$ = new Subject();
        this.el = this.elementRef.nativeElement;
        this.$click = fromEvent(this.el, 'click').pipe(tap(e => {
            if (this.thyStopPropagation) {
                e.stopPropagation();
            }
        }), mapTo(true));
    }
    get thyShowTime() {
        return this._showTime;
    }
    set thyShowTime(value) {
        this._showTime = typeof value === 'object' ? value : coerceBooleanProperty(value);
    }
    set thyOffset(value) {
        warnDeprecation(`thyOffset parameter will be deprecated, please use thyPopoverOptions instead.`);
        this.offset = value;
    }
    set thyHasBackdrop(value) {
        warnDeprecation(`thyHasBackdrop parameter will be deprecated, please use thyPopoverOptions instead.`);
        this.hasBackdrop = value;
    }
    openOverlay() {
        const popoverRef = this.thyPopover.open(DatePopupComponent, Object.assign({
            origin: this.el,
            hasBackdrop: this.hasBackdrop,
            backdropClass: 'thy-overlay-transparent-backdrop',
            offset: this.offset,
            initialState: {
                isRange: this.isRange,
                showWeek: this.showWeek,
                value: this.thyValue,
                showTime: this.thyShowTime,
                mustShowTime: this.withTime,
                format: this.thyFormat,
                dateRender: this.thyDateRender,
                disabledDate: this.thyDisabledDate,
                placeholder: this.thyPlaceHolder,
                className: this.thyPanelClassName,
                defaultPickerValue: this.thyDefaultPickerValue,
                minDate: this.thyMinDate,
                maxDate: this.thyMaxDate
            },
            placement: this.thyPlacement
        }, this.thyPopoverOptions));
        if (popoverRef) {
            const componentInstance = popoverRef.componentInstance;
            componentInstance.valueChange.pipe(takeUntil(this.destroy$)).subscribe((event) => this.onValueChange(event));
            componentInstance.calendarChange.pipe(takeUntil(this.destroy$)).subscribe((event) => {
                const rangeValue = coerceArray(event).map(x => x.nativeDate);
                this.thyOnCalendarChange.emit(rangeValue);
            });
            componentInstance.showTimePickerChange
                .pipe(takeUntil(this.destroy$))
                .subscribe((event) => this.onShowTimePickerChange(event));
            // tslint:disable-next-line: max-line-length
            componentInstance.ngOnChanges({ value: {} }); // dynamically created components don't call ngOnChanges, manual call
            popoverRef
                .afterOpened()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.thyOpenChange.emit(true));
            popoverRef
                .afterClosed()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.thyOpenChange.emit(false));
        }
    }
    closeOverlay() {
        this.thyPopover.close();
    }
    initActionSubscribe() {
        this.$click.pipe(debounceTime(50), takeUntil(this.destroy$)).subscribe(() => {
            if (!this.thyDisabled && !this.thyReadonly) {
                this.openOverlay();
            }
        });
    }
    ngAfterViewInit() {
        this.setDefaultTimePickerState();
        this.initActionSubscribe();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onValueChange(value) {
        this.restoreTimePickerState(value);
        super.onValueChange(value);
        this.closeOverlay();
    }
    // Displays the time directly when the time must be displayed by default
    setDefaultTimePickerState() {
        this.withTime = this.thyMustShowTime;
    }
    // Restore after clearing time to select whether the original picker time is displayed or not
    restoreTimePickerState(value) {
        if (!value) {
            this.withTime = this.thyMustShowTime || this.originWithTime;
        }
    }
    onShowTimePickerChange(show) {
        this.withTime = show;
    }
}
PickerDirective.decorators = [
    { type: Directive }
];
PickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ThyPopover }
];
PickerDirective.propDecorators = {
    thyDateRender: [{ type: Input }],
    thyMode: [{ type: Input }],
    thyOnPanelChange: [{ type: Output }],
    thyOnCalendarChange: [{ type: Output }],
    thyShowTime: [{ type: Input }],
    thyMustShowTime: [{ type: Input }],
    thyPlacement: [{ type: Input }],
    thyOffset: [{ type: Input }],
    thyHasBackdrop: [{ type: Input }],
    thyPopoverOptions: [{ type: Input }],
    thyStopPropagation: [{ type: Input }]
};

class ThyDatePickerDirective extends PickerDirective {
    constructor(elementRef, cdr, thyPopover) {
        super(elementRef, cdr, thyPopover);
        this.isRange = false;
    }
}
ThyDatePickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyDatePicker]',
                exportAs: 'thyDatePicker',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyDatePickerDirective)
                    }
                ]
            },] }
];
ThyDatePickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ThyPopover }
];

class ThyRangePickerDirective extends PickerDirective {
    constructor(elementRef, cdr, thyPopover) {
        super(elementRef, cdr, thyPopover);
        this.isRange = true;
    }
}
ThyRangePickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[thyRangePicker]',
                exportAs: 'thyRangePicker',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => ThyRangePickerDirective)
                    }
                ]
            },] }
];
ThyRangePickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ThyPopover }
];

registerLocaleData(localeZhHans, 'zh-Hans');
class ThyDatePickerModule {
}
ThyDatePickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, LibPackerModule, ThyIconModule, ThyInputModule, ThyPopoverModule],
                exports: [
                    ThyDatePickerComponent,
                    ThyRangePickerComponent,
                    ThyMonthPickerComponent,
                    ThyYearPickerComponent,
                    ThyWeekPickerComponent,
                    DatePickerRequiredValidator,
                    RangePickerRequiredValidator,
                    ThyDatePickerFormatPipe,
                    ThyDatePickerFormatStringPipe,
                    ThyDatePickerDirective,
                    ThyRangePickerDirective
                ],
                declarations: [
                    HeaderPickerComponent,
                    BasePickerComponent,
                    ThyPickerComponent,
                    ThyDatePickerComponent,
                    ThyMonthPickerComponent,
                    ThyYearPickerComponent,
                    ThyWeekPickerComponent,
                    ThyRangePickerComponent,
                    DatePickerRequiredValidator,
                    RangePickerRequiredValidator,
                    ThyDatePickerFormatPipe,
                    ThyDatePickerFormatStringPipe,
                    ThyDatePickerDirective,
                    ThyRangePickerDirective
                ],
                entryComponents: [DatePopupComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractPickerComponent, BasePickerComponent, CalendarFooterComponent, CalendarHeaderComponent, DATE_HELPER_SERVICE_FACTORY, DateHelperByDatePipe, DateHelperService, DatePickerRequiredValidator, DatePopupComponent, DateTableCellComponent, DateTableComponent, DecadePanelComponent, HeaderPickerComponent, InnerPopupComponent, LibPackerModule, MonthPanelComponent, MonthTableComponent, PickerDirective, RangePickerRequiredValidator, ThyDatePickerComponent, ThyDatePickerDirective, ThyDatePickerFormatPipe, ThyDatePickerFormatStringPipe, ThyDatePickerModule, ThyMonthPickerComponent, ThyPickerComponent, ThyRangePickerComponent, ThyRangePickerDirective, ThyWeekPickerComponent, ThyYearPickerComponent, YearPanelComponent, instanceOfDateEntry, instanceOfRangeEntry };
//# sourceMappingURL=ngx-tethys-date-picker.js.map
