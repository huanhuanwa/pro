import { InjectionToken, Component, ElementRef, Inject, Renderer2, NgZone, Input, EventEmitter, Output, ViewChild, HostListener, HostBinding, Injectable, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpClient, XhrFactory, HttpClientModule } from '@angular/common/http';
import { isArray, isString, coerceNumberValue, isNumber, coerceBooleanProperty, isEmpty, coerceArray } from 'ngx-tethys/util';
import { Subject, fromEvent, Observable, from } from 'rxjs';
import { takeUntil, tap, filter, mergeMap, map } from 'rxjs/operators';

// Multipurpose Internet Mail Extensions
const MIME_Map = {
    '.3gp': 'video/3gpp',
    '.apk': 'application/vnd.android.package-archive',
    '.asf': 'video/x-ms-asf',
    '.avi': 'video/x-msvideo',
    '.bin': 'application/octet-stream',
    '.bmp': 'image/bmp',
    '.c': 'text/plain',
    '.class': 'application/octet-stream',
    '.conf': 'text/plain',
    '.cpp': 'text/plain',
    '.doc': 'application/msword',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.xls': 'application/vnd.ms-excel,.xls',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,.xlsx',
    '.xlsb': 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
    '.xlsm': 'application/vnd.ms-excel.sheet.macroenabled.12',
    '.xltx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
    '.exe': 'application/octet-stream',
    '.gif': 'image/gif',
    '.gtar': 'application/x-gtar',
    '.gz': 'application/x-gzip',
    '.h': 'text/plain',
    '.htm': 'text/html',
    '.html': 'text/html',
    '.jar': 'application/java-archive',
    '.java': 'text/plain',
    '.jpeg': 'image/jpeg',
    '.jpg': 'image/jpeg',
    '.js': 'application/x-javascript',
    '.json': 'application/json',
    '.log': 'text/plain',
    '.m3u': 'audio/x-mpegurl',
    '.m4a': 'audio/mp4a-latm',
    '.m4b': 'audio/mp4a-latm',
    '.m4p': 'audio/mp4a-latm',
    '.m4u': 'video/vnd.mpegurl',
    '.m4v': 'video/x-m4v',
    '.mov': 'video/quicktime',
    '.mp2': 'audio/x-mpeg',
    '.mp3': 'audio/x-mpeg',
    '.mp4': 'video/mp4',
    '.mpc': 'application/vnd.mpohun.certificate',
    '.mpe': 'video/mpeg',
    '.mpeg': 'video/mpeg',
    '.mpg': 'video/mpeg',
    '.mpg4': 'video/mp4',
    '.mpga': 'audio/mpeg',
    '.msg': 'application/vnd.ms-outlook',
    '.ogg': 'audio/ogg',
    '.pdf': 'application/pdf',
    '.png': 'image/png',
    '.pps': 'application/vnd.ms-powerpoint',
    '.ppt': 'application/vnd.ms-powerpoint',
    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    '.prop': 'text/plain',
    '.rc': 'text/plain',
    '.rmvb': 'audio/x-pn-realaudio',
    '.rtf': 'application/rtf',
    '.sh': 'text/plain',
    '.tar': 'application/x-tar',
    '.tgz': 'application/x-compressed',
    '.txt': 'text/plain',
    '.wav': 'audio/x-wav',
    '.wma': 'audio/x-ms-wma',
    '.wmv': 'audio/x-ms-wmv',
    '.wps': 'application/vnd.ms-works',
    '.xml': 'text/plain',
    '.z': 'application/x-compress',
    '.zip': 'application/x-zip-compressed',
    '': '*/*'
};

function mimeTypeConvert(value) {
    let inputTypes;
    const acceptTypes = [];
    if (isArray(value)) {
        inputTypes = value;
    }
    else if (isString(value)) {
        inputTypes = value.split(',');
    }
    else {
        inputTypes = [];
    }
    if (inputTypes.length > 0) {
        inputTypes.forEach(n => {
            if (MIME_Map[n]) {
                acceptTypes.push(MIME_Map[n]);
            }
            else {
                acceptTypes.push(n);
            }
        });
    }
    return acceptTypes.join(',');
}

const THY_UPLOADER_DEFAULT_OPTIONS = new InjectionToken('thy-uploader-default-options');
const ɵ0 = {
    sizeThreshold: 0,
    sizeExceedsHandler: sizeExceedsHandler
};
const THY_UPLOADER_DEFAULT_OPTIONS_PROVIDER = {
    provide: THY_UPLOADER_DEFAULT_OPTIONS,
    useValue: ɵ0
};
function sizeExceedsHandler(event) {
    const exceedsFilesMessage = event.exceedsFiles
        .map(item => {
        return `file: ${item.name}, size: ${item.size}`;
    })
        .join(',');
    console.error(`some files(${exceedsFilesMessage}) size exceeds threshold ${event.sizeThreshold}`);
}

class FileSelectBaseComponent {
    constructor(elementRef, defaultConfig, renderer, ngZone) {
        this.elementRef = elementRef;
        this.defaultConfig = defaultConfig;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.sizeThreshold = defaultConfig.sizeThreshold;
        this.sizeExceedsHandler = defaultConfig.sizeExceedsHandler;
    }
    set thySizeThreshold(value) {
        const sizeThreshold = coerceNumberValue(value);
        if (isNumber(sizeThreshold)) {
            this.sizeThreshold = sizeThreshold;
        }
    }
    set thySizeExceedsHandler(value) {
        if (value) {
            this.sizeExceedsHandler = value;
        }
    }
    handleSizeExceeds(event, files) {
        let sizeExceedsFiles = files.filter(item => item.size / 1024 > this.sizeThreshold);
        if (sizeExceedsFiles.length > 0) {
            const sizeExceedContext = {
                files: files,
                exceedsFiles: sizeExceedsFiles,
                nativeEvent: event,
                sizeThreshold: this.sizeThreshold
            };
            return this.sizeExceedsHandler(sizeExceedContext);
        }
        return files;
    }
    selectFiles(event, files, eventEmitter) {
        let successFiles = files;
        if (this.sizeThreshold && this.sizeThreshold > 0) {
            successFiles = this.handleSizeExceeds(event, files);
        }
        if (successFiles) {
            eventEmitter.emit({
                files: successFiles,
                nativeEvent: event
            });
        }
    }
}
FileSelectBaseComponent.decorators = [
    { type: Component, args: [{
                template: ``
            },] }
];
FileSelectBaseComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [THY_UPLOADER_DEFAULT_OPTIONS,] }] },
    { type: Renderer2 },
    { type: NgZone }
];
FileSelectBaseComponent.propDecorators = {
    thySizeThreshold: [{ type: Input }],
    thySizeExceedsHandler: [{ type: Input }]
};

class ThyFileSelectComponent extends FileSelectBaseComponent {
    constructor(elementRef, defaultConfig) {
        super(elementRef, defaultConfig);
        this.elementRef = elementRef;
        this.defaultConfig = defaultConfig;
        this.thyOnFileSelect = new EventEmitter();
    }
    set thyMultiple(value) {
        this.multiple = coerceBooleanProperty(value);
        if (this.multiple) {
            this.fileInput.nativeElement.setAttribute('multiple', '');
        }
        else {
            this.fileInput.nativeElement.removeAttribute('multiple');
        }
    }
    set thyAcceptFolder(value) {
        this.acceptFolder = coerceBooleanProperty(value);
        if (this.acceptFolder) {
            this.fileInput.nativeElement.setAttribute('webkitdirectory', '');
        }
        else {
            this.fileInput.nativeElement.removeAttribute('webkitdirectory');
        }
    }
    set thyAcceptType(value) {
        this.acceptType = mimeTypeConvert(value);
    }
    set thySizeThreshold(value) {
        this.sizeThreshold = value;
    }
    click($event) {
        this.fileInput.nativeElement.click();
    }
    selectFile($event) {
        const files = this.fileInput.nativeElement.files;
        if (files && files.length > 0) {
            this.selectFiles($event, Array.from(files), this.thyOnFileSelect);
            this.fileInput.nativeElement.value = '';
        }
    }
    ngOnInit() { }
    ngOnDestroy() { }
}
ThyFileSelectComponent.decorators = [
    { type: Component, args: [{
                selector: '[thyFileSelect],thy-file-select',
                template: "<ng-content></ng-content>\n<input style=\"width: 0; height: 0\" thyStopPropagation=\"true\" [hidden]=\"'true'\" #fileInput type=\"file\" (change)=\"selectFile($event)\"\n    [attr.accept]=\"acceptType\">\n"
            },] }
];
ThyFileSelectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [THY_UPLOADER_DEFAULT_OPTIONS,] }] }
];
ThyFileSelectComponent.propDecorators = {
    thyOnFileSelect: [{ type: Output }],
    fileInput: [{ type: ViewChild, args: ['fileInput', { static: true },] }],
    thyMultiple: [{ type: Input }],
    thyAcceptFolder: [{ type: Input }],
    thyAcceptType: [{ type: Input }],
    thySizeThreshold: [{ type: Input }],
    click: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class ThyFileDropComponent extends FileSelectBaseComponent {
    constructor(elementRef, renderer, ngZone, defaultConfig) {
        super(elementRef, defaultConfig);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.defaultConfig = defaultConfig;
        this.isDragOver = false;
        this.thyOnDrop = new EventEmitter();
        this.ngUnsubscribe$ = new Subject();
    }
    set thyFileDropClassName(value) {
        this.dragOverCustomClass = value;
    }
    set thyAcceptType(value) {
        this.acceptType = mimeTypeConvert(value);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            fromEvent(this.elementRef.nativeElement, 'dragenter')
                .pipe(takeUntil(this.ngUnsubscribe$), tap((event) => {
                event.preventDefault();
            }), filter(event => event.dataTransfer.items && event.dataTransfer.items.length > 0))
                .subscribe((event) => {
                if (this.checkRejectFolderAndHtmlElement(event)) {
                    const files = this.filterFilesOrItems(Array.from(event.dataTransfer.items));
                    if (!isEmpty(files)) {
                        this.ngZone.run(() => {
                            this.isDragOver = true;
                            this.toggleDropOverClassName();
                        });
                    }
                }
            });
            fromEvent(this.elementRef.nativeElement, 'dragover')
                .pipe(takeUntil(this.ngUnsubscribe$))
                .subscribe((event) => {
                event.preventDefault();
            });
            fromEvent(this.elementRef.nativeElement, 'dragleave')
                .pipe(takeUntil(this.ngUnsubscribe$))
                .subscribe((event) => {
                this.ngZone.run(() => {
                    if (!this.elementRef.nativeElement.contains(event.fromElement)) {
                        this.resetDragOver();
                        this.toggleDropOverClassName();
                    }
                });
            });
            fromEvent(this.elementRef.nativeElement, 'drop')
                .pipe(takeUntil(this.ngUnsubscribe$), tap((event) => {
                event.preventDefault();
            }))
                .subscribe((event) => {
                this.ngZone.run(() => {
                    if (this.checkRejectFolderAndHtmlElement(event)) {
                        const files = this.filterFilesOrItems(event.dataTransfer ? Array.from(event.dataTransfer.files) : []);
                        if (!isEmpty(files)) {
                            this.selectFiles(event, Array.from(event.dataTransfer.files), this.thyOnDrop);
                        }
                    }
                    this.resetDragOver();
                    this.toggleDropOverClassName();
                });
            });
        });
    }
    checkRejectFolderAndHtmlElement(event) {
        // 排除文件夹和HTML元素拖拽
        const items = event.dataTransfer ? event.dataTransfer.items : [];
        let res = true;
        for (let index = 0; index < items.length; index++) {
            const item = items[index];
            const entry = this.getAsEntry(item);
            if (item.kind !== 'file' || (entry && !entry.isFile)) {
                res = false;
                // console.error(`file extensions not support drag upload, kind: ${item.kind}, type: ${item.type}`);
            }
        }
        return res;
    }
    getAsEntry(item) {
        let entry;
        if (item['getAsEntry']) {
            entry = item['getAsEntry']();
        }
        else if (item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
        }
        return entry;
    }
    filterFilesOrItems(items) {
        if (this.acceptType && this.acceptType != '*/*') {
            return items.filter(item => {
                return this.acceptType.includes(item.type);
            });
        }
        else {
            return Array.from(items);
        }
    }
    toggleDropOverClassName() {
        if (this.dragOverCustomClass) {
            if (this.isDragOver) {
                this.renderer.addClass(this.elementRef.nativeElement, this.dragOverCustomClass);
            }
            else {
                this.renderer.removeClass(this.elementRef.nativeElement, this.dragOverCustomClass);
            }
        }
    }
    setDragOverState(isDragOver) {
        this.isDragOver = isDragOver;
    }
    resetDragOver() {
        this.setDragOverState(false);
    }
    ngOnDestroy() {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
}
ThyFileDropComponent.decorators = [
    { type: Component, args: [{
                selector: '[thyFileDrop]',
                template: `
        <ng-content></ng-content>
    `
            },] }
];
ThyFileDropComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [THY_UPLOADER_DEFAULT_OPTIONS,] }] }
];
ThyFileDropComponent.propDecorators = {
    isDragOver: [{ type: HostBinding, args: ['class.drop-over',] }, { type: HostBinding, args: ['class.thy-drop-over',] }],
    thyFileDropClassName: [{ type: Input }],
    thyAcceptType: [{ type: Input }],
    thyOnDrop: [{ type: Output }]
};

var ThyUploadStatus;
(function (ThyUploadStatus) {
    ThyUploadStatus["pending"] = "pending";
    ThyUploadStatus["started"] = "started";
    ThyUploadStatus["uploading"] = "uploading";
    ThyUploadStatus["done"] = "done";
})(ThyUploadStatus || (ThyUploadStatus = {}));
class ThyUploaderService {
    constructor(http, xhrFactory) {
        this.http = http;
        this.xhrFactory = xhrFactory;
    }
    secondsToHuman(sec) {
        return new Date(sec * 1000).toISOString().substr(11, 8);
    }
    humanizeBytes(bytes) {
        if (bytes === 0) {
            return '0 Byte';
        }
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    normalizeUploadFiles(uploadFiles) {
        coerceArray(uploadFiles).forEach(uploadFile => {
            if (!uploadFile.progress) {
                uploadFile.progress = {
                    status: ThyUploadStatus.pending,
                    percentage: 0,
                    startTime: 0
                };
            }
        });
    }
    // private uploadByHttp(observer: Subscriber<ThyUploadResponse>, uploadFile: ThyUploadFile) {
    //     const time: number = new Date().getTime();
    //     let speed = 0;
    //     let estimatedTime: number | null = null;
    //     uploadFile.progress = {
    //         status: ThyUploadStatus.started,
    //         percentage: 0,
    //         startTime: time
    //     };
    //     const formData = new FormData();
    //     Object.keys(uploadFile.data || {}).forEach(key => formData.append(key, uploadFile.data[key]));
    //     formData.append(uploadFile.fileField || 'file', uploadFile.nativeFile, uploadFile.fileName);
    //     const headers = {
    //         'Content-Type': 'multipart/form-data'
    //     };
    //     Object.keys(uploadFile.headers || {}).forEach(key => (headers[key] = uploadFile.headers[key]));
    //     const subscription = this.http
    //         .post(uploadFile.url, formData, {
    //             headers: headers,
    //             reportProgress: true,
    //             observe: 'events',
    //             withCredentials: uploadFile.withCredentials ? true : false
    //         })
    //         .subscribe(
    //             (event: HttpEvent<any>) => {
    //                 console.log('Subscribe data', event);
    //                 switch (event.type) {
    //                     case HttpEventType.Sent:
    //                         observer.next({ status: ThyUploadStatus.started, uploadFile: uploadFile });
    //                         break;
    //                     case HttpEventType.UploadProgress:
    //                         let percentage = Math.round((event.loaded * 100) / event.total);
    //                         if (percentage === 100) {
    //                             percentage = 99;
    //                         }
    //                         const diff = new Date().getTime() - time;
    //                         speed = Math.round((event.loaded / diff) * 1000);
    //                         const progressStartTime = (uploadFile.progress && uploadFile.progress.startTime) || new Date().getTime();
    //                         estimatedTime = Math.ceil((event.total - event.loaded) / speed);
    //                         uploadFile.progress.status = ThyUploadStatus.uploading;
    //                         uploadFile.progress.percentage = percentage;
    //                         uploadFile.progress.speed = speed;
    //                         uploadFile.progress.speedHuman = `${this.humanizeBytes(speed)}/s`;
    //                         uploadFile.progress.startTime = progressStartTime;
    //                         uploadFile.progress.estimatedTime = estimatedTime;
    //                         uploadFile.progress.estimatedTimeHuman = this.secondsToHuman(estimatedTime);
    //                         observer.next({ status: ThyUploadStatus.uploading, uploadFile: uploadFile });
    //                         break;
    //                     case HttpEventType.Response:
    //                         uploadFile.response = event.body;
    //                         observer.next({ status: ThyUploadStatus.done, uploadFile: uploadFile });
    //                         break;
    //                     default:
    //                         throw new Error(`Unhandled event: ${event.type}`);
    //                 }
    //             },
    //             error => {
    //                 observer.error(error);
    //             }
    //         );
    //     return subscription;
    // }
    uploadByXhr(observer, uploadFile) {
        const xhr = this.xhrFactory.build();
        const time = new Date().getTime();
        let speed = 0;
        let estimatedTime = null;
        uploadFile.progress = {
            status: ThyUploadStatus.started,
            percentage: 0,
            startTime: time
        };
        xhr.upload.addEventListener('progress', (event) => {
            if (event.lengthComputable) {
                let percentage = Math.round((event.loaded * 100) / event.total);
                if (percentage === 100) {
                    percentage = 99;
                }
                const diff = new Date().getTime() - time;
                speed = Math.round((event.loaded / diff) * 1000);
                const progressStartTime = (uploadFile.progress && uploadFile.progress.startTime) || new Date().getTime();
                estimatedTime = Math.ceil((event.total - event.loaded) / speed);
                uploadFile.progress.status = ThyUploadStatus.uploading;
                uploadFile.progress.percentage = percentage;
                uploadFile.progress.speed = speed;
                uploadFile.progress.speedHuman = `${this.humanizeBytes(speed)}/s`;
                uploadFile.progress.startTime = progressStartTime;
                uploadFile.progress.estimatedTime = estimatedTime;
                uploadFile.progress.estimatedTimeHuman = this.secondsToHuman(estimatedTime);
                observer.next({ status: ThyUploadStatus.uploading, uploadFile: uploadFile });
            }
        }, false);
        xhr.upload.addEventListener('error', (e) => {
            observer.error(e);
            observer.complete();
        });
        xhr.onreadystatechange = () => {
            if (xhr.readyState === XMLHttpRequest.DONE) {
                const speedTime = (new Date().getTime() - uploadFile.progress.startTime) * 1000;
                const speedAverage = Math.round(uploadFile.nativeFile.size / speedTime);
                uploadFile.progress.status = ThyUploadStatus.done;
                uploadFile.progress.percentage = 100;
                uploadFile.progress.speed = speedAverage;
                uploadFile.progress.speedHuman = `${this.humanizeBytes(speed)}/s`;
                uploadFile.progress.estimatedTime = estimatedTime;
                uploadFile.progress.estimatedTimeHuman = this.secondsToHuman(estimatedTime || 0);
                uploadFile.responseStatus = xhr.status;
                try {
                    uploadFile.response = JSON.parse(xhr.response);
                }
                catch (e) {
                    uploadFile.response = xhr.response;
                }
                // file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());
                observer.next({ status: ThyUploadStatus.done, uploadFile: uploadFile });
                observer.complete();
            }
        };
        xhr.open(uploadFile.method, uploadFile.url, true);
        xhr.withCredentials = uploadFile.withCredentials ? true : false;
        try {
            const formData = new FormData();
            Object.keys(uploadFile.data || {}).forEach(key => formData.append(key, uploadFile.data[key]));
            Object.keys(uploadFile.headers || {}).forEach(key => xhr.setRequestHeader(key, uploadFile.headers[key]));
            formData.append(uploadFile.fileField || 'file', uploadFile.nativeFile, uploadFile.fileName);
            observer.next({ status: ThyUploadStatus.started, uploadFile: uploadFile });
            xhr.send(formData);
        }
        catch (error) {
            observer.error(error);
            observer.complete();
        }
        return xhr;
    }
    ensureFileName(uploadFile) {
        uploadFile.fileName = uploadFile.fileName || uploadFile.nativeFile.name;
    }
    /**
     * 上传单个文件
     * @param uploadFile 上传文件对象
     */
    upload(uploadFile) {
        this.ensureFileName(uploadFile);
        return new Observable(observer => {
            const xhr = this.uploadByXhr(observer, uploadFile);
            return () => {
                xhr.abort();
            };
        });
    }
    /**
     * 并发上传多个文件
     * @param uploadFiles 上传文件列表
     * @param concurrent 并发上传数, 默认 5
     * @param options onStared, onDone 回调
     */
    uploadBulk(uploadFiles, concurrent = 5, options) {
        this.normalizeUploadFiles(uploadFiles);
        const result = from(uploadFiles).pipe(mergeMap(uploadFile => {
            return this.upload(uploadFile).pipe(tap(uploadResponse => {
                if (options && options.onStarted && uploadResponse.status === ThyUploadStatus.started) {
                    options.onStarted(uploadResponse.uploadFile);
                }
                if (options && options.onDone && uploadResponse.status === ThyUploadStatus.done) {
                    options.onDone(uploadResponse.uploadFile);
                }
            }));
        }, concurrent), map(response => {
            return response;
        }));
        return result;
    }
}
ThyUploaderService.decorators = [
    { type: Injectable }
];
ThyUploaderService.ctorParameters = () => [
    { type: HttpClient },
    { type: XhrFactory }
];

// import { ThyDirectiveModule } from 'ngx-tethys/directive';
class ThyUploaderModule {
}
ThyUploaderModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ThyFileSelectComponent, ThyFileDropComponent, FileSelectBaseComponent],
                imports: [CommonModule, HttpClientModule],
                entryComponents: [ThyFileDropComponent],
                providers: [ThyUploaderService, THY_UPLOADER_DEFAULT_OPTIONS_PROVIDER],
                exports: [ThyFileSelectComponent, ThyFileDropComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { THY_UPLOADER_DEFAULT_OPTIONS, THY_UPLOADER_DEFAULT_OPTIONS_PROVIDER, ThyFileDropComponent, ThyFileSelectComponent, ThyUploadStatus, ThyUploaderModule, ThyUploaderService, sizeExceedsHandler, ɵ0, FileSelectBaseComponent as ɵa };
//# sourceMappingURL=ngx-tethys-uploader.js.map
